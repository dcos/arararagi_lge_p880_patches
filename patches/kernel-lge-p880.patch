diff --git a/arch/arm/boot/compressed/Makefile b/arch/arm/boot/compressed/Makefile
index a232975..d0f0ffe 100644
--- a/arch/arm/boot/compressed/Makefile
+++ b/arch/arm/boot/compressed/Makefile
@@ -5,6 +5,7 @@
 #
 
 OBJS		=
+plus_sec := $(call as-instr,.arch_extension sec,+sec)
 
 # Ensure that MMCIF loader code appears early in the image
 # to minimise that number of bocks that have to be read in
@@ -21,9 +22,15 @@ OBJS		+= sdhi-shmobile.o
 OBJS		+= sdhi-sh7372.o
 endif
 
-AFLAGS_head.o += -DTEXT_OFFSET=$(TEXT_OFFSET)
+AFLAGS_head.o += -DTEXT_OFFSET=$(TEXT_OFFSET) -Wa,-march=armv7-a$(plus_sec)
 HEAD	= head.o
-OBJS	+= misc.o decompress.o
+
+AFLAGS_misc.o +=-Wa,-march=armv7-a$(plus_sec)
+MISC	= misc.o
+
+AFLAGS_decompress.o += -Wa,-march=armv7-a$(plus_sec)
+DECOMPRESS	= decompress.o
+
 FONTC	= $(srctree)/drivers/video/console/font_acorn_8x8.c
 
 # string library code (-Os is enforced to keep it much smaller)
@@ -112,7 +119,8 @@ endif
 
 targets       := vmlinux vmlinux.lds \
 		 piggy.$(suffix_y) piggy.$(suffix_y).o \
-		 lib1funcs.o lib1funcs.S font.o font.c head.o misc.o $(OBJS)
+		 lib1funcs.o lib1funcs.S font.o font.c head.o misc.o \
+		 decompress.o $(OBJS)
 
 # Make sure files are removed during clean
 extra-y       += piggy.gzip piggy.lzo piggy.lzma lib1funcs.S $(libfdt) $(libfdt_hdrs)
@@ -146,6 +154,7 @@ LDFLAGS_vmlinux += -X
 LDFLAGS_vmlinux += -T
 
 # For __aeabi_uidivmod
+AFLAGS_lib1funcs.o +=-Wa,-march=armv7-a$(plus_sec)
 lib1funcs = $(obj)/lib1funcs.o
 
 $(obj)/lib1funcs.S: $(srctree)/arch/$(SRCARCH)/lib/lib1funcs.S
@@ -164,7 +173,8 @@ bad_syms=$$($(CROSS_COMPILE)nm $@ | sed -n 's/^.\{8\} [bc] \(.*\)/\1/p') && \
   ( echo "following symbols must have non local/private scope:" >&2; \
     echo "$$bad_syms" >&2; rm -f $@; false )
 
-$(obj)/vmlinux: $(obj)/vmlinux.lds $(obj)/$(HEAD) $(obj)/piggy.$(suffix_y).o \
+$(obj)/vmlinux: $(obj)/vmlinux.lds $(obj)/$(HEAD) $(obj)/$(MISC) \
+	 	$(obj)/$(DECOMPRESS) $(obj)/piggy.$(suffix_y).o \
 	 	$(addprefix $(obj)/, $(OBJS)) $(lib1funcs) FORCE
 	$(call if_changed,ld)
 	@$(check_for_bad_syms)
@@ -172,6 +182,7 @@ $(obj)/vmlinux: $(obj)/vmlinux.lds $(obj)/$(HEAD) $(obj)/piggy.$(suffix_y).o \
 $(obj)/piggy.$(suffix_y): $(obj)/../Image FORCE
 	$(call if_changed,$(suffix_y))
 
+AFLAGS_piggy.$(suffix_y).o += -Wa,-march=armv7-a$(plus_sec)
 $(obj)/piggy.$(suffix_y).o:  $(obj)/piggy.$(suffix_y) FORCE
 
 CFLAGS_font.o := -Dstatic=
diff --git a/arch/arm/mach-tegra/baseband-xmm-power.c b/arch/arm/mach-tegra/baseband-xmm-power.c
index 487c244..a8c17a3 100644
--- a/arch/arm/mach-tegra/baseband-xmm-power.c
+++ b/arch/arm/mach-tegra/baseband-xmm-power.c
@@ -47,7 +47,7 @@ MODULE_LICENSE("GPL");
 unsigned long modem_ver = XMM_MODEM_VER_1145; //XMM_MODEM_VER_1121;
 EXPORT_SYMBOL(modem_ver);
 
-unsigned long modem_flash=1;		//                               
+unsigned long modem_flash=1;
 EXPORT_SYMBOL(modem_flash);
 
 unsigned long modem_pm = 1;
@@ -90,12 +90,12 @@ static struct usb_device_id xmm_pm_ids[] = {
 };
 
 static struct gpio tegra_baseband_gpios[] = {
-	{ -1, GPIOF_OUT_INIT_LOW,  "BB_RSTn" },
-	{ -1, GPIOF_OUT_INIT_LOW,  "BB_ON"   },
-	{ -1, GPIOF_OUT_INIT_LOW,  "IPC_BB_WAKE" },
-	{ -1, GPIOF_IN,            "IPC_AP_WAKE" },
-	{ -1, GPIOF_OUT_INIT_HIGH, "IPC_HSIC_ACTIVE" },
-	{ -1, GPIOF_IN,            "IPC_HSIC_SUS_REQ" },
+	{ -1, GPIOF_OUT_INIT_LOW,	"BB_RSTn" },
+	{ -1, GPIOF_OUT_INIT_LOW,	"BB_ON" },
+	{ -1, GPIOF_OUT_INIT_LOW,	"IPC_BB_WAKE" },
+	{ -1, GPIOF_IN,			"IPC_AP_WAKE" },
+	{ -1, GPIOF_OUT_INIT_HIGH,	"IPC_HSIC_ACTIVE" },
+	{ -1, GPIOF_IN,			"IPC_HSIC_SUS_REQ" },
 };
 
 static enum {
@@ -148,6 +148,15 @@ static void baseband_xmm_power_L2_resume(void);
 static int baseband_xmm_power_driver_handle_resume(struct baseband_power_platform_data *data);
 #define CP_RESET_SEQUENCE
 
+
+#define PR_TRACE(msg) do {\
+	pr_info("ARARARAGI " msg, __LINE__);\
+	dump_stack();\
+} while (0)
+
+// Just disable the wake lock for now
+#define wake_lock(x)
+
 static inline void baseband_xmm_power_msleep(u32 t)
 {
 	/*
@@ -165,7 +174,7 @@ static int baseband_modem_power_on(struct baseband_power_platform_data *data)
 	gpio_set_value(baseband_power_driver_data->
 		modem.xmm.ipc_hsic_active, 1);
 	//pr_debug("ipc_hsic_active -> 1 \n");
-	pr_debug("GPIO [W]: Host_active -> 1 \n"); 
+	pr_debug("GPIO [W]: Host_active -> 1 \n");
 
 	/* reset / power on sequence */
 #ifndef CP_RESET_SEQUENCE
@@ -180,7 +189,7 @@ static int baseband_modem_power_on(struct baseband_power_platform_data *data)
 	mdelay(50);
 	gpio_set_value(data->modem.xmm.bb_rst, 0);
 	mdelay(200);
-	gpio_set_value(data->modem.xmm.bb_rst, 1);	
+	gpio_set_value(data->modem.xmm.bb_rst, 1);
 	mdelay(50);
 
 	gpio_set_value(data->modem.xmm.bb_on, 1);
@@ -199,7 +208,7 @@ static int baseband_xmm_power_on(struct platform_device *device)
 		= (struct baseband_power_platform_data *)
 			device->dev.platform_data;
 	int ret;
-				
+
 	pr_debug("%s {\n", __func__);
 
 	/* check for platform data */
@@ -208,8 +217,8 @@ static int baseband_xmm_power_on(struct platform_device *device)
 		return -EINVAL;
 	}
 
-     if (baseband_xmm_powerstate != BBXMM_PS_UNINIT)
-            return -EINVAL;
+	if (baseband_xmm_powerstate != BBXMM_PS_UNINIT)
+		return -EINVAL;
 
 	/* reset the state machine */
 	baseband_xmm_powerstate = BBXMM_PS_INIT;
@@ -242,7 +251,7 @@ static int baseband_xmm_power_on(struct platform_device *device)
 			pr_debug("%s call baseband_modem_power_on\n", __func__);
 			baseband_modem_power_on(data);
 		}
-	} else {                
+	} else {
 		if (modem_ver >= XMM_MODEM_VER_1145) {
 			pr_debug("%s: ver > 1145: IPC_AP_WAKE_IRQ_READY\n", __func__);
 			ipc_ap_wake_state = IPC_AP_WAKE_IRQ_READY;
@@ -251,15 +260,15 @@ static int baseband_xmm_power_on(struct platform_device *device)
 			enum_repeat = ENUM_REPEAT_TRY_CNT;
 			printk("##@%s forced_abort_hubevent <- 0\n", __func__);
 			forced_abort_hubevent = 0;
-	
+
 			baseband_xmm_power_work->state = BBXMM_WORK_INIT;
 			queue_work(workqueue,(struct work_struct *) baseband_xmm_power_work);
 		} else
 			pr_err("%s: Error, no support cp ver\n", __func__);
 	}
-    ret = enable_irq_wake(gpio_to_irq(data->modem.xmm.ipc_ap_wake));
-    if (ret < 0)
-           pr_err("%s: enable_irq_wake error\n", __func__);
+	ret = enable_irq_wake(gpio_to_irq(data->modem.xmm.ipc_ap_wake));
+	if (ret < 0)
+		pr_err("%s: enable_irq_wake error\n", __func__);
 	pr_debug("%s }\n", __func__);
 
 	return 0;
@@ -269,14 +278,14 @@ static int baseband_xmm_power_off(struct platform_device *device)
 {
 	struct baseband_power_platform_data *data;
 	int ret;
-    unsigned long flags;
+	unsigned long flags;
+
+	enum_success = false;
 
-    enum_success = false;
-    
 	pr_debug("%s {\n", __func__);
 
 	if (baseband_xmm_powerstate == BBXMM_PS_UNINIT)
-	    return -EINVAL;
+		return -EINVAL;
 
 	/* check for device / platform data */
 	if (!device) {
@@ -289,16 +298,16 @@ static int baseband_xmm_power_off(struct platform_device *device)
 		return -EINVAL;
 	}
 
-    ipc_ap_wake_state = IPC_AP_WAKE_UNINIT;
-    ret = disable_irq_wake(gpio_to_irq(data->modem.xmm.ipc_ap_wake));
-    if (ret < 0)
-             pr_err("%s: disable_irq_wake error\n", __func__);
+	ipc_ap_wake_state = IPC_AP_WAKE_UNINIT;
+	ret = disable_irq_wake(gpio_to_irq(data->modem.xmm.ipc_ap_wake));
+	if (ret < 0)
+		pr_err("%s: disable_irq_wake error\n", __func__);
 
 	if (modem_flash && modem_ver >= XMM_MODEM_VER_1145) {
 		/* unregister usb host controller */
 		pr_debug("%s: hsic device: %p\n", __func__, data->modem.xmm.hsic_device);
-                flush_workqueue(workqueue);
-        
+		flush_workqueue(workqueue);
+
 		if (data->hsic_unregister && !register_hsic_device)
 		{
 			data->hsic_unregister(data->modem.xmm.hsic_device);
@@ -310,11 +319,11 @@ static int baseband_xmm_power_off(struct platform_device *device)
 		/* set IPC_HSIC_ACTIVE low */
 		gpio_set_value(baseband_power_driver_data->modem.xmm.ipc_hsic_active, 0);
 		//pr_debug("ipc_hsic_active -> 0 \n");
-		pr_debug("GPIO [W]: Host_active -> 0 \n"); 
+		pr_debug("GPIO [W]: Host_active -> 0 \n");
 
 		/* drive bb_rst low */
 		gpio_set_value(data->modem.xmm.bb_rst, 0);
-		pr_debug("GPIO [W]: CP_rst -> 0 \n"); 
+		pr_debug("GPIO [W]: CP_rst -> 0 \n");
 	} else {
 		/* unregister usb host controller */
 		pr_debug("%s: hsic device: %p\n", __func__, data->modem.xmm.hsic_device);
@@ -325,24 +334,24 @@ static int baseband_xmm_power_off(struct platform_device *device)
 
 		/* set IPC_HSIC_ACTIVE low */
 		gpio_set_value(baseband_power_driver_data->modem.xmm.ipc_hsic_active, 0);
-		pr_debug("GPIO [W]: Host_active -> 0 \n"); 
+		pr_debug("GPIO [W]: Host_active -> 0 \n");
 
 		/* wait 20 ms */
 		mdelay(20);
 
 		/* drive bb_rst low */
 		gpio_set_value(data->modem.xmm.bb_rst, 0);
-		pr_debug("GPIO [W]: CP_rst -> 0 \n"); 		
+		pr_debug("GPIO [W]: CP_rst -> 0 \n");
 		mdelay(1);
 	}
 
 	baseband_xmm_powerstate = BBXMM_PS_UNINIT;
 	modem_sleep_flag = false;
 	CP_initiated_L2toL0 = false;
-    spin_lock_irqsave(&xmm_lock, flags);
-    wakeup_pending = false;
+	spin_lock_irqsave(&xmm_lock, flags);
+	wakeup_pending = false;
 	system_suspending = false;
-   	spin_unlock_irqrestore(&xmm_lock, flags);		
+	spin_unlock_irqrestore(&xmm_lock, flags);
 
 	pr_debug("%s }\n", __func__);
 	return 0;
@@ -383,7 +392,7 @@ static ssize_t baseband_xmm_onoff(struct device *dev,
 	}
 	power_onoff = pwr;
 	pr_debug("%s power_onoff=%d\n", __func__, power_onoff);
-	
+
 
 	if (power_onoff == 0)
 		baseband_xmm_power_off(device);
@@ -396,15 +405,15 @@ static ssize_t baseband_xmm_onoff(struct device *dev,
 
 //To_Ril-recovery Nvidia_Patch_20111226 [Start]
 static ssize_t baseband_xmm_onoff_show(struct device *dev,
-            struct device_attribute *attr,
-            char *buf)
+		struct device_attribute *attr,
+		char *buf)
 {
-    int onoff = power_onoff;
-    pr_debug("%s, enum(%d), onoff(%d)\n", __func__, enum_success, power_onoff );
-    if(enum_success)
-        onoff = 2;
-              
-    return sprintf(buf, "%d", onoff);
+	int onoff = power_onoff;
+	pr_debug("%s, enum(%d), onoff(%d)\n", __func__, enum_success, power_onoff );
+	if(enum_success)
+		onoff = 2;
+
+	return sprintf(buf, "%d", onoff);
 }
 
 static DEVICE_ATTR(xmm_onoff, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP , baseband_xmm_onoff_show, baseband_xmm_onoff);
@@ -416,7 +425,7 @@ void baseband_xmm_power_switch(bool power_on)
 
 	pr_debug("%s {\n", __func__);
 	pr_debug("power_on(%d)\n", power_on);
-		
+
 	/* check if enumeration succeeded */
 
 	if (power_onoff == power_on)
@@ -432,7 +441,7 @@ void baseband_xmm_power_switch(bool power_on)
 				filp->f_op->write(filp, "1", 1, &filp->f_pos);
 			else
 				filp->f_op->write(filp, "0", 1, &filp->f_pos);
-				
+
 			filp_close(filp, NULL);
 		}
 		set_fs(oldfs);
@@ -447,9 +456,9 @@ void baseband_xmm_set_power_status(unsigned int status)
 {
 	struct baseband_power_platform_data *data = baseband_power_driver_data;
 	int value = 0;
-    unsigned long flags;
+	unsigned long flags;
 
-	pr_debug("%s n(%d),o(%d)\n", __func__, status, baseband_xmm_powerstate );
+	pr_debug("%s n(%d),o(%d)\n", __func__, status, baseband_xmm_powerstate);
 
 	if (baseband_xmm_powerstate == status)
 		return;
@@ -457,18 +466,22 @@ void baseband_xmm_set_power_status(unsigned int status)
 	switch (status) {
 	case BBXMM_PS_L0:
 		if (modem_sleep_flag) {
-			pr_debug("%s Resume from L3 without calling resume" "function\n",  __func__);
+			pr_debug("%s Resume from L3 without calling resume" "function\n", __func__);
 				baseband_xmm_power_driver_handle_resume(data);
-		}	
+		}
 		pr_debug("PM_ST : L0\n");
 		baseband_xmm_powerstate = status;
-		if (!wake_lock_active(&wakelock))
+		if (!wake_lock_active(&wakelock)) {
+			PR_TRACE("Acquire baseband_xmm_power wakelock line %d\n");
 			wake_lock(&wakelock);
+		} else {
+			PR_TRACE("Already held baseband_xmm_power wakelock line %d\n");
+		}
 		value = gpio_get_value(data->modem.xmm.ipc_hsic_active);
-		//pr_debug("GPIO [R]: before L0 Host_active = %d \n", value); 
+		//pr_debug("GPIO [R]: before L0 Host_active = %d \n", value);
 		if (!value) {
 			gpio_set_value(data->modem.xmm.ipc_hsic_active, 1);
-			pr_debug("GPIO [W]: L0 Host_active -> 1 \n"); 
+			pr_debug("GPIO [W]: L0 Host_active -> 1 \n");
 		}
 		if (modem_power_on) {
 			modem_power_on = false;
@@ -476,7 +489,7 @@ void baseband_xmm_set_power_status(unsigned int status)
 		}
 		pr_debug("gpio host active high->\n");
 		break;
-		
+
 	case BBXMM_PS_L2:
 		pr_debug("PM_ST : L2\n");
 		baseband_xmm_powerstate = status;
@@ -484,11 +497,15 @@ void baseband_xmm_set_power_status(unsigned int status)
 		if (wakeup_pending) {
 			spin_unlock_irqrestore(&xmm_lock, flags);
 			baseband_xmm_power_L2_resume();
-		 } else {
+		} else {
 			spin_unlock_irqrestore(&xmm_lock, flags);
-			if (wake_lock_active(&wakelock))
+			if (wake_lock_active(&wakelock)) {
+				PR_TRACE("Release baseband_xmm_power wakelock line %d\n");
 				wake_unlock(&wakelock);
-		modem_sleep_flag = true;
+			} else {
+				PR_TRACE("Already released baseband_xmm_power wakelock line %d\n");
+			}
+			modem_sleep_flag = true;
 		}
 		if (short_autosuspend && enable_short_autosuspend && &usbdev->dev) {
 			pr_debug("autosuspend delay %d ms, disable short_autosuspend\n",DEFAULT_AUTOSUSPEND_DELAY);
@@ -496,27 +513,30 @@ void baseband_xmm_set_power_status(unsigned int status)
 			short_autosuspend = false;
 		}
 		break;
-		
+
 	case BBXMM_PS_L3:
 		if (baseband_xmm_powerstate == BBXMM_PS_L2TOL0) {
-				if (!data->modem.xmm.ipc_ap_wake) {
-						spin_lock_irqsave(&xmm_lock, flags);
-						wakeup_pending = true;
-						spin_unlock_irqrestore(&xmm_lock, flags);
-					pr_debug("%s: L2 race condition-CP wakeup" " pending\n", __func__);
-				}
-		}	
+			if (!data->modem.xmm.ipc_ap_wake) {
+				spin_lock_irqsave(&xmm_lock, flags);
+				wakeup_pending = true;
+				spin_unlock_irqrestore(&xmm_lock, flags);
+				pr_debug("%s: L2 race condition-CP wakeup" " pending\n", __func__);
+			}
+		}
 		pr_debug("PM_ST : L3\n");
 		baseband_xmm_powerstate = status;
 		spin_lock_irqsave(&xmm_lock, flags);
 		system_suspending = false;
 		spin_unlock_irqrestore(&xmm_lock, flags);
 		if (wake_lock_active(&wakelock)) {
+			PR_TRACE("Release baseband_xmm_power wakelock line %d\n");
 			pr_debug("%s: releasing wakelock before L3\n", __func__);
 			wake_unlock(&wakelock);
+		} else {
+			PR_TRACE("Already released baseband_xmm_power wakelock line %d\n");
 		}
 		gpio_set_value(data->modem.xmm.ipc_hsic_active, 0);
-		pr_debug("GPIO [W]: Host_active -> 0 \n"); 
+		pr_debug("GPIO [W]: Host_active -> 0 \n");
 		break;
 	case BBXMM_PS_L2TOL0:
 		spin_lock_irqsave(&xmm_lock, flags);
@@ -543,7 +563,7 @@ irqreturn_t baseband_xmm_power_ipc_ap_wake_irq(int irq, void *dev_id)
 {
 	int value;
 	struct baseband_power_platform_data *data = baseband_power_driver_data;
-	
+
 	value = gpio_get_value(baseband_power_driver_data->modem.xmm.ipc_ap_wake);
 	pr_debug("%s g(%d), wake_st(%d)\n", __func__, value, ipc_ap_wake_state);
 
@@ -572,7 +592,7 @@ irqreturn_t baseband_xmm_power_ipc_ap_wake_irq(int irq, void *dev_id)
 	} else {
 		if (!value) {
 			pr_debug("%s - falling\n", __func__);
-			/* First check it a CP ack or CP wake  */
+			/* First check it a CP ack or CP wake */
 			value = gpio_get_value(data->modem.xmm.ipc_bb_wake);
 			if (value) {
 				pr_debug("cp ack for bb_wake\n");
@@ -602,21 +622,21 @@ irqreturn_t baseband_xmm_power_ipc_ap_wake_irq(int irq, void *dev_id)
 		} else {
 			pr_debug("%s - rising\n", __func__);
 			value = gpio_get_value(data->modem.xmm.ipc_hsic_active);
-			//pr_debug("GPIO [R]: Host_active = %d \n",value); 
+			//pr_debug("GPIO [R]: Host_active = %d \n",value);
 			if (!value) {
 				pr_debug("host active low: ignore request\n");
 				ipc_ap_wake_state = IPC_AP_WAKE_H;
 				return IRQ_HANDLED;
 			}
 			value = gpio_get_value(data->modem.xmm.ipc_bb_wake);
-			//pr_debug("GPIO [R]: Slave_wakeup = %d \n", value); 
+			//pr_debug("GPIO [R]: Slave_wakeup = %d \n", value);
 			if (value) {
 				/* Clear the slave wakeup request */
 				gpio_set_value(data->modem.xmm.ipc_bb_wake, 0);
-				pr_debug("GPIO [W]: Slave_wake -> 0 \n"); 
+				pr_debug("GPIO [W]: Slave_wake -> 0 \n");
 			}
 			if (reenable_autosuspend && usbdev) {
-			      reenable_autosuspend = false;
+				reenable_autosuspend = false;
 				struct usb_interface *intf;
 				intf = usb_ifnum_to_if(usbdev, 0);
 				if (usb_autopm_get_interface_async(intf) >= 0) {
@@ -624,17 +644,17 @@ irqreturn_t baseband_xmm_power_ipc_ap_wake_irq(int irq, void *dev_id)
 					usb_autopm_put_interface_async(intf);
 				} else {
 					pr_debug("get_interface_async failed" " - do not call put_interface\n");
-				}			      
+				}
 			}
 			modem_sleep_flag = false;
 			baseband_xmm_set_power_status(BBXMM_PS_L0);
 			if (short_autosuspend && enable_short_autosuspend &&
 						baseband_xmm_powerstate == BBXMM_PS_L0 &&
-						&usbdev->dev) 
+						&usbdev->dev)
 			{
 				pr_debug("set autosuspend delay %d ms\n",SHORT_AUTOSUSPEND_DELAY);
-				queue_work(workqueue_susp, &work_shortsusp);				
-			} 
+				queue_work(workqueue_susp, &work_shortsusp);
+			}
 			/* save gpio state */
 			ipc_ap_wake_state = IPC_AP_WAKE_H;
 		}
@@ -650,21 +670,21 @@ static void baseband_xmm_power_init1_work(struct work_struct *work)
 
 	pr_debug("%s {\n", __func__);
 
-	if (modem_flash && modem_ver >= XMM_MODEM_VER_1145) {		
+	if (modem_flash && modem_ver >= XMM_MODEM_VER_1145) {
 		if (register_hsic_device && baseband_power_driver_data->hsic_register) {
 			pr_debug("%s: register usb host controller\n", __func__);
 			baseband_power_driver_data->modem.xmm.hsic_device = baseband_power_driver_data->hsic_register();
 			register_hsic_device = false;
 
-			baseband_xmm_power_work->state =  BBXMM_WORK_INIT_FLASH_PM_VER_GE_1145_RECOVERY;
-			queue_work(workqueue, (struct work_struct *) baseband_xmm_power_work);						
+			baseband_xmm_power_work->state = BBXMM_WORK_INIT_FLASH_PM_VER_GE_1145_RECOVERY;
+			queue_work(workqueue, (struct work_struct *) baseband_xmm_power_work);
 		} else {
 			pr_err("%s: Error? hsic_register is missing \n", __func__);
 		}
 	} else {
 		/* check if IPC_HSIC_ACTIVE high */
 		value = gpio_get_value(baseband_power_driver_data->modem.xmm.ipc_hsic_active);
-		//pr_debug("GPIO [R]: Host_active = %d \n",value); 
+		//pr_debug("GPIO [R]: Host_active = %d \n",value);
 		if (value != 1) {
 			pr_err("%s - expected IPC_HSIC_ACTIVE high!\n", __func__);
 			return;
@@ -675,17 +695,17 @@ static void baseband_xmm_power_init1_work(struct work_struct *work)
 
 		/* set IPC_HSIC_ACTIVE low */
 		gpio_set_value(baseband_power_driver_data->modem.xmm.ipc_hsic_active, 0);
-		pr_debug("GPIO [W]: Host_active -> 0 \n"); 
+		pr_debug("GPIO [W]: Host_active -> 0 \n");
 		/* wait 10 ms */
 		mdelay(10);
 
 		/* set IPC_HSIC_ACTIVE high */
 		gpio_set_value(baseband_power_driver_data->modem.xmm.ipc_hsic_active, 1);
-		pr_debug("GPIO [W]: Host_active -> 1 \n"); 
+		pr_debug("GPIO [W]: Host_active -> 1 \n");
 		/* wait 20 ms */
 		mdelay(20);
 	}
-      
+
 	pr_debug("%s }\n", __func__);
 }
 
@@ -707,10 +727,10 @@ static void baseband_xmm_power_init2_work(struct work_struct *work)
 	/* register usb host controller only once */
 	if (register_hsic_device) {
 		if (data->hsic_register) {
-			data->modem.xmm.hsic_device = data->hsic_register();			
+			data->modem.xmm.hsic_device = data->hsic_register();
 		}
 		else
-			pr_err("%s: hsic_register is missing\n", __func__);		
+			pr_err("%s: hsic_register is missing\n", __func__);
 		register_hsic_device = false;
 	}
 }
@@ -730,44 +750,46 @@ static void baseband_xmm_power_L2_resume(void)
 		return;
 
 	/* claim the wakelock here to avoid any system suspend */
-	if (!wake_lock_active(&wakelock))
+	if (!wake_lock_active(&wakelock)) {
+		PR_TRACE("Acquire baseband_xmm_power wakelock line %d\n");
 		wake_lock(&wakelock);
+	} else {
+		PR_TRACE("Already held baseband_xmm_power wakelock line %d\n");
+	}
 	modem_sleep_flag = false;
 	spin_lock_irqsave(&xmm_lock, flags);
 	wakeup_pending = false;
 	spin_unlock_irqrestore(&xmm_lock, flags);
 
-	if (CP_initiated_L2toL0)  {		
+	if (CP_initiated_L2toL0) {
 		pr_debug("PM_ST : CP L2->L0\n");
-	    spin_lock_irqsave(&xmm_lock, flags);
+		spin_lock_irqsave(&xmm_lock, flags);
 		CP_initiated_L2toL0 = false;
-	    spin_unlock_irqrestore(&xmm_lock, flags);
+		spin_unlock_irqrestore(&xmm_lock, flags);
 		queue_work(workqueue, &L2_resume_work);
 	} else {
 		/* set the slave wakeup request */
 		pr_debug("PM_ST : AP L2->L0\n");
 		value = gpio_get_value(data->modem.xmm.ipc_ap_wake);
-		//pr_debug("GPIO [R]: Host_wakeup = %d \n",value); 
+		//pr_debug("GPIO [R]: Host_wakeup = %d \n",value);
 		if (value) {
 			gpio_set_value(data->modem.xmm.ipc_bb_wake, 1);
-			pr_debug("GPIO [W]: Slave_wake -> 1 \n"); 
+			pr_debug("GPIO [W]: Slave_wake -> 1 \n");
 			pr_debug("waiting for host wakeup from CP...\n");
 			do {
 				mdelay(1);
 				value = gpio_get_value(data->modem.xmm.ipc_ap_wake);
 				delay--;
-			} while ((value) && (delay));
+			} while (value && delay);
 			if (delay)
 			{
-				//pr_debug("GPIO [R]: Host_wakeup = %d \n",value); 
-			}
-			else
-			{
+				//pr_debug("GPIO [R]: Host_wakeup = %d \n",value);
+			} else {
 				pr_debug("PM_ST :!!AP L2->L0 Failed and CP is not response !!\n");
 			}
 		} else {
-			pr_debug("CP already ready\n");		
-        }
+			pr_debug("CP already ready\n");
+		}
 	}
 }
 
@@ -793,7 +815,7 @@ static void baseband_xmm_power_L2_resume_work(struct work_struct *work)
 	{
 		pr_debug("usb_ifnum_to_if's return vaule is NULL !! \n");
 	}
-	
+
 	if (usb_autopm_get_interface(intf) == 0)
 		usb_autopm_put_interface(intf);
 	usb_unlock_device(usbdev);
@@ -805,24 +827,24 @@ static void baseband_xmm_power_L2_resume_work(struct work_struct *work)
 
 static void baseband_xmm_power_shortsusp(struct work_struct *work)
 {
-    pr_debug("%s {\n", __func__);
-    if (!usbdev || !&usbdev->dev) {
-        pr_err("%s usbdev is invalid\n", __func__);
-        return;
-    }
-    pm_runtime_set_autosuspend_delay(&usbdev->dev, SHORT_AUTOSUSPEND_DELAY);
-    pr_debug("} %s\n", __func__);
+	pr_debug("%s {\n", __func__);
+	if (!usbdev || !&usbdev->dev) {
+		pr_err("%s usbdev is invalid\n", __func__);
+		return;
+	}
+	pm_runtime_set_autosuspend_delay(&usbdev->dev, SHORT_AUTOSUSPEND_DELAY);
+	pr_debug("} %s\n", __func__);
 }
 
 static void baseband_xmm_power_defaultsusp(struct work_struct *work)
 {
-    pr_debug("%s {\n", __func__);
-    if (!usbdev || !&usbdev->dev) {
-        pr_err("%s usbdev is invalid\n", __func__);
-        return;
-    }
-    pm_runtime_set_autosuspend_delay(&usbdev->dev, DEFAULT_AUTOSUSPEND_DELAY);
-    pr_debug("} %s\n", __func__);
+	pr_debug("%s {\n", __func__);
+	if (!usbdev || !&usbdev->dev) {
+		pr_err("%s usbdev is invalid\n", __func__);
+		return;
+	}
+	pm_runtime_set_autosuspend_delay(&usbdev->dev, DEFAULT_AUTOSUSPEND_DELAY);
+	pr_debug("} %s\n", __func__);
 }
 
 static void baseband_xmm_power_reset_on(void)
@@ -842,9 +864,9 @@ static void baseband_xmm_power_reset_on(void)
 	mdelay(50);
 	gpio_set_value(baseband_power_driver_data->modem.xmm.bb_rst, 0);
 	mdelay(200);
-	gpio_set_value(baseband_power_driver_data->modem.xmm.bb_rst, 1);	
+	gpio_set_value(baseband_power_driver_data->modem.xmm.bb_rst, 1);
 	mdelay(50);
-	
+
 	gpio_set_value(baseband_power_driver_data->modem.xmm.bb_on, 1);
 	udelay(60);
 	gpio_set_value(baseband_power_driver_data->modem.xmm.bb_on, 0);
@@ -859,7 +881,7 @@ static void baseband_xmm_power_flash_pm_ver_ge_1145_recovery
 	int timeout_500ms = MODEM_ENUM_TIMEOUT_500MS;
 	int timeout_200ms = 0;
 	long err;
-	
+
 	pr_debug("%s {\n", __func__);
 
 
@@ -870,16 +892,15 @@ static void baseband_xmm_power_flash_pm_ver_ge_1145_recovery
 	/* waiting ap_wake up */
 	while (ipc_ap_wake_state == IPC_AP_WAKE_INIT1 && timeout_500ms--)
 		msleep(500);
-	
+
 	if (ipc_ap_wake_state != IPC_AP_WAKE_INIT2) {
 		pr_err("err : modem boot repeat condition state(%d)\n",ipc_ap_wake_state);
 		timeout_200ms = MODEM_ENUM_TIMEOUT_200MS;
 	}
-	
+
 	/* check if enumeration succeeded */
 	/* waiting ttyacm dev to be created */
-	do
-	{
+	do {
 		mm_segment_t oldfs;
 		struct file *filp;
 		oldfs = get_fs();
@@ -897,10 +918,10 @@ static void baseband_xmm_power_flash_pm_ver_ge_1145_recovery
 			break;
 		}
 		set_fs(oldfs);
-	}while (++timeout_200ms <= MODEM_ENUM_TIMEOUT_200MS);
+	} while (++timeout_200ms <= MODEM_ENUM_TIMEOUT_200MS);
 
 	if (timeout_200ms > MODEM_ENUM_TIMEOUT_200MS)
-		pr_err("/dev/ttyACM0 %ld\n", err); 
+		pr_err("/dev/ttyACM0 %ld\n", err);
 
 	/*
 	TODO:power on/off routine
@@ -919,16 +940,16 @@ static void baseband_xmm_power_flash_pm_ver_ge_1145_recovery
 		else
 			pr_err("%s: hsic is already unregistered\n", __func__);
 		register_hsic_device = true;
-	
+
 		/* wait X ms */
 		msleep(500);
 
 		/* set IPC_HSIC_ACTIVE low */
 		gpio_set_value(baseband_power_driver_data->modem.xmm.ipc_hsic_active,0);
 		//pr_debug("ipc_hsic_active -> 0 \n");
-		pr_debug("GPIO [W]: Host_active -> 0 \n"); 
+		pr_debug("GPIO [W]: Host_active -> 0 \n");
 	}
-	
+
 	pr_debug("%s enum(%d), interval(%d, %d)ms }\n", __func__, enum_success,
 		(MODEM_ENUM_TIMEOUT_500MS - timeout_500ms)*500,
 		timeout_200ms*200);
@@ -974,28 +995,28 @@ static void baseband_xmm_power_work_func(struct work_struct *work)
 			gpio_set_value(baseband_power_driver_data->
 				modem.xmm.ipc_hsic_active, 1);
 			//pr_debug("ipc_hsic_active -> 1 \n");
-			pr_debug("GPIO [W]: Host_active -> 1 \n"); 
-			
+			pr_debug("GPIO [W]: Host_active -> 1 \n");
+
 			/* reset / power on sequence */
 			baseband_xmm_power_reset_on();
 			/* set power status as on */
 			power_onoff = 1;
 			//pr_debug("%s: ver > 1145:" " ipc_hsic_active -> 0\n", __func__);
 			gpio_set_value(baseband_power_driver_data->
-				modem.xmm.ipc_hsic_active, 0);			
-			pr_debug("%s: ver > 1145:" "GPIO [W]: Host_active -> 0 \n",__func__); 
+				modem.xmm.ipc_hsic_active, 0);
+			pr_debug("%s: ver > 1145:" "GPIO [W]: Host_active -> 0 \n",__func__);
 		} else {
 			/* [modem ver >= 1130] start with IPC_HSIC_ACTIVE low */
 			if (modem_ver >= XMM_MODEM_VER_1130) {
 				//pr_debug("%s: ver > 1130:" " ipc_hsic_active -> 0\n", __func__);
 				gpio_set_value(baseband_power_driver_data->modem.xmm.ipc_hsic_active, 0);
-				pr_debug("%s: ver > 1130:" "GPIO [W]: Host_active -> 0 \n",__func__); 				
+				pr_debug("%s: ver > 1130:" "GPIO [W]: Host_active -> 0 \n",__func__);
 			}
 			/* reset / power on sequence */
 			baseband_xmm_power_reset_on();
 			/* set power status as on */
 			power_onoff = 1;
-			
+
 			/* optional delay
 			 * 0 = flashless
 			 *   ==> causes next step to enumerate modem boot rom
@@ -1013,11 +1034,11 @@ static void baseband_xmm_power_work_func(struct work_struct *work)
 			if (baseband_power_driver_data->hsic_register && register_hsic_device == true) {
 				baseband_power_driver_data->modem.xmm.hsic_device =
 					baseband_power_driver_data->hsic_register();
-					
+
 				register_hsic_device = false;
-			}
-			else
+			} else {
 				pr_err("%s: hsic_register is missing\n", __func__);
+			}
 		}
 
 		/* go to next state */
@@ -1107,7 +1128,7 @@ static struct notifier_block usb_xmm_nb = {
 };
 
 static int baseband_xmm_power_pm_notifier_event(struct notifier_block *this,
-					unsigned long event, void *ptr)
+		unsigned long event, void *ptr)
 {
 	struct baseband_power_platform_data *data = baseband_power_driver_data;
 	unsigned long flags;
@@ -1120,6 +1141,7 @@ static int baseband_xmm_power_pm_notifier_event(struct notifier_block *this,
 	case PM_SUSPEND_PREPARE:
 		pr_debug("%s : PM_SUSPEND_PREPARE\n", __func__);
 		if (wake_lock_active(&wakelock)) {
+			PR_TRACE("Not suspending because baseband_xmm_power wakelock active line %d\n");
 			pr_debug("%s: wakelock was active, aborting suspend\n",__func__);
 			return NOTIFY_STOP;
 		}
@@ -1163,9 +1185,9 @@ static int baseband_xmm_shutdown_function()
 	} else {
 		pr_err("%s:Called reboot_notify during resuming\n", __func__);
 	}
-	
+
 	gpio_set_value(baseband_power_driver_data->modem.xmm.bb_on, 0);
-	udelay(200);	
+	udelay(200);
 	gpio_set_value(baseband_power_driver_data->modem.xmm.bb_rst, 0);
 	mdelay(20);
 }
@@ -1176,20 +1198,20 @@ static struct notifier_block baseband_xmm_power_pm_notifier = {
 };
 
 static int baseband_xmm_reboot_notify(struct notifier_block *nb,
-                                unsigned long event, void *data)
+		unsigned long event, void *data)
 {
 	pr_debug("%s\n", __func__);
 
-    switch (event) {
-    case SYS_RESTART:
-    case SYS_HALT:
-    case SYS_POWER_OFF:
+	switch (event) {
+	case SYS_RESTART:
+	case SYS_HALT:
+	case SYS_POWER_OFF:
 		{
 			baseband_xmm_shutdown_function();
 		}
-	    return NOTIFY_OK;
-    }
-    return NOTIFY_DONE;
+		return NOTIFY_OK;
+	}
+	return NOTIFY_DONE;
 }
 
 
@@ -1202,7 +1224,7 @@ static int baseband_xmm_power_driver_probe(struct platform_device *device)
 	struct baseband_power_platform_data *data
 		= (struct baseband_power_platform_data *)device->dev.platform_data;
 	struct device *dev = &device->dev;
-	unsigned long flags;	
+	unsigned long flags;
 	int err;
 
 	pr_debug("%s\n", __func__);
@@ -1251,23 +1273,23 @@ static int baseband_xmm_power_driver_probe(struct platform_device *device)
 		pr_debug("%s: request_irq IPC_AP_WAKE_IRQ\n", __func__);
 		ipc_ap_wake_state = IPC_AP_WAKE_UNINIT;
 
-		err = request_threaded_irq(gpio_to_irq(data->modem.xmm.ipc_ap_wake), 
+		err = request_threaded_irq(gpio_to_irq(data->modem.xmm.ipc_ap_wake),
 					NULL,
-					baseband_xmm_power_ipc_ap_wake_irq, 
-					IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, 
-					"IPC_AP_WAKE_IRQ", 
+					baseband_xmm_power_ipc_ap_wake_irq,
+					IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+					"IPC_AP_WAKE_IRQ",
 					NULL);
 		if (err < 0) {
 			pr_err("%s - request irq IPC_AP_WAKE_IRQ failed\n",__func__);
 			return err;
 		}
-		
-		disable_irq(gpio_to_irq(data->modem.xmm.ipc_ap_wake));		
+
+		disable_irq(gpio_to_irq(data->modem.xmm.ipc_ap_wake));
 
 		err = enable_irq_wake(gpio_to_irq(data->modem.xmm.ipc_ap_wake));
-	    if (err < 0)
-	           pr_err("%s: enable_irq_wake error\n", __func__);
-	
+		if (err < 0)
+			pr_err("%s: enable_irq_wake error\n", __func__);
+
 		ipc_ap_wake_state = IPC_AP_WAKE_IRQ_READY;
 		if (modem_ver >= XMM_MODEM_VER_1145) {
 			pr_debug("%s: ver > 1145: AP_WAKE_READY\n", __func__);
@@ -1291,14 +1313,14 @@ static int baseband_xmm_power_driver_probe(struct platform_device *device)
 		return -1;
 	}
 
-	workqueue_susp = alloc_workqueue("baseband_xmm_power_autosusp", 
+	workqueue_susp = alloc_workqueue("baseband_xmm_power_autosusp",
 				WQ_UNBOUND | WQ_HIGHPRI | WQ_NON_REENTRANT, 1);
 
 	if (!workqueue_susp) {
 		pr_err("cannot create workqueue_susp\n");
 		return -1;
 	}
-	
+
 	baseband_xmm_power_work = (struct baseband_xmm_power_work_t *)
 		kmalloc(sizeof(struct baseband_xmm_power_work_t), GFP_KERNEL);
 
@@ -1306,7 +1328,7 @@ static int baseband_xmm_power_driver_probe(struct platform_device *device)
 		pr_err("cannot allocate baseband_xmm_power_work\n");
 		return -1;
 	}
-	
+
 	INIT_WORK((struct work_struct *) baseband_xmm_power_work, baseband_xmm_power_work_func);
 	baseband_xmm_power_work->state = BBXMM_WORK_INIT;
 	queue_work(workqueue,(struct work_struct *) baseband_xmm_power_work);
@@ -1315,10 +1337,10 @@ static int baseband_xmm_power_driver_probe(struct platform_device *device)
 	INIT_WORK(&init1_work, baseband_xmm_power_init1_work);
 	INIT_WORK(&init2_work, baseband_xmm_power_init2_work);
 	INIT_WORK(&L2_resume_work, baseband_xmm_power_L2_resume_work);
-	
+
 	INIT_WORK(&work_shortsusp, baseband_xmm_power_shortsusp);
 	INIT_WORK(&work_defaultsusp, baseband_xmm_power_defaultsusp);
-	
+
 
 	/* init state variables */
 	register_hsic_device = true;
@@ -1396,19 +1418,19 @@ static int baseband_xmm_power_driver_shutdown(struct platform_device *device)
 }
 
 static int baseband_xmm_power_driver_handle_resume(
-            			struct baseband_power_platform_data *data)
+		struct baseband_power_platform_data *data)
 {
 
 	int value;
 	int delay = 1000; /* maxmum delay in msec */ //1000 is Intel recovmmand value
-    unsigned long flags;
+	unsigned long flags;
 
 	value = gpio_get_value(data->modem.xmm.ipc_ap_wake);
 	//pr_debug("%s host_wake(%d)\n", __func__, value);
-	pr_debug("%s GPIO [R]: Host_wakeup = %d \n",__func__,value); 
+	pr_debug("%s GPIO [R]: Host_wakeup = %d \n",__func__,value);
 
-    if (!data)
-                return 0;
+	if (!data)
+		return 0;
 
 	/* check if modem is on */
 	if (power_onoff == 0) {
@@ -1416,7 +1438,7 @@ static int baseband_xmm_power_driver_handle_resume(
 		return 0;
 	}
 
-	modem_sleep_flag = false;	
+	modem_sleep_flag = false;
 	spin_lock_irqsave(&xmm_lock, flags);
 	wakeup_pending = false;
 	spin_unlock_irqrestore(&xmm_lock, flags);
@@ -1428,7 +1450,7 @@ static int baseband_xmm_power_driver_handle_resume(
 		pr_debug("PM_ST : AP L3 -> L0\n");
 		/* wake bb */
 		gpio_set_value(data->modem.xmm.ipc_bb_wake, 1);
-		pr_debug("GPIO [W]: Slave_wakeup -> 1 \n"); 
+		pr_debug("GPIO [W]: Slave_wakeup -> 1 \n");
 		pr_debug("waiting for host wakeup...\n");
 		do {
 			mdelay(1);
@@ -1436,7 +1458,7 @@ static int baseband_xmm_power_driver_handle_resume(
 			delay--;
 		} while ((value) && (delay));
 		if (delay) {
-			//pr_debug("GPIO [R]: Host_wakeup = %d \n",value); 
+			//pr_debug("GPIO [R]: Host_wakeup = %d \n",value);
 			pr_debug("%s enable short_autosuspend\n", __func__);
 			short_autosuspend = true;
 		}
@@ -1446,7 +1468,7 @@ static int baseband_xmm_power_driver_handle_resume(
 		pr_debug("PM_ST : CP L3 -> L0\n");
 	}
 	reenable_autosuspend = true; //20120112 - Nv Bug 924425 - L2 Auto Suspend#1
-    
+
 	return 0;
 }
 
@@ -1459,32 +1481,33 @@ static int baseband_xmm_power_driver_suspend(struct device *dev)
 
 static int baseband_xmm_power_driver_resume(struct device *dev)
 {
-     struct platform_device *pdev = to_platform_device(dev);
-     struct baseband_power_platform_data *data
-                = (struct baseband_power_platform_data *)pdev->dev.platform_data;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct baseband_power_platform_data *data
+			= (struct baseband_power_platform_data*)
+			pdev->dev.platform_data;
 
-     pr_debug("%s\n", __func__);
-     baseband_xmm_power_driver_handle_resume(data);
+	pr_debug("%s\n", __func__);
+	baseband_xmm_power_driver_handle_resume(data);
 
-     return 0;
+	return 0;
 }
 
 static int baseband_xmm_power_suspend_noirq(struct device *dev)
 {
-    unsigned long flags;
+	unsigned long flags;
 
-    pr_debug("%s !!\n", __func__);
-    spin_lock_irqsave(&xmm_lock, flags);
+	pr_debug("%s !!\n", __func__);
+	spin_lock_irqsave(&xmm_lock, flags);
 	system_suspending = false;
-    if (wakeup_pending) {
+	if (wakeup_pending) {
 		wakeup_pending = false;
-		spin_unlock_irqrestore(&xmm_lock, flags);	//                                                                  
+		spin_unlock_irqrestore(&xmm_lock, flags);	//
 		pr_info("%s:**Abort Suspend: reason CP WAKEUP**\n", __func__);
 		pr_info("%s:**spin unlock **\n", __func__);
 		return -EBUSY;
-    }
-    spin_unlock_irqrestore(&xmm_lock, flags);
-    return 0;
+	}
+	spin_unlock_irqrestore(&xmm_lock, flags);
+	return 0;
 }
 
 static int baseband_xmm_power_resume_noirq(struct device *dev)
@@ -1492,8 +1515,8 @@ static int baseband_xmm_power_resume_noirq(struct device *dev)
 	int value;
 	value = gpio_get_value(baseband_power_driver_data->modem.xmm.ipc_ap_wake);
 	//pr_debug("%s host_wake(%d)\n", __func__, value);
-	pr_debug("%s GPIO [R]: Host_wakeup = %d \n",__func__,value); 
-    return 0;
+	pr_debug("%s GPIO [R]: Host_wakeup = %d \n",__func__,value);
+	return 0;
 }
 
 static const struct dev_pm_ops baseband_xmm_power_dev_pm_ops = {
@@ -1501,7 +1524,7 @@ static const struct dev_pm_ops baseband_xmm_power_dev_pm_ops = {
 	.resume_noirq = baseband_xmm_power_resume_noirq,
 	.suspend = baseband_xmm_power_driver_suspend,
 	.resume = baseband_xmm_power_driver_resume,
-};	
+};
 #endif
 
 static struct platform_driver baseband_power_driver = {
@@ -1509,10 +1532,10 @@ static struct platform_driver baseband_power_driver = {
 	.remove = baseband_xmm_power_driver_remove,
 	.shutdown = baseband_xmm_power_driver_shutdown,
 	.driver = {
-		       .name = "baseband_xmm_power",
+		.name	= "baseband_xmm_power",
 #ifdef CONFIG_PM
-	           .pm   = &baseband_xmm_power_dev_pm_ops,
-#endif		
+		.pm	= &baseband_xmm_power_dev_pm_ops,
+#endif
 	},
 };
 
diff --git a/drivers/media/video/tegra/lm3559.c b/drivers/media/video/tegra/lm3559.c
index be6e9fa..e47e135 100644
--- a/drivers/media/video/tegra/lm3559.c
+++ b/drivers/media/video/tegra/lm3559.c
@@ -14,11 +14,9 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 
+ * Foundation, Inc.,
  */
 
-
-
 #include <linux/fs.h>
 #include <linux/i2c.h>
 #include <linux/miscdevice.h>
@@ -30,37 +28,32 @@
 #include <linux/gpio.h>
 #include <media/lm3559.h>
 
-#define LM3559_I2C_NAME  				"lm3559"
-
-#if 1 //                 
-#define LGE_X3_LM3559_FLASH_TORCH_CURRENT_FIXED 1
-#endif
+#define LM3559_I2C_NAME			"lm3559"
 
 /* Register Descriptions */
-#define LM3559_REG_ENABLE				      0x10
-#define LM3559_REG_GPIO					      0x20
-#define LM3559_REG_VLED_MONITOR			  0x30
-#define LM3559_REG_ADC_DELAY			    0x31
-#define LM3559_REG_VIN_MONITOR			  0x80
-#define LM3559_REG_LAST_FLASH			    0x81
-#define LM3559_REG_TORCH_BRIGHTNESS	  0xA0
-#define LM3559_REG_FLASH_BRIGHTNESS	  0xB0
-#define LM3559_REG_FLASH_DURATION		  0xC0
-#define LM3559_REG_FLAGS				      0xD0
-#define LM3559_REG_CONFIGURATION1		  0xE0
-#define LM3559_REG_CONFIGURATION2		  0xF0
-#define LM3559_REG_PRIVACY				    0x11
+#define LM3559_REG_ENABLE		0x10
+#define LM3559_REG_GPIO			0x20
+#define LM3559_REG_VLED_MONITOR		0x30
+#define LM3559_REG_ADC_DELAY		0x31
+#define LM3559_REG_VIN_MONITOR		0x80
+#define LM3559_REG_LAST_FLASH		0x81
+#define LM3559_REG_TORCH_BRIGHTNESS	0xA0
+#define LM3559_REG_FLASH_BRIGHTNESS	0xB0
+#define LM3559_REG_FLASH_DURATION	0xC0
+#define LM3559_REG_FLAGS		0xD0
+#define LM3559_REG_CONFIGURATION1	0xE0
+#define LM3559_REG_CONFIGURATION2	0xF0
+#define LM3559_REG_PRIVACY		0x11
 #define LM3559_REG_MESSAGE_INDICATOR	0x12
 #define LM3559_REG_INDICATOR_BLINKING	0x13
-#define LM3559_REG_PRIVACY_PWM			  0x14
+#define LM3559_REG_PRIVACY_PWM		0x14
 
-
-enum{
-   LM3559_LED_OFF,
-   LM3559_LED_LOW,
-   LM3559_LED_HIGH,
-   LM3559_LED_MAX
-}; 
+enum {
+	LM3559_LED_OFF,
+	LM3559_LED_LOW,
+	LM3559_LED_HIGH,
+	LM3559_LED_MAX
+};
 
 struct lm3559_info {
 	struct i2c_client *i2c_client;
@@ -71,10 +64,9 @@ struct lm3559_info {
 static struct lm3559_info *info;
 static int lm3559_onoff_state = LM3559_POWER_OFF;
 
-#ifndef LGE_X3_LM3559_FLASH_TORCH_CURRENT_FIXED
-static unsigned char lm3559_flash_lvl[16] = {  
-		
-      0x00, //0000 0000 
+// TODO: Use finer grading
+static unsigned char lm3559_flash_lvl[16] = {
+      0x00, //0000 0000
       0x11, //0001 0001
       0x22, //0010 0010
       0x33, //0011 0011
@@ -86,60 +78,80 @@ static unsigned char lm3559_flash_lvl[16] = {
       0x99, //1001 1001
       0xaa, //1010 1010
       0xbb, //1011 1011
-      0xcc, //1100 1100 
+      0xcc, //1100 1100
       0xdd, //1101 1101
       0xee, //1110 1110
-      0xff, //1111 1111     
+      0xff, //1111 1111
 };
 
-static unsigned char lm3559_torch_lvl[8] = {  
-		
-      0x00, //000 000 
-      0x09, //001 001
-      0x12, //010 010 
-      0x1b, //011 011
-      0x24, //100 100 -> fixed value
-      0x2d, //101 101
-      0x36, //110 110 
-      0x3f, //111 111
+// [5:0] Register value [5:0]
+// [6] 1 => LED2 on, 0 => LED2 off
+// [7] 1 => Torch, 0 => Privacy
+static u8 lm3559_torch_table[] = {
+	0,	// Off
+	228,	// CM default
+	255,	// CM high
+	24, 24, 24, 24, 24, 24, 24, // Filler
+	24,	// 10
+	120,	// 11
+	26,	// 12
+	121,	// 13
+	28,	// 14
+	122,	// 15
+	30,	// 16
+	123,	// 17
+	124,	// 18
+	125,	// 19
+	126,	// 20
+	127,	// 21
+	192,	// 22
+	200,	// 23
+	201,	// 24
+	209,	// 25
+	210,	// 26
+	218,	// 27
+	219,	// 28
+	227,	// 29
+	228,	// 30 CM default
+	236,	// 31
+	237,	// 32
+	245,	// 33
+	246,	// 34
+	254,	// 35
+	255,	// CM high
 };
-#endif
 
 int lm3559_write_reg(struct i2c_client *client, unsigned char addr, unsigned char data)
 {
-	int err = 0;  
+	int err = 0;
 	int retry = 0;
 
-	unsigned char buf[2] ={0,};
-	
+	u8 buf[2] = {0};
+
 	struct i2c_msg msg[] = {
 		{
-			.addr  = client->addr, 
-			.flags = 0, 
-			.len   = 2, 
-			.buf   = buf, 
+			.addr	= client->addr,
+			.flags	= 0,
+			.len	= 2,
+			.buf	= buf,
 		},
 	};
 
 	buf[0] = addr;
 	buf[1] = data;
 
-#if 0	//                 
-	if ((err = i2c_transfer(client->adapter, &msg[0], 1)) < 0) {
-		dev_err(&client->dev, "i2c write error [%d]\n",err);
-	}
-#else
-  do {
+	do {
 		err = i2c_transfer(client->adapter, &msg[0], 1);
-		if (err == 1)
+		if (err == 1) {
 			return 0;
+		}
 		retry++;
-		pr_err("lm3559: i2c transfer failed, retrying %x %x\n",addr, data);
+		pr_err("lm3559: i2c transfer failed, retrying %x %x\n",
+				addr, data);
 		msleep(1);
-	} while (retry <= 3);
-#endif	
-	return err;
+	} while (retry < 3);
 
+	return err;
 }
 
 int lm3559_read_reg(struct i2c_client *client, unsigned char addr, unsigned char *data)
@@ -169,40 +181,28 @@ int lm3559_read_reg(struct i2c_client *client, unsigned char addr, unsigned char
 }
 
 void lm3559_led_shutdown(struct lm3559_info *info)
-{	
+{
 	lm3559_write_reg(info->i2c_client,LM3559_REG_ENABLE,0x18);
 }
 
-/*	Torch Current
-	 000 : 28.125 mA		100 : 140.625 mA	 
-	 001 : 56.25 mA 		101 : 168.75 mA
-	 010 : 84.375 mA 		110 : 196.875 mA
-	 011 : 112.5mA  		111 : 225 mA
-*/
-void lm3559_enable_torch_mode(struct lm3559_info *info, int state, struct lm3559_param param)
+// Don't use.
+static void lm3559_enable_torch_mode(
+		struct lm3559_info *info, int state, struct lm3559_param param)
 {
-#ifndef LGE_X3_LM3559_FLASH_TORCH_CURRENT_FIXED  
   unsigned char level_value;
-#endif
 
-	//pr_info("%s: state=%d, arg=%d\n",__func__, state, param.value);
-
-#ifdef LGE_X3_LM3559_FLASH_TORCH_CURRENT_FIXED			
-  pr_info("%s:[LGE fixed]  Level: 140.625 (Total 281.25) mA \n",__func__);
-
-  // 0x24 : 100 100 -> 140.625
-  lm3559_write_reg(info->i2c_client,LM3559_REG_TORCH_BRIGHTNESS,0x24);  
-  udelay(10);
-#else
   level_value = (unsigned char)param.value-1;
-  lm3559_write_reg(info->i2c_client,LM3559_REG_TORCH_BRIGHTNESS,lm3559_torch_lvl[level_value]);  
+  if (level_value < 0) {
+    level_value = 0;
+  }
+  if (level_value > 63) {
+    level_value = 63;
+  }
+  lm3559_write_reg(info->i2c_client, LM3559_REG_TORCH_BRIGHTNESS, level_value);
   pr_info("%s: Level: %d \n",__func__, level_value);
-#endif
 
-	lm3559_write_reg(info->i2c_client,LM3559_REG_ENABLE,0x1A);
+lm3559_write_reg(info->i2c_client,LM3559_REG_ENABLE,0x1A);
   udelay(10);
-
-
 }
 
 /*	 Flash Current
@@ -252,23 +252,22 @@ void lm3559_enable_flash_mode(struct lm3559_info *info, int state, struct lm3559
 
 }
 
-void lm3559_power_onoff(struct lm3559_info *info, int onoff){
-
-	if(onoff == LM3559_POWER_OFF){
-		gpio_set_value(info->pdata->gpio_act, 0);		
-    udelay(10);
+static void lm3559_power_onoff(struct lm3559_info *info, int onoff)
+{
+	if (onoff == LM3559_POWER_OFF) {
+		gpio_set_value(info->pdata->gpio_act, 0);
+		udelay(10);
 		gpio_direction_output(info->pdata->gpio_act, 0);
-    pr_info("LM3559_POWER_OFF\n");
+		pr_info("LM3559_POWER_OFF\n");
+	} else {
+		gpio_direction_output(info->pdata->gpio_act, 1);
+		udelay(10);
+		gpio_set_value(info->pdata->gpio_act, 1);
+		pr_info("LM3559_POWER_ON\n");
 	}
-	else{
-    gpio_direction_output(info->pdata->gpio_act, 1);	
-    udelay(10);
-		gpio_set_value(info->pdata->gpio_act, 1);	
-    pr_info("LM3559_POWER_ON\n");
-	}
-  mdelay(1); /* delay for device startup */
-  
-  //pr_info("%s: lm3559_onoff_state=%d, onoff=%d\n",__func__, lm3559_onoff_state, onoff);
+	mdelay(1); /* delay for device startup */
+	//pr_info("%s: lm3559_onoff_state=%d, onoff=%d\n", __func__,
+	//		lm3559_onoff_state, onoff);
 }
 
 //static DEFINE_SPINLOCK(lm3559_spinlock);
@@ -393,28 +392,67 @@ static struct miscdevice lm3559_device = {
 	.fops = &lm3559_fileops,
 };
 
-
-static ssize_t torch_store(struct device* dev,
-		struct device_attribute* attr, const char* buf, size_t count)
+static int torch_apply(struct lm3559_info *info, int level)
 {
+	u8 enable = 0b00001000; // LED1 on
 	int val;
-	sscanf(buf, "%ld", &val );
 
-	if (val <= 0) {
+	pr_info("%s: %d", __func__, level);
+
+	if (level < 0) {
+		return -EINVAL;
+	}
+	if (level >= sizeof(lm3559_torch_table)) {
+		return -EINVAL;
+	}
+
+	if (level == 0) {
 		lm3559_power_onoff(info, LM3559_POWER_OFF);
 		lm3559_onoff_state = LM3559_POWER_OFF;
-	} else {
-        	struct lm3559_param param;
-		if(lm3559_onoff_state == LM3559_POWER_OFF){    
-			param.param = LM3559_TORCH_LEVEL;
-			param.value = (val == 2 ? 666 : 1);
-			lm3559_power_onoff(info, LM3559_POWER_ON);
-			lm3559_onoff_state = LM3559_POWER_ON;
-			lm3559_enable_torch_mode(info, LM3559_LED_LOW, param);
-		}          
-	}
-
-	return  count;
+		return 0;
+	}
+
+	val = lm3559_torch_table[level];
+
+	lm3559_power_onoff(info, LM3559_POWER_ON);
+	lm3559_onoff_state = LM3559_POWER_ON;
+
+	if (val & 0b01000000) { // LED2 on
+		enable |= 0b00010000;
+	}
+
+	if (val & 0b10000000) { // Torch
+		lm3559_write_reg(info->i2c_client,
+				LM3559_REG_TORCH_BRIGHTNESS, val & 0b00111111);
+		enable |= 0b00000010; // Torch mode
+		lm3559_write_reg(info->i2c_client,
+				LM3559_REG_ENABLE, enable);
+	} else { // Privacy
+		lm3559_write_reg(info->i2c_client,
+				LM3559_REG_PRIVACY, val & 0b00111111);
+		lm3559_write_reg(info->i2c_client,
+				LM3559_REG_PRIVACY_PWM, 0); // 5.12 ms
+		enable |= 0b00000001; // Privacy mode
+		lm3559_write_reg(info->i2c_client,
+				LM3559_REG_ENABLE, enable);
+	}
+}
+
+static ssize_t torch_store(struct device *dev,
+		struct device_attribute *attr, const char* buf, size_t count)
+{
+	int val;
+	int err = kstrtoint(buf, 0, &val);
+	if (err) {
+		return err;
+	}
+
+	err = torch_apply(info, val); // TODO: Kill global variable.
+	if (err) {
+		return err;
+	}
+
+	return count;
 }
 static DEVICE_ATTR(torch, 0666, NULL, torch_store);
 
diff --git a/drivers/misc/tspdrv/ImmVibeSPI.c b/drivers/misc/tspdrv/ImmVibeSPI.c
index b86e513..82aedfd 100644
--- a/drivers/misc/tspdrv/ImmVibeSPI.c
+++ b/drivers/misc/tspdrv/ImmVibeSPI.c
@@ -95,7 +95,7 @@ static int status = 0;
 
 #define PWM_PERIOD_DEFAULT              44000 //20.3KHz
 //#define PWM_DUTY_DEFAULT              (PWM_PERIOD_DEFAULT >> 1) //50%
-#define PWM_DUTY_DEFAULT              (PWM_PERIOD_DEFAULT *.75 ) //75%
+#define PWM_DUTY_DEFAULT              (PWM_PERIOD_DEFAULT *1 ) //100%
 
 VibeUInt32 g_nPWM_Freq = PWM_PERIOD_DEFAULT;
 
diff --git a/drivers/power/max8971-charger.c b/drivers/power/max8971-charger.c
index c6787eb..8b246403 100644
--- a/drivers/power/max8971-charger.c
+++ b/drivers/power/max8971-charger.c
@@ -175,6 +175,8 @@ struct max8971_chip {
 	int				chg_cable_type;
 	int				chg_status;
 	bool				chg_enable;
+	int				chgcc_forced;
+	int				dcilmt_forced;
 };
 
 static struct max8971_chip	*max8971_chg;
@@ -228,11 +230,19 @@ out:
 	return ret;
 }
 
+#define POWER_SUPPLY_TYPE_FORCED 9001
+
 extern unsigned char chg_flag_muic;
 extern unsigned char chg_700_flag;
 static int max8971_set_reg(struct max8971_chip *chip, int enable)
 {
 	u8 reg_val= 0;
+	int chg_cable_type = chip->chg_cable_type;
+
+	if (chip->chgcc_forced >= 5
+			&& chip->chgcc_forced <= 31) {
+		chg_cable_type = POWER_SUPPLY_TYPE_FORCED;
+	}
 
 	// unlock charger protection
 	reg_val = chip->pdata->chg_proctection  << MAX8971_CHGPROT_SHIFT;
@@ -244,7 +254,7 @@ static int max8971_set_reg(struct max8971_chip *chip, int enable)
 		dev_dbg(&chip->client->dev, "Charing enable..\n");
 
 		// Set fast charge current and timer
-		switch(chip->chg_cable_type) {
+		switch(chg_cable_type) {
 			case POWER_SUPPLY_TYPE_USB:
 				//                                                      
 				if( charging_mode != CHARGING_MHL ) {
@@ -266,6 +276,12 @@ static int max8971_set_reg(struct max8971_chip *chip, int enable)
 							(chip->pdata->fchgtime<<MAX8971_FCHGTIME_SHIFT));
 				}
 				break;
+
+			case POWER_SUPPLY_TYPE_FORCED:
+				reg_val = (chip->chgcc_forced << MAX8971_CHGCC_SHIFT) |
+						(chip->pdata->fchgtime << MAX8971_FCHGTIME_SHIFT);
+				break;
+
 			case POWER_SUPPLY_TYPE_MAINS:
 //                                                                          
 //                    
@@ -286,6 +302,7 @@ static int max8971_set_reg(struct max8971_chip *chip, int enable)
 				reg_val = ((chip->pdata->chgcc_factory << MAX8971_CHGCC_SHIFT) |
 						(chip->pdata->fchgtime<<MAX8971_FCHGTIME_SHIFT));
 				break;
+
 			default :
 				dev_dbg(&chip->client->dev, "Unknown charger cabel type!!!\n");
 				reg_val = ((chip->pdata->chgcc_usb500 << MAX8971_CHGCC_SHIFT) |
@@ -305,7 +322,7 @@ static int max8971_set_reg(struct max8971_chip *chip, int enable)
 		dev_dbg(&chip->client->dev, "MAX8971_REG_FCHGCRNT(0x%x) = 0x%x\n", MAX8971_REG_FCHGCRNT, reg_val);
 		
 		// Set input current limit and charger restart threshold
-		switch(chip->chg_cable_type) {
+		switch(chg_cable_type) {
 			case POWER_SUPPLY_TYPE_USB:
 				//                                                      
 				if( charging_mode != CHARGING_MHL ) {
@@ -316,6 +333,10 @@ static int max8971_set_reg(struct max8971_chip *chip, int enable)
 					(chip->pdata->dcilmt_mhl400 << MAX8971_DCILMT_SHIFT));
 				}
 				break;
+			case POWER_SUPPLY_TYPE_FORCED:
+				reg_val = (chip->pdata->chgrstrt << MAX8971_CHGRSTRT_SHIFT) |
+						(chip->dcilmt_forced << MAX8971_DCILMT_SHIFT);
+				break;
 			case POWER_SUPPLY_TYPE_MAINS:
 				if(chg_700_flag == 1){
 					reg_val = ((chip->pdata->chgrstrt << MAX8971_CHGRSTRT_SHIFT) |
@@ -346,7 +367,7 @@ static int max8971_set_reg(struct max8971_chip *chip, int enable)
 				(chip->pdata->chgcv << MAX8971_CHGCV_SHIFT) |
 				(chip->pdata->ifst2p8 << MAX8971_IFST2P8_SHIFT));
 #endif
-		switch(chip->chg_cable_type) {
+		switch(chg_cable_type) {
 			case POWER_SUPPLY_TYPE_USB:
 				//                                                      
 				if( charging_mode != CHARGING_MHL ) {
@@ -361,6 +382,7 @@ static int max8971_set_reg(struct max8971_chip *chip, int enable)
 					(chip->pdata->ifst2p8_mhl400 << MAX8971_IFST2P8_SHIFT));
 				}
 				break;
+			case POWER_SUPPLY_TYPE_FORCED:
 			case POWER_SUPPLY_TYPE_MAINS:
 				reg_val = ((chip->pdata->topofftime << MAX8971_TOPOFFTIME_SHIFT) |
 				(chip->pdata->topofftshld << MAX8971_TOPOFFTSHLD_SHIFT) |
@@ -394,7 +416,7 @@ static int max8971_set_reg(struct max8971_chip *chip, int enable)
 		if(chg_flag_muic >= MAX_CHARGER_INT_COUNT)		//                                                                    
 		{
 			//                                                                                           
-			if(chip->chg_cable_type == POWER_SUPPLY_TYPE_USB){
+			if(chg_cable_type == POWER_SUPPLY_TYPE_USB){
 			reg_val = (0x0 << MAX8971_DCMON_DIS_SHIFT)
 				|(chip->pdata->suspend_usb << MAX8971_USB_SUS_SHIFT);
 		}
@@ -981,6 +1003,58 @@ static DEVICE_ATTR(chgcc_ta, S_IRUGO | S_IWUSR | S_IRGRP | S_IWGRP,
 		   max8971_charger_show_chgcc_ta,
 		   max8971_charger_store_chgcc_ta);
 
+static ssize_t max8971_charger_show_chgcc_forced(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct max8971_chip *chip = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", chip->chgcc_forced);
+}
+
+static ssize_t max8971_charger_store_chgcc_forced(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct max8971_chip *chip = dev_get_drvdata(dev);
+	if (!count) {
+		return -EINVAL;
+	}
+	chip->chgcc_forced = simple_strtoul(buf, NULL, 10);
+	if (chip->chg_enable) {
+		max8971_set_reg(chip, 1);
+	}
+	return count;
+}
+
+DEVICE_ATTR(chgcc_forced, 0660, max8971_charger_show_chgcc_forced,
+		max8971_charger_store_chgcc_forced);
+
+static ssize_t max8971_charger_show_dcilmt_forced(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct max8971_chip *chip = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", chip->dcilmt_forced);
+}
+
+static ssize_t max8971_charger_store_dcilmt_forced(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct max8971_chip *chip = dev_get_drvdata(dev);
+	if (!count) {
+		return -EINVAL;
+	}
+	int val = simple_strtoul(buf, NULL, 10);
+	if (val < 9 || val > 63) {
+		return -EINVAL;
+	}
+	chip->dcilmt_forced = val;
+	if (chip->chg_enable) {
+		max8971_set_reg(chip, 1);
+	}
+	return count;
+}
+
+DEVICE_ATTR(dcilmt_forced, 0660, max8971_charger_show_dcilmt_forced,
+		max8971_charger_store_dcilmt_forced);
+
 
 static __devinit int max8971_probe(struct i2c_client *client, 
 				   const struct i2c_device_id *id)
@@ -1075,15 +1149,37 @@ static __devinit int max8971_probe(struct i2c_client *client,
 	}
 */
 
- 	ret = device_create_file(&client->dev, &dev_attr_chgcc_ta);
-        if (ret < 0) {
-                printk("device_create_file error!\n");
-                return ret;
+	chip->chgcc_forced = 0;
+	chip->dcilmt_forced = 60;
+
+	ret = device_create_file(&client->dev, &dev_attr_chgcc_ta);
+	if (ret < 0) {
+		printk("device_create_file(chgcc_ta) error!\n");
+		goto err;
 	}
+
+	ret = device_create_file(&client->dev, &dev_attr_chgcc_forced);
+	if (ret < 0) {
+		printk("device_create_file(chgcc_forced) error!\n");
+		goto err_chgcc_forced;
+	}
+
+	ret = device_create_file(&client->dev, &dev_attr_dcilmt_forced);
+	if (ret < 0) {
+		printk("device_create_file(dcilmt_forced) error!\n");
+		goto err_dcilmt_forced;
+	}
+
 	dev_info(&client->dev, "%s finish...\n", __func__);
 
 	return 0;
 
+err_dcilmt_forced:
+	device_remove_file(&client->dev, &dev_attr_chgcc_forced);
+
+err_chgcc_forced:
+	device_remove_file(&client->dev, &dev_attr_chgcc_ta);
+
 err:
 	free_irq(client->irq, chip);
 
@@ -1108,6 +1204,10 @@ static __devexit int max8971_remove(struct i2c_client *client)
 	//kkk_test
 	//cancel_delayed_work(&chip->monitor_work);
 
+	device_remove_file(&client->dev, &dev_attr_dcilmt_forced);
+	device_remove_file(&client->dev, &dev_attr_chgcc_forced);
+	device_remove_file(&client->dev, &dev_attr_chgcc_ta);
+
 	gpio_free(TEGRA_GPIO_PJ2);
 	free_irq(client->irq, chip);
 	power_supply_unregister(&chip->charger);
@@ -1186,7 +1286,8 @@ module_exit(max8971_exit);
 
 
 MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Clark Kim <clark.kim@maxim-ic.com>");
+MODULE_AUTHOR("Clark Kim <clark.kim@maxim-ic.com>"
+		", Michael Zhou <mzhou@cse.unsw.edu.au>");
 MODULE_DESCRIPTION("Power supply driver for MAX8971");
 MODULE_VERSION("3.3");
 MODULE_ALIAS("platform:max8971-charger");
diff --git a/drivers/video/backlight/lm3533_bl.c b/drivers/video/backlight/lm3533_bl.c
index f0ee1d9..95270ae 100644
--- a/drivers/video/backlight/lm3533_bl.c
+++ b/drivers/video/backlight/lm3533_bl.c
@@ -46,6 +46,10 @@
 #define LEDS_BACKLIGHT_NAME 		"lcd-backlight"
 #endif
 
+#define LM3533_BL_MAX_MAXCURRENT	23
+#define LM3533_BL_DEFAULT_MAXCURRENT	19
+#define LM3533_BL_MIN_MAXCURRENT	0
+
 static unsigned char default_160nit_53percent_lut[256]={
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,
 1,1,1,1,1,1,2,2,2,2,2,2,2,3,3,3,3,3,3,4,
@@ -78,6 +82,7 @@ struct lm3533_device {
 	int			bl_status;
 	struct mutex 		bl_mutex;
 	struct mutex 		bl_mutex_saved;
+	int			cur_maxcurrent;
 };
 
 struct lm3533_device *lm3533dev;
@@ -174,10 +179,12 @@ static void lm3533_set_main_current_level(struct i2c_client *client, int level)
 			cal_value = LM3533_BL_MIN_BRIGHTNESS;
 		}
 #endif
+		lm3533_bl_write_reg(client, 0x1F, dev->cur_maxcurrent);
 		lm3533_bl_write_reg(client, 0x40, cal_value);
 	}
 	else if(level == 0){
 		cal_value = level;
+		lm3533_bl_write_reg(client, 0x1F, dev->cur_maxcurrent);
 		lm3533_bl_write_reg(client, 0x40, cal_value);
 	}
 	mutex_unlock(&lm3533dev->bl_mutex);
@@ -200,7 +207,6 @@ static void lm3533_backlight_on(struct i2c_client *client, int level)
 	lm3533_bl_write_reg(client, 0x14, 0x0); //PWM input is disabled for CABC
 #endif
 	lm3533_bl_write_reg(client, 0x1A, 0x2); //Linear & Control Bank A is configured for register Current control
-	lm3533_bl_write_reg(client, 0x1F, 0x13); //Full-Scale Current (20.2mA)
 	lm3533_bl_write_reg(client, 0x27, 0x1); //Control Bank A is enable
 #if !defined(CONFIG_MACH_HD5_LGD)        
 	lm3533_bl_write_reg(client, 0x2C, 0x0A); //                                                                                   
@@ -411,6 +417,59 @@ static ssize_t lm3533_bl_store_on_off(struct device *dev,
 DEVICE_ATTR(lm3533_bl_level, 0660, lm3533_bl_show_lvl, lm3533_bl_store_lvl);
 DEVICE_ATTR(lm3533_bl_onoff, 0660, lm3533_bl_show_on_off, lm3533_bl_store_on_off);
 
+static void lm3533_lcd_backlight_set_maxcurrent(struct i2c_client *client,
+		int level)
+{
+	struct lm3533_device *dev = i2c_get_clientdata(client);
+
+	if (level > LM3533_BL_MAX_MAXCURRENT)
+		level = LM3533_BL_MAX_MAXCURRENT;
+	if (level < LM3533_BL_MIN_MAXCURRENT)
+		level = LM3533_BL_MIN_MAXCURRENT;
+
+	dev->cur_maxcurrent = level;
+	lm3533_set_main_current_level(client, dev->saved_main_lcd_level);
+}
+
+static ssize_t lm3533_bl_show_maxcurrent(struct device *dev,
+		struct device_attribute *attr,
+		char *buf)
+{
+	int r;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lm3533_device *lm3533_dev = i2c_get_clientdata(client);
+
+	r = snprintf(buf, PAGE_SIZE,
+			"%d\n",
+			lm3533_dev->cur_maxcurrent);
+
+	return r;
+}
+
+static ssize_t lm3533_bl_store_maxcurrent(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf,
+		size_t count)
+{
+	int level;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (!count) {
+		dev_err(&client->dev,
+				"Invalid argument while storing maxcurrent\n");
+		return -EINVAL;
+	}
+
+	level = simple_strtoul(buf, NULL, 10);
+
+	lm3533_lcd_backlight_set_maxcurrent(client, level);
+
+	return count;
+}
+
+DEVICE_ATTR(lm3533_bl_maxcurrent, 0660, lm3533_bl_show_maxcurrent,
+		lm3533_bl_store_maxcurrent);
+
 #ifdef CONFIG_LM3533_LEDS_CLASS
 
 static int lm3533_bl_get_intensity(struct lm3533_device *drvdata)
@@ -502,6 +561,7 @@ static int __devinit lm3533_bl_probe(struct i2c_client *i2c_dev,
 	dev->cur_main_lcd_level= LM3533_BL_DEFAULT_BRIGHTNESS;
 	dev->saved_main_lcd_level= LM3533_BL_DEFAULT_BRIGHTNESS;
 	dev->bl_status = BL_OFF;
+	dev->cur_maxcurrent = LM3533_BL_DEFAULT_MAXCURRENT;
 
 	err = led_classdev_register(&i2c_dev->dev, &lm3533_led_dev);
 	if (err < 0) {
@@ -538,6 +598,11 @@ static int __devinit lm3533_bl_probe(struct i2c_client *i2c_dev,
 		dev_err(&i2c_dev->dev, "device_create_file(onoff) failed\n");
 		goto err_device_create_file_2;
 	}
+	err = device_create_file(&i2c_dev->dev, &dev_attr_lm3533_bl_maxcurrent);
+	if (err < 0) {
+		dev_err(&i2c_dev->dev, "device_create_file(maxcurrent) failed\n");
+		goto err_device_create_file_3;
+	}
 
 	lm3533dev = dev;
 
@@ -547,6 +612,8 @@ static int __devinit lm3533_bl_probe(struct i2c_client *i2c_dev,
 
 	return 0;
 
+err_device_create_file_3:
+	device_remove_file(&i2c_dev->dev, &dev_attr_lm3533_bl_onoff);
 err_device_create_file_2:
 	device_remove_file(&i2c_dev->dev, &dev_attr_lm3533_bl_level);
 err_device_create_file_1:
@@ -570,6 +637,7 @@ static int __devexit lm3533_bl_remove(struct i2c_client *i2c_dev)
 
  	device_remove_file(&i2c_dev->dev, &dev_attr_lm3533_bl_level);
 	device_remove_file(&i2c_dev->dev, &dev_attr_lm3533_bl_onoff);
+	device_remove_file(&i2c_dev->dev, &dev_attr_lm3533_bl_maxcurrent);
 
 	led_classdev_unregister(dev->led);
 
@@ -614,5 +682,6 @@ module_init(lm3533_init);
 module_exit(lm3533_exit);
 
 MODULE_DESCRIPTION("LM3533 Backlight Control");
-MODULE_AUTHOR("Jaeseong Gim <jaeseong.gim@lge.com>");
+MODULE_AUTHOR("Jaeseong Gim <jaeseong.gim@lge.com>"
+		", Michael Zhou <mzhou@cse.unsw.edu.au>");
 MODULE_LICENSE("GPL");
diff --git a/include/linux/input/lge_touch_core.h b/include/linux/input/lge_touch_core.h
index cbda30a..910e71af 100644
--- a/include/linux/input/lge_touch_core.h
+++ b/include/linux/input/lge_touch_core.h
@@ -350,9 +350,9 @@ enum{
 #define LGE_TOUCH_NAME		"lge_touch"
 
 /* Debug Mask setting */
-#define TOUCH_DEBUG_PRINT   (0)
-#define TOUCH_ERROR_PRINT   (1)
-#define TOUCH_INFO_PRINT   	(0)
+//#define TOUCH_DEBUG_PRINT
+#define TOUCH_ERROR_PRINT
+//#define TOUCH_INFO_PRINT
 
 #if defined(TOUCH_INFO_PRINT)
 #define TOUCH_INFO_MSG(fmt, args...) \
diff --git a/include/media/lm3559.h b/include/media/lm3559.h
index 7e8daf2..6501357 100644
--- a/include/media/lm3559.h
+++ b/include/media/lm3559.h
@@ -6,22 +6,22 @@
 //#define LM3559_MAX_TORCH_LEVEL	11
 //#define LM3559_MAX_FLASH_LEVEL	20
 
-#define LM3559_FLASH_LEVEL		        0
-#define LM3559_TORCH_LEVEL		        1
+#define LM3559_FLASH_LEVEL		0
+#define LM3559_TORCH_LEVEL		1
 
-#define LM3559_POWER_OFF				      1
-#define LM3559_POWER_STANDBY					2
-#define LM3559_POWER_ON					      3
+#define LM3559_POWER_OFF		1
+#define LM3559_POWER_STANDBY		2
+#define LM3559_POWER_ON			3
 
 struct lm3559_param {
 	int param;
-  int value;
+	int value;
 	//__s32 sizeofvalue;
 	//void *p_value;
 };
 
-#define LM3559_IOCTL_P0WER_CONT   _IOW('o', 13, int)
-#define LM3559_IOCTL_FLASH_TORCH  _IOW('o', 14, struct lm3559_param)
+#define LM3559_IOCTL_P0WER_CONT		_IOW('o', 13, int)
+#define LM3559_IOCTL_FLASH_TORCH	_IOW('o', 14, struct lm3559_param)
 
 struct lm3559_platform_data {
 	//unsigned cfg; /* use the NVC_CFG_ defines */
