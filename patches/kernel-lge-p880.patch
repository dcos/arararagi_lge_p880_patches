diff --git a/arch/arm/mach-tegra/baseband-xmm-power.c b/arch/arm/mach-tegra/baseband-xmm-power.c
index 487c244..f7d40ba 100644
--- a/arch/arm/mach-tegra/baseband-xmm-power.c
+++ b/arch/arm/mach-tegra/baseband-xmm-power.c
@@ -462,8 +462,8 @@ void baseband_xmm_set_power_status(unsigned int status)
 		}	
 		pr_debug("PM_ST : L0\n");
 		baseband_xmm_powerstate = status;
-		if (!wake_lock_active(&wakelock))
-			wake_lock(&wakelock);
+		//if (!wake_lock_active(&wakelock))
+		//	wake_lock(&wakelock);
 		value = gpio_get_value(data->modem.xmm.ipc_hsic_active);
 		//pr_debug("GPIO [R]: before L0 Host_active = %d \n", value); 
 		if (!value) {
@@ -730,8 +730,8 @@ static void baseband_xmm_power_L2_resume(void)
 		return;
 
 	/* claim the wakelock here to avoid any system suspend */
-	if (!wake_lock_active(&wakelock))
-		wake_lock(&wakelock);
+	//if (!wake_lock_active(&wakelock))
+	//	wake_lock(&wakelock);
 	modem_sleep_flag = false;
 	spin_lock_irqsave(&xmm_lock, flags);
 	wakeup_pending = false;
diff --git a/drivers/media/video/tegra/lm3559.c b/drivers/media/video/tegra/lm3559.c
index be6e9fa..e47e135 100644
--- a/drivers/media/video/tegra/lm3559.c
+++ b/drivers/media/video/tegra/lm3559.c
@@ -14,11 +14,9 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 
+ * Foundation, Inc.,
  */
 
-
-
 #include <linux/fs.h>
 #include <linux/i2c.h>
 #include <linux/miscdevice.h>
@@ -30,37 +28,32 @@
 #include <linux/gpio.h>
 #include <media/lm3559.h>
 
-#define LM3559_I2C_NAME  				"lm3559"
-
-#if 1 //                 
-#define LGE_X3_LM3559_FLASH_TORCH_CURRENT_FIXED 1
-#endif
+#define LM3559_I2C_NAME			"lm3559"
 
 /* Register Descriptions */
-#define LM3559_REG_ENABLE				      0x10
-#define LM3559_REG_GPIO					      0x20
-#define LM3559_REG_VLED_MONITOR			  0x30
-#define LM3559_REG_ADC_DELAY			    0x31
-#define LM3559_REG_VIN_MONITOR			  0x80
-#define LM3559_REG_LAST_FLASH			    0x81
-#define LM3559_REG_TORCH_BRIGHTNESS	  0xA0
-#define LM3559_REG_FLASH_BRIGHTNESS	  0xB0
-#define LM3559_REG_FLASH_DURATION		  0xC0
-#define LM3559_REG_FLAGS				      0xD0
-#define LM3559_REG_CONFIGURATION1		  0xE0
-#define LM3559_REG_CONFIGURATION2		  0xF0
-#define LM3559_REG_PRIVACY				    0x11
+#define LM3559_REG_ENABLE		0x10
+#define LM3559_REG_GPIO			0x20
+#define LM3559_REG_VLED_MONITOR		0x30
+#define LM3559_REG_ADC_DELAY		0x31
+#define LM3559_REG_VIN_MONITOR		0x80
+#define LM3559_REG_LAST_FLASH		0x81
+#define LM3559_REG_TORCH_BRIGHTNESS	0xA0
+#define LM3559_REG_FLASH_BRIGHTNESS	0xB0
+#define LM3559_REG_FLASH_DURATION	0xC0
+#define LM3559_REG_FLAGS		0xD0
+#define LM3559_REG_CONFIGURATION1	0xE0
+#define LM3559_REG_CONFIGURATION2	0xF0
+#define LM3559_REG_PRIVACY		0x11
 #define LM3559_REG_MESSAGE_INDICATOR	0x12
 #define LM3559_REG_INDICATOR_BLINKING	0x13
-#define LM3559_REG_PRIVACY_PWM			  0x14
+#define LM3559_REG_PRIVACY_PWM		0x14
 
-
-enum{
-   LM3559_LED_OFF,
-   LM3559_LED_LOW,
-   LM3559_LED_HIGH,
-   LM3559_LED_MAX
-}; 
+enum {
+	LM3559_LED_OFF,
+	LM3559_LED_LOW,
+	LM3559_LED_HIGH,
+	LM3559_LED_MAX
+};
 
 struct lm3559_info {
 	struct i2c_client *i2c_client;
@@ -71,10 +64,9 @@ struct lm3559_info {
 static struct lm3559_info *info;
 static int lm3559_onoff_state = LM3559_POWER_OFF;
 
-#ifndef LGE_X3_LM3559_FLASH_TORCH_CURRENT_FIXED
-static unsigned char lm3559_flash_lvl[16] = {  
-		
-      0x00, //0000 0000 
+// TODO: Use finer grading
+static unsigned char lm3559_flash_lvl[16] = {
+      0x00, //0000 0000
       0x11, //0001 0001
       0x22, //0010 0010
       0x33, //0011 0011
@@ -86,60 +78,80 @@ static unsigned char lm3559_flash_lvl[16] = {
       0x99, //1001 1001
       0xaa, //1010 1010
       0xbb, //1011 1011
-      0xcc, //1100 1100 
+      0xcc, //1100 1100
       0xdd, //1101 1101
       0xee, //1110 1110
-      0xff, //1111 1111     
+      0xff, //1111 1111
 };
 
-static unsigned char lm3559_torch_lvl[8] = {  
-		
-      0x00, //000 000 
-      0x09, //001 001
-      0x12, //010 010 
-      0x1b, //011 011
-      0x24, //100 100 -> fixed value
-      0x2d, //101 101
-      0x36, //110 110 
-      0x3f, //111 111
+// [5:0] Register value [5:0]
+// [6] 1 => LED2 on, 0 => LED2 off
+// [7] 1 => Torch, 0 => Privacy
+static u8 lm3559_torch_table[] = {
+	0,	// Off
+	228,	// CM default
+	255,	// CM high
+	24, 24, 24, 24, 24, 24, 24, // Filler
+	24,	// 10
+	120,	// 11
+	26,	// 12
+	121,	// 13
+	28,	// 14
+	122,	// 15
+	30,	// 16
+	123,	// 17
+	124,	// 18
+	125,	// 19
+	126,	// 20
+	127,	// 21
+	192,	// 22
+	200,	// 23
+	201,	// 24
+	209,	// 25
+	210,	// 26
+	218,	// 27
+	219,	// 28
+	227,	// 29
+	228,	// 30 CM default
+	236,	// 31
+	237,	// 32
+	245,	// 33
+	246,	// 34
+	254,	// 35
+	255,	// CM high
 };
-#endif
 
 int lm3559_write_reg(struct i2c_client *client, unsigned char addr, unsigned char data)
 {
-	int err = 0;  
+	int err = 0;
 	int retry = 0;
 
-	unsigned char buf[2] ={0,};
-	
+	u8 buf[2] = {0};
+
 	struct i2c_msg msg[] = {
 		{
-			.addr  = client->addr, 
-			.flags = 0, 
-			.len   = 2, 
-			.buf   = buf, 
+			.addr	= client->addr,
+			.flags	= 0,
+			.len	= 2,
+			.buf	= buf,
 		},
 	};
 
 	buf[0] = addr;
 	buf[1] = data;
 
-#if 0	//                 
-	if ((err = i2c_transfer(client->adapter, &msg[0], 1)) < 0) {
-		dev_err(&client->dev, "i2c write error [%d]\n",err);
-	}
-#else
-  do {
+	do {
 		err = i2c_transfer(client->adapter, &msg[0], 1);
-		if (err == 1)
+		if (err == 1) {
 			return 0;
+		}
 		retry++;
-		pr_err("lm3559: i2c transfer failed, retrying %x %x\n",addr, data);
+		pr_err("lm3559: i2c transfer failed, retrying %x %x\n",
+				addr, data);
 		msleep(1);
-	} while (retry <= 3);
-#endif	
-	return err;
+	} while (retry < 3);
 
+	return err;
 }
 
 int lm3559_read_reg(struct i2c_client *client, unsigned char addr, unsigned char *data)
@@ -169,40 +181,28 @@ int lm3559_read_reg(struct i2c_client *client, unsigned char addr, unsigned char
 }
 
 void lm3559_led_shutdown(struct lm3559_info *info)
-{	
+{
 	lm3559_write_reg(info->i2c_client,LM3559_REG_ENABLE,0x18);
 }
 
-/*	Torch Current
-	 000 : 28.125 mA		100 : 140.625 mA	 
-	 001 : 56.25 mA 		101 : 168.75 mA
-	 010 : 84.375 mA 		110 : 196.875 mA
-	 011 : 112.5mA  		111 : 225 mA
-*/
-void lm3559_enable_torch_mode(struct lm3559_info *info, int state, struct lm3559_param param)
+// Don't use.
+static void lm3559_enable_torch_mode(
+		struct lm3559_info *info, int state, struct lm3559_param param)
 {
-#ifndef LGE_X3_LM3559_FLASH_TORCH_CURRENT_FIXED  
   unsigned char level_value;
-#endif
-
-	//pr_info("%s: state=%d, arg=%d\n",__func__, state, param.value);
-
-#ifdef LGE_X3_LM3559_FLASH_TORCH_CURRENT_FIXED			
-  pr_info("%s:[LGE fixed]  Level: 140.625 (Total 281.25) mA \n",__func__);
 
-  // 0x24 : 100 100 -> 140.625
-  lm3559_write_reg(info->i2c_client,LM3559_REG_TORCH_BRIGHTNESS,0x24);  
-  udelay(10);
-#else
   level_value = (unsigned char)param.value-1;
-  lm3559_write_reg(info->i2c_client,LM3559_REG_TORCH_BRIGHTNESS,lm3559_torch_lvl[level_value]);  
+  if (level_value < 0) {
+    level_value = 0;
+  }
+  if (level_value > 63) {
+    level_value = 63;
+  }
+  lm3559_write_reg(info->i2c_client, LM3559_REG_TORCH_BRIGHTNESS, level_value);
   pr_info("%s: Level: %d \n",__func__, level_value);
-#endif
 
-	lm3559_write_reg(info->i2c_client,LM3559_REG_ENABLE,0x1A);
+lm3559_write_reg(info->i2c_client,LM3559_REG_ENABLE,0x1A);
   udelay(10);
-
-
 }
 
 /*	 Flash Current
@@ -252,23 +252,22 @@ void lm3559_enable_flash_mode(struct lm3559_info *info, int state, struct lm3559
 
 }
 
-void lm3559_power_onoff(struct lm3559_info *info, int onoff){
-
-	if(onoff == LM3559_POWER_OFF){
-		gpio_set_value(info->pdata->gpio_act, 0);		
-    udelay(10);
+static void lm3559_power_onoff(struct lm3559_info *info, int onoff)
+{
+	if (onoff == LM3559_POWER_OFF) {
+		gpio_set_value(info->pdata->gpio_act, 0);
+		udelay(10);
 		gpio_direction_output(info->pdata->gpio_act, 0);
-    pr_info("LM3559_POWER_OFF\n");
-	}
-	else{
-    gpio_direction_output(info->pdata->gpio_act, 1);	
-    udelay(10);
-		gpio_set_value(info->pdata->gpio_act, 1);	
-    pr_info("LM3559_POWER_ON\n");
+		pr_info("LM3559_POWER_OFF\n");
+	} else {
+		gpio_direction_output(info->pdata->gpio_act, 1);
+		udelay(10);
+		gpio_set_value(info->pdata->gpio_act, 1);
+		pr_info("LM3559_POWER_ON\n");
 	}
-  mdelay(1); /* delay for device startup */
-  
-  //pr_info("%s: lm3559_onoff_state=%d, onoff=%d\n",__func__, lm3559_onoff_state, onoff);
+	mdelay(1); /* delay for device startup */
+	//pr_info("%s: lm3559_onoff_state=%d, onoff=%d\n", __func__,
+	//		lm3559_onoff_state, onoff);
 }
 
 //static DEFINE_SPINLOCK(lm3559_spinlock);
@@ -393,28 +392,67 @@ static struct miscdevice lm3559_device = {
 	.fops = &lm3559_fileops,
 };
 
-
-static ssize_t torch_store(struct device* dev,
-		struct device_attribute* attr, const char* buf, size_t count)
+static int torch_apply(struct lm3559_info *info, int level)
 {
+	u8 enable = 0b00001000; // LED1 on
 	int val;
-	sscanf(buf, "%ld", &val );
 
-	if (val <= 0) {
+	pr_info("%s: %d", __func__, level);
+
+	if (level < 0) {
+		return -EINVAL;
+	}
+	if (level >= sizeof(lm3559_torch_table)) {
+		return -EINVAL;
+	}
+
+	if (level == 0) {
 		lm3559_power_onoff(info, LM3559_POWER_OFF);
 		lm3559_onoff_state = LM3559_POWER_OFF;
-	} else {
-        	struct lm3559_param param;
-		if(lm3559_onoff_state == LM3559_POWER_OFF){    
-			param.param = LM3559_TORCH_LEVEL;
-			param.value = (val == 2 ? 666 : 1);
-			lm3559_power_onoff(info, LM3559_POWER_ON);
-			lm3559_onoff_state = LM3559_POWER_ON;
-			lm3559_enable_torch_mode(info, LM3559_LED_LOW, param);
-		}          
+		return 0;
+	}
+
+	val = lm3559_torch_table[level];
+
+	lm3559_power_onoff(info, LM3559_POWER_ON);
+	lm3559_onoff_state = LM3559_POWER_ON;
+
+	if (val & 0b01000000) { // LED2 on
+		enable |= 0b00010000;
+	}
+
+	if (val & 0b10000000) { // Torch
+		lm3559_write_reg(info->i2c_client,
+				LM3559_REG_TORCH_BRIGHTNESS, val & 0b00111111);
+		enable |= 0b00000010; // Torch mode
+		lm3559_write_reg(info->i2c_client,
+				LM3559_REG_ENABLE, enable);
+	} else { // Privacy
+		lm3559_write_reg(info->i2c_client,
+				LM3559_REG_PRIVACY, val & 0b00111111);
+		lm3559_write_reg(info->i2c_client,
+				LM3559_REG_PRIVACY_PWM, 0); // 5.12 ms
+		enable |= 0b00000001; // Privacy mode
+		lm3559_write_reg(info->i2c_client,
+				LM3559_REG_ENABLE, enable);
+	}
+}
+
+static ssize_t torch_store(struct device *dev,
+		struct device_attribute *attr, const char* buf, size_t count)
+{
+	int val;
+	int err = kstrtoint(buf, 0, &val);
+	if (err) {
+		return err;
+	}
+
+	err = torch_apply(info, val); // TODO: Kill global variable.
+	if (err) {
+		return err;
 	}
 
-	return  count;
+	return count;
 }
 static DEVICE_ATTR(torch, 0666, NULL, torch_store);
 
diff --git a/drivers/power/max8971-charger.c b/drivers/power/max8971-charger.c
index c6787eb..8b246403 100644
--- a/drivers/power/max8971-charger.c
+++ b/drivers/power/max8971-charger.c
@@ -175,6 +175,8 @@ struct max8971_chip {
 	int				chg_cable_type;
 	int				chg_status;
 	bool				chg_enable;
+	int				chgcc_forced;
+	int				dcilmt_forced;
 };
 
 static struct max8971_chip	*max8971_chg;
@@ -228,11 +230,19 @@ out:
 	return ret;
 }
 
+#define POWER_SUPPLY_TYPE_FORCED 9001
+
 extern unsigned char chg_flag_muic;
 extern unsigned char chg_700_flag;
 static int max8971_set_reg(struct max8971_chip *chip, int enable)
 {
 	u8 reg_val= 0;
+	int chg_cable_type = chip->chg_cable_type;
+
+	if (chip->chgcc_forced >= 5
+			&& chip->chgcc_forced <= 31) {
+		chg_cable_type = POWER_SUPPLY_TYPE_FORCED;
+	}
 
 	// unlock charger protection
 	reg_val = chip->pdata->chg_proctection  << MAX8971_CHGPROT_SHIFT;
@@ -244,7 +254,7 @@ static int max8971_set_reg(struct max8971_chip *chip, int enable)
 		dev_dbg(&chip->client->dev, "Charing enable..\n");
 
 		// Set fast charge current and timer
-		switch(chip->chg_cable_type) {
+		switch(chg_cable_type) {
 			case POWER_SUPPLY_TYPE_USB:
 				//                                                      
 				if( charging_mode != CHARGING_MHL ) {
@@ -266,6 +276,12 @@ static int max8971_set_reg(struct max8971_chip *chip, int enable)
 							(chip->pdata->fchgtime<<MAX8971_FCHGTIME_SHIFT));
 				}
 				break;
+
+			case POWER_SUPPLY_TYPE_FORCED:
+				reg_val = (chip->chgcc_forced << MAX8971_CHGCC_SHIFT) |
+						(chip->pdata->fchgtime << MAX8971_FCHGTIME_SHIFT);
+				break;
+
 			case POWER_SUPPLY_TYPE_MAINS:
 //                                                                          
 //                    
@@ -286,6 +302,7 @@ static int max8971_set_reg(struct max8971_chip *chip, int enable)
 				reg_val = ((chip->pdata->chgcc_factory << MAX8971_CHGCC_SHIFT) |
 						(chip->pdata->fchgtime<<MAX8971_FCHGTIME_SHIFT));
 				break;
+
 			default :
 				dev_dbg(&chip->client->dev, "Unknown charger cabel type!!!\n");
 				reg_val = ((chip->pdata->chgcc_usb500 << MAX8971_CHGCC_SHIFT) |
@@ -305,7 +322,7 @@ static int max8971_set_reg(struct max8971_chip *chip, int enable)
 		dev_dbg(&chip->client->dev, "MAX8971_REG_FCHGCRNT(0x%x) = 0x%x\n", MAX8971_REG_FCHGCRNT, reg_val);
 		
 		// Set input current limit and charger restart threshold
-		switch(chip->chg_cable_type) {
+		switch(chg_cable_type) {
 			case POWER_SUPPLY_TYPE_USB:
 				//                                                      
 				if( charging_mode != CHARGING_MHL ) {
@@ -316,6 +333,10 @@ static int max8971_set_reg(struct max8971_chip *chip, int enable)
 					(chip->pdata->dcilmt_mhl400 << MAX8971_DCILMT_SHIFT));
 				}
 				break;
+			case POWER_SUPPLY_TYPE_FORCED:
+				reg_val = (chip->pdata->chgrstrt << MAX8971_CHGRSTRT_SHIFT) |
+						(chip->dcilmt_forced << MAX8971_DCILMT_SHIFT);
+				break;
 			case POWER_SUPPLY_TYPE_MAINS:
 				if(chg_700_flag == 1){
 					reg_val = ((chip->pdata->chgrstrt << MAX8971_CHGRSTRT_SHIFT) |
@@ -346,7 +367,7 @@ static int max8971_set_reg(struct max8971_chip *chip, int enable)
 				(chip->pdata->chgcv << MAX8971_CHGCV_SHIFT) |
 				(chip->pdata->ifst2p8 << MAX8971_IFST2P8_SHIFT));
 #endif
-		switch(chip->chg_cable_type) {
+		switch(chg_cable_type) {
 			case POWER_SUPPLY_TYPE_USB:
 				//                                                      
 				if( charging_mode != CHARGING_MHL ) {
@@ -361,6 +382,7 @@ static int max8971_set_reg(struct max8971_chip *chip, int enable)
 					(chip->pdata->ifst2p8_mhl400 << MAX8971_IFST2P8_SHIFT));
 				}
 				break;
+			case POWER_SUPPLY_TYPE_FORCED:
 			case POWER_SUPPLY_TYPE_MAINS:
 				reg_val = ((chip->pdata->topofftime << MAX8971_TOPOFFTIME_SHIFT) |
 				(chip->pdata->topofftshld << MAX8971_TOPOFFTSHLD_SHIFT) |
@@ -394,7 +416,7 @@ static int max8971_set_reg(struct max8971_chip *chip, int enable)
 		if(chg_flag_muic >= MAX_CHARGER_INT_COUNT)		//                                                                    
 		{
 			//                                                                                           
-			if(chip->chg_cable_type == POWER_SUPPLY_TYPE_USB){
+			if(chg_cable_type == POWER_SUPPLY_TYPE_USB){
 			reg_val = (0x0 << MAX8971_DCMON_DIS_SHIFT)
 				|(chip->pdata->suspend_usb << MAX8971_USB_SUS_SHIFT);
 		}
@@ -981,6 +1003,58 @@ static DEVICE_ATTR(chgcc_ta, S_IRUGO | S_IWUSR | S_IRGRP | S_IWGRP,
 		   max8971_charger_show_chgcc_ta,
 		   max8971_charger_store_chgcc_ta);
 
+static ssize_t max8971_charger_show_chgcc_forced(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct max8971_chip *chip = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", chip->chgcc_forced);
+}
+
+static ssize_t max8971_charger_store_chgcc_forced(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct max8971_chip *chip = dev_get_drvdata(dev);
+	if (!count) {
+		return -EINVAL;
+	}
+	chip->chgcc_forced = simple_strtoul(buf, NULL, 10);
+	if (chip->chg_enable) {
+		max8971_set_reg(chip, 1);
+	}
+	return count;
+}
+
+DEVICE_ATTR(chgcc_forced, 0660, max8971_charger_show_chgcc_forced,
+		max8971_charger_store_chgcc_forced);
+
+static ssize_t max8971_charger_show_dcilmt_forced(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct max8971_chip *chip = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", chip->dcilmt_forced);
+}
+
+static ssize_t max8971_charger_store_dcilmt_forced(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct max8971_chip *chip = dev_get_drvdata(dev);
+	if (!count) {
+		return -EINVAL;
+	}
+	int val = simple_strtoul(buf, NULL, 10);
+	if (val < 9 || val > 63) {
+		return -EINVAL;
+	}
+	chip->dcilmt_forced = val;
+	if (chip->chg_enable) {
+		max8971_set_reg(chip, 1);
+	}
+	return count;
+}
+
+DEVICE_ATTR(dcilmt_forced, 0660, max8971_charger_show_dcilmt_forced,
+		max8971_charger_store_dcilmt_forced);
+
 
 static __devinit int max8971_probe(struct i2c_client *client, 
 				   const struct i2c_device_id *id)
@@ -1075,15 +1149,37 @@ static __devinit int max8971_probe(struct i2c_client *client,
 	}
 */
 
- 	ret = device_create_file(&client->dev, &dev_attr_chgcc_ta);
-        if (ret < 0) {
-                printk("device_create_file error!\n");
-                return ret;
+	chip->chgcc_forced = 0;
+	chip->dcilmt_forced = 60;
+
+	ret = device_create_file(&client->dev, &dev_attr_chgcc_ta);
+	if (ret < 0) {
+		printk("device_create_file(chgcc_ta) error!\n");
+		goto err;
 	}
+
+	ret = device_create_file(&client->dev, &dev_attr_chgcc_forced);
+	if (ret < 0) {
+		printk("device_create_file(chgcc_forced) error!\n");
+		goto err_chgcc_forced;
+	}
+
+	ret = device_create_file(&client->dev, &dev_attr_dcilmt_forced);
+	if (ret < 0) {
+		printk("device_create_file(dcilmt_forced) error!\n");
+		goto err_dcilmt_forced;
+	}
+
 	dev_info(&client->dev, "%s finish...\n", __func__);
 
 	return 0;
 
+err_dcilmt_forced:
+	device_remove_file(&client->dev, &dev_attr_chgcc_forced);
+
+err_chgcc_forced:
+	device_remove_file(&client->dev, &dev_attr_chgcc_ta);
+
 err:
 	free_irq(client->irq, chip);
 
@@ -1108,6 +1204,10 @@ static __devexit int max8971_remove(struct i2c_client *client)
 	//kkk_test
 	//cancel_delayed_work(&chip->monitor_work);
 
+	device_remove_file(&client->dev, &dev_attr_dcilmt_forced);
+	device_remove_file(&client->dev, &dev_attr_chgcc_forced);
+	device_remove_file(&client->dev, &dev_attr_chgcc_ta);
+
 	gpio_free(TEGRA_GPIO_PJ2);
 	free_irq(client->irq, chip);
 	power_supply_unregister(&chip->charger);
@@ -1186,7 +1286,8 @@ module_exit(max8971_exit);
 
 
 MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Clark Kim <clark.kim@maxim-ic.com>");
+MODULE_AUTHOR("Clark Kim <clark.kim@maxim-ic.com>"
+		", Michael Zhou <mzhou@cse.unsw.edu.au>");
 MODULE_DESCRIPTION("Power supply driver for MAX8971");
 MODULE_VERSION("3.3");
 MODULE_ALIAS("platform:max8971-charger");
diff --git a/drivers/video/backlight/lm3533_bl.c b/drivers/video/backlight/lm3533_bl.c
index f0ee1d9..7170cce 100644
--- a/drivers/video/backlight/lm3533_bl.c
+++ b/drivers/video/backlight/lm3533_bl.c
@@ -46,6 +46,10 @@
 #define LEDS_BACKLIGHT_NAME 		"lcd-backlight"
 #endif
 
+#define LM3533_BL_MAX_MAXCURRENT	19 // Can be up to 23
+#define LM3533_BL_DEFAULT_MAXCURRENT	19
+#define LM3533_BL_MIN_MAXCURRENT	0
+
 static unsigned char default_160nit_53percent_lut[256]={
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,
 1,1,1,1,1,1,2,2,2,2,2,2,2,3,3,3,3,3,3,4,
@@ -78,6 +82,7 @@ struct lm3533_device {
 	int			bl_status;
 	struct mutex 		bl_mutex;
 	struct mutex 		bl_mutex_saved;
+	int			cur_maxcurrent;
 };
 
 struct lm3533_device *lm3533dev;
@@ -174,10 +179,12 @@ static void lm3533_set_main_current_level(struct i2c_client *client, int level)
 			cal_value = LM3533_BL_MIN_BRIGHTNESS;
 		}
 #endif
+		lm3533_bl_write_reg(client, 0x1F, dev->cur_maxcurrent);
 		lm3533_bl_write_reg(client, 0x40, cal_value);
 	}
 	else if(level == 0){
 		cal_value = level;
+		lm3533_bl_write_reg(client, 0x1F, dev->cur_maxcurrent);
 		lm3533_bl_write_reg(client, 0x40, cal_value);
 	}
 	mutex_unlock(&lm3533dev->bl_mutex);
@@ -200,7 +207,6 @@ static void lm3533_backlight_on(struct i2c_client *client, int level)
 	lm3533_bl_write_reg(client, 0x14, 0x0); //PWM input is disabled for CABC
 #endif
 	lm3533_bl_write_reg(client, 0x1A, 0x2); //Linear & Control Bank A is configured for register Current control
-	lm3533_bl_write_reg(client, 0x1F, 0x13); //Full-Scale Current (20.2mA)
 	lm3533_bl_write_reg(client, 0x27, 0x1); //Control Bank A is enable
 #if !defined(CONFIG_MACH_HD5_LGD)        
 	lm3533_bl_write_reg(client, 0x2C, 0x0A); //                                                                                   
@@ -411,6 +417,59 @@ static ssize_t lm3533_bl_store_on_off(struct device *dev,
 DEVICE_ATTR(lm3533_bl_level, 0660, lm3533_bl_show_lvl, lm3533_bl_store_lvl);
 DEVICE_ATTR(lm3533_bl_onoff, 0660, lm3533_bl_show_on_off, lm3533_bl_store_on_off);
 
+static void lm3533_lcd_backlight_set_maxcurrent(struct i2c_client *client,
+		int level)
+{
+	struct lm3533_device *dev = i2c_get_clientdata(client);
+
+	if (level > LM3533_BL_MAX_MAXCURRENT)
+		level = LM3533_BL_MAX_MAXCURRENT;
+	if (level < LM3533_BL_MIN_MAXCURRENT)
+		level = LM3533_BL_MIN_MAXCURRENT;
+
+	dev->cur_maxcurrent = level;
+	lm3533_set_main_current_level(client, dev->saved_main_lcd_level);
+}
+
+static ssize_t lm3533_bl_show_maxcurrent(struct device *dev,
+		struct device_attribute *attr,
+		char *buf)
+{
+	int r;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lm3533_device *lm3533_dev = i2c_get_clientdata(client);
+
+	r = snprintf(buf, PAGE_SIZE,
+			"%d\n",
+			lm3533_dev->cur_maxcurrent);
+
+	return r;
+}
+
+static ssize_t lm3533_bl_store_maxcurrent(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf,
+		size_t count)
+{
+	int level;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (!count) {
+		dev_err(&client->dev,
+				"Invalid argument while storing maxcurrent\n");
+		return -EINVAL;
+	}
+
+	level = simple_strtoul(buf, NULL, 10);
+
+	lm3533_lcd_backlight_set_maxcurrent(client, level);
+
+	return count;
+}
+
+DEVICE_ATTR(lm3533_bl_maxcurrent, 0660, lm3533_bl_show_maxcurrent,
+		lm3533_bl_store_maxcurrent);
+
 #ifdef CONFIG_LM3533_LEDS_CLASS
 
 static int lm3533_bl_get_intensity(struct lm3533_device *drvdata)
@@ -502,6 +561,7 @@ static int __devinit lm3533_bl_probe(struct i2c_client *i2c_dev,
 	dev->cur_main_lcd_level= LM3533_BL_DEFAULT_BRIGHTNESS;
 	dev->saved_main_lcd_level= LM3533_BL_DEFAULT_BRIGHTNESS;
 	dev->bl_status = BL_OFF;
+	dev->cur_maxcurrent = LM3533_BL_DEFAULT_MAXCURRENT;
 
 	err = led_classdev_register(&i2c_dev->dev, &lm3533_led_dev);
 	if (err < 0) {
@@ -538,6 +598,11 @@ static int __devinit lm3533_bl_probe(struct i2c_client *i2c_dev,
 		dev_err(&i2c_dev->dev, "device_create_file(onoff) failed\n");
 		goto err_device_create_file_2;
 	}
+	err = device_create_file(&i2c_dev->dev, &dev_attr_lm3533_bl_maxcurrent);
+	if (err < 0) {
+		dev_err(&i2c_dev->dev, "device_create_file(maxcurrent) failed\n");
+		goto err_device_create_file_3;
+	}
 
 	lm3533dev = dev;
 
@@ -547,6 +612,8 @@ static int __devinit lm3533_bl_probe(struct i2c_client *i2c_dev,
 
 	return 0;
 
+err_device_create_file_3:
+	device_remove_file(&i2c_dev->dev, &dev_attr_lm3533_bl_onoff);
 err_device_create_file_2:
 	device_remove_file(&i2c_dev->dev, &dev_attr_lm3533_bl_level);
 err_device_create_file_1:
@@ -570,6 +637,7 @@ static int __devexit lm3533_bl_remove(struct i2c_client *i2c_dev)
 
  	device_remove_file(&i2c_dev->dev, &dev_attr_lm3533_bl_level);
 	device_remove_file(&i2c_dev->dev, &dev_attr_lm3533_bl_onoff);
+	device_remove_file(&i2c_dev->dev, &dev_attr_lm3533_bl_maxcurrent);
 
 	led_classdev_unregister(dev->led);
 
@@ -614,5 +682,6 @@ module_init(lm3533_init);
 module_exit(lm3533_exit);
 
 MODULE_DESCRIPTION("LM3533 Backlight Control");
-MODULE_AUTHOR("Jaeseong Gim <jaeseong.gim@lge.com>");
+MODULE_AUTHOR("Jaeseong Gim <jaeseong.gim@lge.com>"
+		", Michael Zhou <mzhou@cse.unsw.edu.au>");
 MODULE_LICENSE("GPL");
diff --git a/include/linux/input/lge_touch_core.h b/include/linux/input/lge_touch_core.h
index cbda30a..910e71af 100644
--- a/include/linux/input/lge_touch_core.h
+++ b/include/linux/input/lge_touch_core.h
@@ -350,9 +350,9 @@ enum{
 #define LGE_TOUCH_NAME		"lge_touch"
 
 /* Debug Mask setting */
-#define TOUCH_DEBUG_PRINT   (0)
-#define TOUCH_ERROR_PRINT   (1)
-#define TOUCH_INFO_PRINT   	(0)
+//#define TOUCH_DEBUG_PRINT
+#define TOUCH_ERROR_PRINT
+//#define TOUCH_INFO_PRINT
 
 #if defined(TOUCH_INFO_PRINT)
 #define TOUCH_INFO_MSG(fmt, args...) \
diff --git a/include/media/lm3559.h b/include/media/lm3559.h
index 7e8daf2..6501357 100644
--- a/include/media/lm3559.h
+++ b/include/media/lm3559.h
@@ -6,22 +6,22 @@
 //#define LM3559_MAX_TORCH_LEVEL	11
 //#define LM3559_MAX_FLASH_LEVEL	20
 
-#define LM3559_FLASH_LEVEL		        0
-#define LM3559_TORCH_LEVEL		        1
+#define LM3559_FLASH_LEVEL		0
+#define LM3559_TORCH_LEVEL		1
 
-#define LM3559_POWER_OFF				      1
-#define LM3559_POWER_STANDBY					2
-#define LM3559_POWER_ON					      3
+#define LM3559_POWER_OFF		1
+#define LM3559_POWER_STANDBY		2
+#define LM3559_POWER_ON			3
 
 struct lm3559_param {
 	int param;
-  int value;
+	int value;
 	//__s32 sizeofvalue;
 	//void *p_value;
 };
 
-#define LM3559_IOCTL_P0WER_CONT   _IOW('o', 13, int)
-#define LM3559_IOCTL_FLASH_TORCH  _IOW('o', 14, struct lm3559_param)
+#define LM3559_IOCTL_P0WER_CONT		_IOW('o', 13, int)
+#define LM3559_IOCTL_FLASH_TORCH	_IOW('o', 14, struct lm3559_param)
 
 struct lm3559_platform_data {
 	//unsigned cfg; /* use the NVC_CFG_ defines */
