diff --git a/Android.mk b/Android.mk
index d1e7d90..866f730 100644
--- a/Android.mk
+++ b/Android.mk
@@ -55,6 +55,7 @@ LOCAL_SRC_FILES := $(filter-out \
 ## across process boundaries.
 ##
 ## READ ME: ########################################################
+# BEGIN privacy-added: IPrivacySettingsManager.aidl
 LOCAL_SRC_FILES += \
 	core/java/android/accessibilityservice/IAccessibilityServiceConnection.aidl \
 	core/java/android/accessibilityservice/IAccessibilityServiceClient.aidl \
@@ -216,6 +217,7 @@ LOCAL_SRC_FILES += \
 	media/java/android/media/IRemoteControlDisplay.aidl \
 	media/java/android/media/IRemoteVolumeObserver.aidl \
 	media/java/android/media/IRingtonePlayer.aidl \
+	privacy/java/android/privacy/IPrivacySettingsManager.aidl \
 	telephony/java/com/android/internal/telephony/IPhoneStateListener.aidl \
 	telephony/java/com/android/internal/telephony/IPhoneSubInfo.aidl \
 	telephony/java/com/android/internal/telephony/ITelephony.aidl \
@@ -241,6 +243,7 @@ LOCAL_SRC_FILES += \
 	fmradio/java/com/stericsson/hardware/fm/IOnExtraCommandListener.aidl \
 	fmradio/java/com/stericsson/hardware/fm/IOnAutomaticSwitchListener.aidl
 #
+# END privacy-added: IPrivacySettingsManager.aidl
 
 
 # FRAMEWORKS_BASE_JAVA_SRC_DIRS comes from build/core/pathmap.mk
@@ -280,6 +283,7 @@ framework_built := $(call java-lib-deps,framework)
 # AIDL files to be preprocessed and included in the SDK,
 # relative to the root of the build tree.
 # ============================================================
+# BEGIN privacy-added: PrivacySettings.aidl
 aidl_files := \
 	frameworks/base/core/java/android/accounts/IAccountManager.aidl \
 	frameworks/base/core/java/android/accounts/IAccountManagerResponse.aidl \
@@ -331,11 +335,14 @@ aidl_files := \
 	frameworks/base/location/java/android/location/LocationRequest.aidl \
 	frameworks/base/location/java/com/android/internal/location/ProviderProperties.aidl \
 	frameworks/base/location/java/com/android/internal/location/ProviderRequest.aidl \
+	frameworks/base/privacy/java/android/privacy/PrivacySettings.aidl \
 	frameworks/base/telephony/java/android/telephony/ServiceState.aidl \
 	frameworks/base/telephony/java/com/android/internal/telephony/IPhoneSubInfo.aidl \
 	frameworks/base/telephony/java/com/android/internal/telephony/ITelephony.aidl \
 
 gen := $(TARGET_OUT_COMMON_INTERMEDIATES)/framework.aidl
+# END privacy-added: PrivacySettings.aidl
+
 $(gen): PRIVATE_SRC_FILES := $(aidl_files)
 ALL_SDK_FILES += $(gen)
 $(gen): $(aidl_files) | $(AIDL)
diff --git a/api/current.txt b/api/current.txt
index 0ff0fbc..1d90e07 100644
--- a/api/current.txt
+++ b/api/current.txt
@@ -20692,6 +20692,7 @@ package android.telephony {
   public final class CellInfoGsm extends android.telephony.CellInfo implements android.os.Parcelable {
     method public android.telephony.CellIdentityGsm getCellIdentity();
     method public android.telephony.CellSignalStrengthGsm getCellSignalStrength();
+    method public void setCellIdentity(android.telephony.CellIdentityGsm);
     method public void writeToParcel(android.os.Parcel, int);
     field public static final android.os.Parcelable.Creator CREATOR;
   }
diff --git a/core/java/android/app/Activity.java b/core/java/android/app/Activity.java
index e779746..94e9b42 100644
--- a/core/java/android/app/Activity.java
+++ b/core/java/android/app/Activity.java
@@ -55,13 +55,17 @@ import android.text.TextUtils;
 import android.text.method.TextKeyListener;
 import android.util.AttributeSet;
 import android.util.EventLog;
+import android.util.DisplayMetrics;
 import android.util.Log;
+import android.util.TypedValue;
 import android.util.Slog;
 import android.util.SparseArray;
 import android.view.ActionMode;
 import android.view.ContextMenu;
 import android.view.ContextMenu.ContextMenuInfo;
 import android.view.ContextThemeWrapper;
+import android.view.Display;
+import android.view.Gravity;
 import android.view.KeyEvent;
 import android.view.LayoutInflater;
 import android.view.Menu;
@@ -1459,6 +1463,9 @@ public class Activity extends ContextThemeWrapper
         if (mWindow != null) {
             // Pass the configuration changed event to the window
             mWindow.onConfigurationChanged(newConfig);
+            if (mWindow.mIsFloatingWindow) {
+                scaleFloatingWindow(null);
+            }
         }
 
         if (mActionBar != null) {
@@ -5056,11 +5063,47 @@ public class Activity extends ContextThemeWrapper
             CharSequence title, Activity parent, String id,
             NonConfigurationInstances lastNonConfigurationInstances,
             Configuration config) {
+
         attachBaseContext(context);
 
         mFragments.attachActivity(this, mContainer, null);
-        
-        mWindow = PolicyManager.makeNewWindow(this);
+
+        boolean floating = (intent.getFlags()&Intent.FLAG_FLOATING_WINDOW) == Intent.FLAG_FLOATING_WINDOW;
+        if (intent != null && floating) {
+            TypedArray styleArray = context.obtainStyledAttributes(info.theme, com.android.internal.R.styleable.Window);
+            TypedValue backgroundValue = styleArray.peekValue(com.android.internal.R.styleable.Window_windowBackground);
+
+            // Apps that have no title don't need no title bar
+            TypedValue outValue = new TypedValue();
+            boolean result = styleArray.getValue(com.android.internal.R.styleable.Window_windowNoTitle, outValue);
+
+            if (backgroundValue != null && backgroundValue.toString().contains("light")) {
+                context.getTheme().applyStyle(com.android.internal.R.style.Theme_DeviceDefault_FloatingWindowLight, true);
+            } else {
+                context.getTheme().applyStyle(com.android.internal.R.style.Theme_DeviceDefault_FloatingWindow, true);
+            }
+
+            parent = null;
+
+            // Create our new window
+            mWindow = PolicyManager.makeNewWindow(this);
+            mWindow.mIsFloatingWindow = true;
+            mWindow.setCloseOnTouchOutsideIfNotSet(true);
+            mWindow.setGravity(Gravity.CENTER);
+
+            mWindow.setFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND,
+                    WindowManager.LayoutParams.FLAG_DIM_BEHIND);
+            WindowManager.LayoutParams params = mWindow.getAttributes(); 
+            params.alpha = 1f;
+            params.dimAmount = 0.25f;
+            mWindow.setAttributes((android.view.WindowManager.LayoutParams) params);
+
+            // Scale it
+            scaleFloatingWindow(context);
+        } else {
+            mWindow = PolicyManager.makeNewWindow(this);
+        }
+
         mWindow.setCallback(this);
         mWindow.getLayoutInflater().setPrivateFactory(this);
         if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) {
@@ -5095,6 +5138,26 @@ public class Activity extends ContextThemeWrapper
         mCurrentConfig = config;
     }
 
+    private void scaleFloatingWindow(Context context) {
+        if (!mWindow.mIsFloatingWindow) {
+            return;
+        }
+        WindowManager wm = null;
+        if (context != null) {
+            wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+        } else {
+            wm = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
+        }
+        Display display = wm.getDefaultDisplay();
+        DisplayMetrics metrics = new DisplayMetrics();
+        display.getMetrics(metrics);
+        if (metrics.heightPixels > metrics.widthPixels) {
+            mWindow.setLayout((int)(metrics.widthPixels * 0.9f), (int)(metrics.heightPixels * 0.7f));
+        } else {
+            mWindow.setLayout((int)(metrics.widthPixels * 0.7f), (int)(metrics.heightPixels * 0.8f));
+        }
+    }
+
     /** @hide */
     public final IBinder getActivityToken() {
         return mParent != null ? mParent.getActivityToken() : mToken;
@@ -5218,7 +5281,7 @@ public class Activity extends ContextThemeWrapper
         onUserInteraction();
         onUserLeaveHint();
     }
-    
+
     final void performStop() {
         if (mLoadersStarted) {
             mLoadersStarted = false;
@@ -5264,6 +5327,14 @@ public class Activity extends ContextThemeWrapper
             mStopped = true;
         }
         mResumed = false;
+
+        // Floatingwindows activities should be kept volatile to prevent new activities taking
+        // up front in a minimized space. Every stop call, for instance when pressing home,
+        // will terminate the activity. If the activity is already finishing we might just
+        // as well let it go.
+        if (!mChangingConfigurations && mWindow != null && mWindow.mIsFloatingWindow && !isFinishing()) {
+            finish();
+        }
     }
 
     final void performDestroy() {
diff --git a/core/java/android/app/ActivityThread.java b/core/java/android/app/ActivityThread.java
index 6250262..a03e301 100644
--- a/core/java/android/app/ActivityThread.java
+++ b/core/java/android/app/ActivityThread.java
@@ -2866,12 +2866,7 @@ public final class ActivityThread {
                 r.stopped = false;
                 r.state = null;
             } catch (Exception e) {
-                if (!mInstrumentation.onException(r.activity, e)) {
-                    throw new RuntimeException(
-                        "Unable to resume activity "
-                        + r.intent.getComponent().toShortString()
-                        + ": " + e.toString(), e);
-                }
+                // Unable to resume activity
             }
         }
         return r;
diff --git a/core/java/android/app/ContextImpl.java b/core/java/android/app/ContextImpl.java
index 4d9f11e..65ad294 100644
--- a/core/java/android/app/ContextImpl.java
+++ b/core/java/android/app/ContextImpl.java
@@ -65,7 +65,7 @@ import android.location.ILocationManager;
 import android.location.LocationManager;
 import android.media.AudioManager;
 import android.media.MediaRouter;
-import android.net.ConnectivityManager;
+//import android.net.ConnectivityManager;
 import android.net.IConnectivityManager;
 import android.net.INetworkPolicyManager;
 import android.net.NetworkPolicyManager;
@@ -117,6 +117,16 @@ import android.accounts.IAccountManager;
 import android.app.admin.DevicePolicyManager;
 import com.android.internal.os.IDropBoxManagerService;
 
+// BEGIN privacy-added
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.surrogate.PrivacyAccountManager;
+import android.privacy.surrogate.PrivacyLocationManager;
+import android.privacy.surrogate.PrivacyTelephonyManager;
+import android.privacy.surrogate.PrivacyWifiManager;
+import android.privacy.surrogate.PrivacyConnectivityManager;
+// END privacy-added
+
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
@@ -192,6 +202,9 @@ class ContextImpl extends Context {
     private Resources mResources;
     /*package*/ ActivityThread mMainThread;
     private Context mOuterContext;
+    // BEGIN privacy-added
+    private static Context sOuterContext = null;
+    // END privacy-added
     private IBinder mActivityToken = null;
     private ApplicationContentResolver mContentResolver;
     private int mThemeResource = 0;
@@ -307,7 +320,11 @@ class ContextImpl extends Context {
                 public Object createService(ContextImpl ctx) {
                     IBinder b = ServiceManager.getService(ACCOUNT_SERVICE);
                     IAccountManager service = IAccountManager.Stub.asInterface(b);
-                    return new AccountManager(ctx, service);
+                    // BEGIN privacy-modified
+                    Log.d(TAG, "PDroid:ContextImpl: returning PrivacyAccountManager rather than AccountManager");
+                    //return new AccountManager(ctx, service);
+                    return new PrivacyAccountManager(ctx, service);
+                    // END privacy-modified
                 }});
 
         registerService(ACTIVITY_SERVICE, new ServiceFetcher() {
@@ -346,7 +363,14 @@ class ContextImpl extends Context {
         registerService(CONNECTIVITY_SERVICE, new StaticServiceFetcher() {
                 public Object createStaticService() {
                     IBinder b = ServiceManager.getService(CONNECTIVITY_SERVICE);
-                    return new ConnectivityManager(IConnectivityManager.Stub.asInterface(b));
+                    // BEGIN privacy-modified
+                    // SM: Having a 'static outer context' may be problematic if
+                    //      there is more than one instance of this class, ever.
+                    Log.d(TAG, "PDroid:ContextImpl: returning PrivacyConnectivityManager");
+                    //return new ConnectivityManager(IConnectivityManager.Stub.asInterface(b));
+                    IConnectivityManager service = IConnectivityManager.Stub.asInterface(b);
+                    return new PrivacyConnectivityManager(service, getStaticOuterContext());
+                    // END privacy-modified
                 }});
 
         registerService(COUNTRY_DETECTOR, new StaticServiceFetcher() {
@@ -412,8 +436,16 @@ class ContextImpl extends Context {
 
         registerService(LOCATION_SERVICE, new ServiceFetcher() {
                 public Object createService(ContextImpl ctx) {
-                    IBinder b = ServiceManager.getService(LOCATION_SERVICE);
-                    return new LocationManager(ctx, ILocationManager.Stub.asInterface(b));
+    	            IBinder b = ServiceManager.getService(LOCATION_SERVICE);
+    
+    	            // BEGIN privacy-modified
+    	            //return new LocationManager(ctx, ILocationManager.Stub.asInterface(b));
+    	            Log.d(TAG, "PDroid:ContextImpl: returning PrivacyLocationManager");
+    	            // SM: I'm not sure whyt this is using getStaticOuterContext rather than getOuterContext.
+    	            // Would have thought it should have been the following line:
+    	            // return new PrivacyLocationManager(ILocationManager.Stub.asInterface(b), ctx.getOuterContext());
+    	            return new PrivacyLocationManager(ILocationManager.Stub.asInterface(b), getStaticOuterContext());
+    	            // END privacy-modified                    
                 }});
 
         registerService(NETWORK_POLICY_SERVICE, new ServiceFetcher() {
@@ -484,7 +516,11 @@ class ContextImpl extends Context {
 
         registerService(TELEPHONY_SERVICE, new ServiceFetcher() {
                 public Object createService(ContextImpl ctx) {
-                    return new TelephonyManager(ctx.getOuterContext());
+                    // BEGIN privacy-modified
+                    //return new TelephonyManager(ctx.getOuterContext());
+                    Log.d(TAG, "PDroid:ContextImpl: returning PrivacyTelephonyManager");
+                    return new PrivacyTelephonyManager(ctx.getOuterContext());
+                    // END privacy-modified
                 }});
 
         registerService(THROTTLE_SERVICE, new StaticServiceFetcher() {
@@ -521,7 +557,11 @@ class ContextImpl extends Context {
                 public Object createService(ContextImpl ctx) {
                     IBinder b = ServiceManager.getService(WIFI_SERVICE);
                     IWifiManager service = IWifiManager.Stub.asInterface(b);
-                    return new WifiManager(ctx.getOuterContext(), service);
+                    // BEGIN privacy-modified
+                    //return new WifiManager(ctx.getOuterContext(), service);
+                    Log.d(TAG, "PDroid:ContextImpl: returning PrivacyWifiManager");
+                    return new PrivacyWifiManager(ctx.getOuterContext(), service);
+                    // END privacy-modified
                 }});
 
         registerService(WIFI_P2P_SERVICE, new ServiceFetcher() {
@@ -531,6 +571,16 @@ class ContextImpl extends Context {
                     return new WifiP2pManager(service);
                 }});
 
+        // BEGIN privacy-added
+        registerService("privacy", new StaticServiceFetcher() {
+                public Object createStaticService() {
+                    Log.d(TAG, "PDroid:ContextImpl: Creating static privacy service");
+                    IBinder b = ServiceManager.getService("privacy");
+                    IPrivacySettingsManager service = IPrivacySettingsManager.Stub.asInterface(b);
+                    return new PrivacySettingsManager(getStaticOuterContext(), service);
+                }});
+        // END privacy-added
+
         registerService(WINDOW_SERVICE, new ServiceFetcher() {
                 public Object getService(ContextImpl ctx) {
                     Display display = ctx.mDisplay;
@@ -1886,7 +1936,10 @@ class ContextImpl extends Context {
     }
 
     ContextImpl() {
-        mOuterContext = this;
+        if (sOuterContext != null) {
+            Log.w(TAG, "PDroid:ContextImpl: ContextImpl being created but already has sOuterContext");
+        }
+        sOuterContext = mOuterContext = this;
     }
 
     /**
@@ -1903,7 +1956,12 @@ class ContextImpl extends Context {
         mContentResolver = context.mContentResolver;
         mUser = context.mUser;
         mDisplay = context.mDisplay;
-        mOuterContext = this;
+        
+        if (sOuterContext != null) {
+            Log.w(TAG, "PDroid:ContextImpl: ContextImpl being created but already has sOuterContext");
+        }
+        
+        sOuterContext = mOuterContext = this;
     }
 
     final void init(LoadedApk packageInfo, IBinder activityToken, ActivityThread mainThread) {
@@ -1959,13 +2017,21 @@ class ContextImpl extends Context {
     }
 
     final void setOuterContext(Context context) {
-        mOuterContext = context;
+        if (sOuterContext != null) {
+            Log.w(TAG, "PDroid:ContextImpl: ContextImpl being created but already has sOuterContext");
+        }
+
+        sOuterContext = mOuterContext = context;
     }
 
     final Context getOuterContext() {
         return mOuterContext;
     }
 
+    final static Context getStaticOuterContext() {
+        return sOuterContext;
+    }
+
     final IBinder getActivityToken() {
         return mActivityToken;
     }
diff --git a/core/java/android/app/INotificationManager.aidl b/core/java/android/app/INotificationManager.aidl
index 62d4962..b94d93a 100644
--- a/core/java/android/app/INotificationManager.aidl
+++ b/core/java/android/app/INotificationManager.aidl
@@ -34,5 +34,12 @@ interface INotificationManager
 
     void setNotificationsEnabledForPackage(String pkg, boolean enabled);
     boolean areNotificationsEnabledForPackage(String pkg);
+
+    void setHaloPolicyBlack(boolean state);
+    void setHaloStatus(String pkg, boolean status);
+    void setHaloBlacklistStatus(String pkg, boolean status);
+    void setHaloWhitelistStatus(String pkg, boolean status);
+    boolean isHaloPolicyBlack();
+    boolean isPackageAllowedForHalo(String pkg);
 }
 
diff --git a/core/java/android/app/Instrumentation.java b/core/java/android/app/Instrumentation.java
index e0856ae..432a7bf 100644
--- a/core/java/android/app/Instrumentation.java
+++ b/core/java/android/app/Instrumentation.java
@@ -48,6 +48,13 @@ import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
 
+///////////////////////////////////////////////////
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.TelephonyManager;
+///////////////////////////////////////////////////
+
 
 /**
  * Base class for implementing application instrumentation code.  When running
@@ -88,6 +95,10 @@ public class Instrumentation {
     private boolean mAutomaticPerformanceSnapshots = false;
     private PerformanceCollector mPerformanceCollector;
     private Bundle mPerfMetrics = new Bundle();
+    
+    //---------------------------------------------------------------------------------------------------------------------------------------------------------
+    private PrivacySettingsManager mPrvSvc;
+    //---------------------------------------------------------------------------------------------------------------------------------------------------------
 
     public Instrumentation() {
     }
@@ -1391,6 +1402,79 @@ public class Instrumentation {
             Context who, IBinder contextThread, IBinder token, Activity target,
             Intent intent, int requestCode, Bundle options) {
         IApplicationThread whoThread = (IApplicationThread) contextThread;
+        
+        // BEGIN privacy-added
+        boolean allowIntent = true;
+        try{
+        	Log.d(TAG,"PDroid:Instrumentation:execStartActivity: execStartActivity for " + who.getPackageName());
+            if (intent.getAction() != null && (intent.getAction().equals(Intent.ACTION_CALL) || intent.getAction().equals(Intent.ACTION_DIAL))){
+                allowIntent = false;
+                Log.d(TAG,"PDroid:Instrumentation:execStartActivity: Intent action = Intent.ACTION_CALL or Intent.ACTION_DIAL for " + who.getPackageName());
+        		if (mPrvSvc == null || !mPrvSvc.isServiceAvailable()) {
+        		    mPrvSvc = new PrivacySettingsManager(who, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+        		    if (mPrvSvc != null) {
+        		        Log.d(TAG,"PDroid:Instrumentation:execStartActivity: Obtained privacy service");
+        		    } else {
+        		        Log.d(TAG,"PDroid:Instrumentation:execStartActivity: Privacy service not obtained");
+        		    }
+        		} else {
+        		    Log.d(TAG,"PDroid:Instrumentation:execStartActivity: Already had privacy service");
+        		}
+        		
+        		if (mPrvSvc == null || !mPrvSvc.isServiceAvailable()) {
+        		    Log.d(TAG,"PDroid:Instrumentation:execStartActivity: Privacy service not available: rejecting call attempt");
+        		    allowIntent = false;
+        		    mPrvSvc.notification(who.getPackageName(), PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null);
+        		} else {
+            		PrivacySettings privacySettings = mPrvSvc.getSettings(who.getPackageName());
+            		if (privacySettings == null) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity: Call allowed: No settings for package: " + who.getPackageName());
+                        allowIntent = true;
+                        mPrvSvc.notification(who.getPackageName(), PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null);
+            		} else if (privacySettings.getPhoneCallSetting() == PrivacySettings.REAL) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity: Call allowed: Settings permit " + who.getPackageName());
+                        allowIntent = true;
+                        mPrvSvc.notification(who.getPackageName(), privacySettings.getPhoneCallSetting(), PrivacySettings.DATA_PHONE_CALL, null);
+            		} else {
+            		    Log.d(TAG,"PDroid:Instrumentation:execStartActivity: Call denied: Settings deny " + who.getPackageName());
+            		    // No settings = allowed; any phone call setting but real == disallowed
+            		    
+                		allowIntent = false;
+                		
+                		// test if broadcasting works! SM: I don't know what 'test if broadcasting works' means.
+                		// Send the notification intent
+                		final Context tmp = who;
+                		// SM: the BLOCKED_PHONE_CALL intent is handled by the privacy service to fake a change in call state
+                		new Thread(new Runnable() {
+                		    public void run() {
+                		        // SM: Not clear why there is this delay
+                		    	try{
+                 		    		Thread.sleep(1000); //wait 1 Second
+                 		    	} catch(Exception e){
+                 		    		//nothing here
+                 		    	}  
+                		    	Intent privacy = new Intent("android.privacy.BLOCKED_PHONE_CALL");
+                        		Bundle extras = new Bundle();
+                        		extras.putString("packageName", tmp.getPackageName());
+                        		extras.putInt("phoneState", TelephonyManager.CALL_STATE_IDLE);
+                        		privacy.putExtras(extras);
+                        		tmp.sendBroadcast(privacy);
+                        		Log.i("PrivacyContext","sent privacy intent");
+                		    }
+                		}).start();
+                		mPrvSvc.notification(who.getPackageName(), privacySettings.getPhoneCallSetting(), PrivacySettings.DATA_PHONE_CALL, null);
+            		}
+        		}
+            }
+        } catch(Exception e){
+        	 if(who != null) {
+        	     Log.e(TAG,"PDroid:Instrumentation:execStartActivity: Exception occurred handling intent for " + who.getPackageName(), e);
+        	 } else {
+        	     Log.e(TAG,"PDroid:Instrumentation:execStartActivity: Exception occurred handling intent for unknown package", e);
+        	 }
+        }
+        // END privacy-added
+        
         if (mActivityMonitors != null) {
             synchronized (mSync) {
                 final int N = mActivityMonitors.size();
@@ -1406,6 +1490,16 @@ public class Instrumentation {
                 }
             }
         }
+        
+        // BEGIN privacy-added
+        try{
+        	if (!allowIntent) return new ActivityResult(requestCode, intent);
+        } catch(Exception e) {
+            Log.e(TAG,"PDroid:Instrumentation:execStartActivity: Exception occurred while trying to create ActivityResult", e);
+        	return null;
+        }
+    	// END privacy-added
+        
         try {
             intent.setAllowFds(false);
             intent.migrateExtraStreamToClipData();
@@ -1446,6 +1540,109 @@ public class Instrumentation {
             IBinder token, Activity target, Intent[] intents, Bundle options,
             int userId) {
         IApplicationThread whoThread = (IApplicationThread) contextThread;
+
+        // BEGIN privacy-added
+        
+        Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: execStartActivitiesAsUser for " + who.getPackageName());
+        if (intents != null) {
+            boolean checkPrivacySettings = false;
+
+            // If any intents are Intent.ACTION_CALL or Intent.ACTION_DIAL, need to check permissions
+            for (Intent intent : intents) {
+                try {
+                    if (intent.getAction() != null && (
+                            intent.getAction().equals(Intent.ACTION_CALL) ||
+                            intent.getAction().equals(Intent.ACTION_DIAL))) {
+                        checkPrivacySettings = true;
+                        break;
+                    }
+                } catch (Exception e) {
+                    Log.e(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Exception occurred when checking intents for " + who.getPackageName(), e);
+                    // If an exception occurred, then check the privacy settings as the default action
+                    checkPrivacySettings = true;
+                }
+            }
+
+            if (!checkPrivacySettings) {
+                Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: No provided intents triggered checking for " + who.getPackageName());
+            } else {
+                Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: One or more intents triggered checking for " + who.getPackageName());
+
+                if (mPrvSvc == null || !mPrvSvc.isServiceAvailable()) {
+                    mPrvSvc = new PrivacySettingsManager(who, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+                    if (mPrvSvc != null) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Obtained privacy service");
+                    } else {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Privacy service not obtained");
+                    }
+                } else {
+                    Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Already had privacy service");
+                }
+
+                boolean allowCallIntents = false; 
+                if (mPrvSvc == null || !mPrvSvc.isServiceAvailable()) {
+                    Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Privacy service not available - assuming permission denied");
+                    allowCallIntents = false;
+                    mPrvSvc.notification(who.getPackageName(), PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null);
+                } else {
+                    PrivacySettings privacySettings = mPrvSvc.getSettings(who.getPackageName());
+                    if (privacySettings == null) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Call intents allowed: No settings for package: " + who.getPackageName());
+                        allowCallIntents = true;
+                        mPrvSvc.notification(who.getPackageName(), PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null);
+                    } else if (privacySettings.getPhoneCallSetting() == PrivacySettings.REAL) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Call intents allowed: Settings permit " + who.getPackageName());
+                        allowCallIntents = true;
+                        mPrvSvc.notification(who.getPackageName(), privacySettings.getPhoneCallSetting(), PrivacySettings.DATA_PHONE_CALL, null);
+                    } else {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Call intents denied: Settings deny " + who.getPackageName());
+                        allowCallIntents = false;
+                        mPrvSvc.notification(who.getPackageName(), privacySettings.getPhoneCallSetting(), PrivacySettings.DATA_PHONE_CALL, null);
+                    }
+                }
+
+                // If call intents are not allowed, need to regenerate the
+                // intents list to remove call-related intents
+                if (!allowCallIntents) {
+                    List<Intent> filteredIntents = new ArrayList<Intent>(intents.length);
+                    for (Intent intent : intents) {
+                        try {
+                            if (intent.getAction() == null || !(
+                                    intent.getAction().equals(Intent.ACTION_CALL) ||
+                                    intent.getAction().equals(Intent.ACTION_DIAL))) {
+                                filteredIntents.add(intent);
+                            }
+                        } catch (Exception e) {
+                            Log.e(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Exception occurred when checking intent for " + who.getPackageName(), e);
+                        }
+                    }
+                    intents = filteredIntents.toArray(new Intent [filteredIntents.size()]);
+                    
+                    // Send the notification intent
+                    final Context tmp = who;
+                    // SM: the BLOCKED_PHONE_CALL intent is handled by the privacy service to fake a change in call state
+                    new Thread(new Runnable() {
+                        public void run() {
+                            // SM: Not clear why there is this delay
+                            try{
+                                Thread.sleep(1000); //wait 1 Second
+                            } catch(Exception e){
+                                //nothing here
+                            }  
+                            Intent privacy = new Intent("android.privacy.BLOCKED_PHONE_CALL");
+                            Bundle extras = new Bundle();
+                            extras.putString("packageName", tmp.getPackageName());
+                            extras.putInt("phoneState", TelephonyManager.CALL_STATE_IDLE);
+                            privacy.putExtras(extras);
+                            tmp.sendBroadcast(privacy);
+                            Log.i("PrivacyContext","sent privacy intent");
+                        }
+                    }).start();
+                }
+            }
+        }
+        // END privacy-added
+        
         if (mActivityMonitors != null) {
             synchronized (mSync) {
                 final int N = mActivityMonitors.size();
@@ -1506,6 +1703,77 @@ public class Instrumentation {
         Context who, IBinder contextThread, IBinder token, Fragment target,
         Intent intent, int requestCode, Bundle options) {
         IApplicationThread whoThread = (IApplicationThread) contextThread;
+        // BEGIN privacy-added
+        boolean allowIntent = true;
+        try{
+            Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): execStartActivity for " + who.getPackageName());
+            if (intent.getAction() != null && (intent.getAction().equals(Intent.ACTION_CALL) || intent.getAction().equals(Intent.ACTION_DIAL))){
+                allowIntent = false;
+                Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Intent action = Intent.ACTION_CALL or Intent.ACTION_DIAL for " + who.getPackageName());
+                if (mPrvSvc == null || !mPrvSvc.isServiceAvailable()) {
+                    mPrvSvc = new PrivacySettingsManager(who, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+                    if (mPrvSvc != null) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Obtained privacy service");
+                    } else {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Privacy service not obtained");
+                    }
+                } else {
+                    Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Already had privacy service");
+                }
+                
+                if (mPrvSvc == null || !mPrvSvc.isServiceAvailable()) {
+                    Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Privacy service not available: rejecting call attempt");
+                    allowIntent = false;
+                    mPrvSvc.notification(who.getPackageName(), PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null);
+                } else {
+                    PrivacySettings privacySettings = mPrvSvc.getSettings(who.getPackageName());
+                    if (privacySettings == null) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Call allowed: No settings for package: " + who.getPackageName());
+                        allowIntent = true;
+                        mPrvSvc.notification(who.getPackageName(), PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null);
+                    } else if (privacySettings.getPhoneCallSetting() == PrivacySettings.REAL) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Call allowed: Settings permit " + who.getPackageName());
+                        allowIntent = true;
+                        mPrvSvc.notification(who.getPackageName(), privacySettings.getPhoneCallSetting(), PrivacySettings.DATA_PHONE_CALL, null);
+                    } else {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Call denied: Settings deny " + who.getPackageName());
+                        // No settings = allowed; any phone call setting but real == disallowed
+                        
+                        // test if broadcasting works! SM: I don't know what 'test if broadcasting works' means.
+                        // Send the notification intent
+                        final Context tmp = who;
+                        allowIntent = false;
+                        // SM: Why is all of this done? It seems like a weirdly unnecessary bit of code...
+                        new Thread(new Runnable() {
+                            public void run() {
+                                // SM: Not clear why there is this delay
+                                try{
+                                    Thread.sleep(1000); //wait 1 Second
+                                } catch(Exception e){
+                                    //nothing here
+                                }  
+                                Intent privacy = new Intent("android.privacy.BLOCKED_PHONE_CALL");
+                                Bundle extras = new Bundle();
+                                extras.putString("packageName", tmp.getPackageName());
+                                extras.putInt("phoneState", TelephonyManager.CALL_STATE_IDLE);
+                                privacy.putExtras(extras);
+                                tmp.sendBroadcast(privacy);
+                                Log.i("PrivacyContext","sent privacy intent");
+                            }
+                        }).start();
+                        mPrvSvc.notification(who.getPackageName(), privacySettings.getPhoneCallSetting(), PrivacySettings.DATA_PHONE_CALL, null);
+                    }
+                }
+            }
+        } catch(Exception e){
+             if(who != null) {
+                 Log.e(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Exception occurred handling intent for " + who.getPackageName(), e);
+             } else {
+                 Log.e(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Exception occurred handling intent for unknown package", e);
+             }
+        }
+        // END privacy-added
+        
         if (mActivityMonitors != null) {
             synchronized (mSync) {
                 final int N = mActivityMonitors.size();
@@ -1521,6 +1789,16 @@ public class Instrumentation {
                 }
             }
         }
+        
+        // BEGIN privacy-added
+        try{
+            if (!allowIntent) return new ActivityResult(requestCode, intent);
+        } catch(Exception e) {
+            Log.e(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Exception occurred while trying to create ActivityResult", e);
+            return null;
+        }
+        // END privacy-added
+        
         try {
             intent.setAllowFds(false);
             intent.migrateExtraStreamToClipData();
@@ -1566,6 +1844,78 @@ public class Instrumentation {
             Context who, IBinder contextThread, IBinder token, Activity target,
             Intent intent, int requestCode, Bundle options, UserHandle user) {
         IApplicationThread whoThread = (IApplicationThread) contextThread;
+        
+        // BEGIN privacy-added
+        boolean allowIntent = true;
+        try{
+            Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): execStartActivity for " + who.getPackageName());
+            if (intent.getAction() != null && (intent.getAction().equals(Intent.ACTION_CALL) || intent.getAction().equals(Intent.ACTION_DIAL))){
+                allowIntent = false;
+                Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Intent action = Intent.ACTION_CALL or Intent.ACTION_DIAL for " + who.getPackageName());
+                if (mPrvSvc == null || !mPrvSvc.isServiceAvailable()) {
+                    mPrvSvc = new PrivacySettingsManager(who, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+                    if (mPrvSvc != null) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Obtained privacy service");
+                    } else {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Privacy service not obtained");
+                    }
+                } else {
+                    Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Already had privacy service");
+                }
+                
+                if (mPrvSvc == null || !mPrvSvc.isServiceAvailable()) {
+                    Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Privacy service not available: rejecting call attempt");
+                    allowIntent = false;
+                    mPrvSvc.notification(who.getPackageName(), PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null);
+                } else {
+                    PrivacySettings privacySettings = mPrvSvc.getSettings(who.getPackageName());
+                    if (privacySettings == null) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Call allowed: No settings for package: " + who.getPackageName());
+                        allowIntent = true;
+                        mPrvSvc.notification(who.getPackageName(), PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null);
+                    } else if (privacySettings.getPhoneCallSetting() == PrivacySettings.REAL) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Call allowed: Settings permit " + who.getPackageName());
+                        allowIntent = true;
+                        mPrvSvc.notification(who.getPackageName(), privacySettings.getPhoneCallSetting(), PrivacySettings.DATA_PHONE_CALL, null);
+                    } else {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Call denied: Settings deny " + who.getPackageName());
+                        // No settings = allowed; any phone call setting but real == disallowed
+                        
+                        // test if broadcasting works! SM: I don't know what 'test if broadcasting works' means.
+                        // Send the notification intent
+                        final Context tmp = who;
+                        allowIntent = false;
+                        // SM: Why is all of this done? It seems like a weirdly unnecessary bit of code...
+                        new Thread(new Runnable() {
+                            public void run() {
+                                // SM: Not clear why there is this delay
+                                try{
+                                    Thread.sleep(1000); //wait 1 Second
+                                } catch(Exception e){
+                                    //nothing here
+                                }  
+                                Intent privacy = new Intent("android.privacy.BLOCKED_PHONE_CALL");
+                                Bundle extras = new Bundle();
+                                extras.putString("packageName", tmp.getPackageName());
+                                extras.putInt("phoneState", TelephonyManager.CALL_STATE_IDLE);
+                                privacy.putExtras(extras);
+                                tmp.sendBroadcast(privacy);
+                                Log.i("PrivacyContext","sent privacy intent");
+                            }
+                        }).start();
+                        mPrvSvc.notification(who.getPackageName(), privacySettings.getPhoneCallSetting(), PrivacySettings.DATA_PHONE_CALL, null);
+                    }
+                }
+            }
+        } catch(Exception e){
+             if(who != null) {
+                 Log.e(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Exception occurred handling intent for " + who.getPackageName(), e);
+             } else {
+                 Log.e(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Exception occurred handling intent for unknown package", e);
+             }
+        }
+        // END privacy-added
+        
         if (mActivityMonitors != null) {
             synchronized (mSync) {
                 final int N = mActivityMonitors.size();
@@ -1581,6 +1931,16 @@ public class Instrumentation {
                 }
             }
         }
+        
+        // BEGIN privacy-added
+        try{
+            if (!allowIntent) return new ActivityResult(requestCode, intent);
+        } catch(Exception e) {
+            Log.e(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Exception occurred while trying to create ActivityResult", e);
+            return null;
+        }
+        // END privacy-added
+        
         try {
             intent.setAllowFds(false);
             intent.migrateExtraStreamToClipData();
diff --git a/core/java/android/app/TaskStackBuilder.java b/core/java/android/app/TaskStackBuilder.java
index 3e0ac7e..f3d07cc 100644
--- a/core/java/android/app/TaskStackBuilder.java
+++ b/core/java/android/app/TaskStackBuilder.java
@@ -62,6 +62,7 @@ public class TaskStackBuilder {
 
     private final ArrayList<Intent> mIntents = new ArrayList<Intent>();
     private final Context mSourceContext;
+    private boolean mFirstTaskOnHome = true;
 
     private TaskStackBuilder(Context a) {
         mSourceContext = a;
@@ -78,6 +79,10 @@ public class TaskStackBuilder {
         return new TaskStackBuilder(context);
     }
 
+    public void setTaskOnHome(boolean firstTaskOnHome) {
+        mFirstTaskOnHome = firstTaskOnHome;
+    }
+
     /**
      * Add a new Intent to the task stack. The most recently added Intent will invoke
      * the Activity at the top of the final task stack.
@@ -298,9 +303,16 @@ public class TaskStackBuilder {
         Intent[] intents = new Intent[mIntents.size()];
         if (intents.length == 0) return intents;
 
-        intents[0] = new Intent(mIntents.get(0)).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
-                Intent.FLAG_ACTIVITY_CLEAR_TASK |
-                Intent.FLAG_ACTIVITY_TASK_ON_HOME);
+        Intent newIntent = new Intent(mIntents.get(0));
+        newIntent.addFlags(
+                Intent.FLAG_ACTIVITY_NEW_TASK |
+                Intent.FLAG_ACTIVITY_CLEAR_TASK);
+
+        if (mFirstTaskOnHome) {
+            newIntent.addFlags(Intent.FLAG_ACTIVITY_TASK_ON_HOME);
+        }
+
+        intents[0] = newIntent;
         for (int i = 1; i < intents.length; i++) {
             intents[i] = new Intent(mIntents.get(i));
         }
diff --git a/core/java/android/content/ContentResolver.java b/core/java/android/content/ContentResolver.java
index 9e406d4..55c62d9 100644
--- a/core/java/android/content/ContentResolver.java
+++ b/core/java/android/content/ContentResolver.java
@@ -44,6 +44,10 @@ import android.text.TextUtils;
 import android.util.EventLog;
 import android.util.Log;
 
+// BEGIN privacy-added
+import android.privacy.surrogate.PrivacyContentResolver;
+// END privacy-added
+
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
@@ -371,6 +375,10 @@ public abstract class ContentResolver {
             try {
                 qCursor = unstableProvider.query(uri, projection,
                         selection, selectionArgs, sortOrder, remoteCancellationSignal);
+                // BEGIN privacy-added
+                // Log.d(TAG, "PDroid:ContentResolver:wrapping content resolver in PrivacyContentResolver");
+                qCursor = PrivacyContentResolver.enforcePrivacyPermission(uri, projection, mContext, qCursor);
+                // END privacy-added
             } catch (DeadObjectException e) {
                 // The remote process has died...  but we only hold an unstable
                 // reference though, so we might recover!!!  Let's try!!!!
@@ -382,6 +390,11 @@ public abstract class ContentResolver {
                 }
                 qCursor = stableProvider.query(uri, projection,
                         selection, selectionArgs, sortOrder, remoteCancellationSignal);
+                // BEGIN privacy-added
+                // Log.d(TAG, "PDroid:ContentResolver:wrapping content resolver in PrivacyContentResolver");
+        		qCursor = PrivacyContentResolver.enforcePrivacyPermission(uri, projection, mContext, qCursor);
+        		// END privacy-added
+
             }
             if (qCursor == null) {
                 return null;
diff --git a/core/java/android/content/Intent.java b/core/java/android/content/Intent.java
index 519eb36..ae52b7b 100644
--- a/core/java/android/content/Intent.java
+++ b/core/java/android/content/Intent.java
@@ -3126,7 +3126,6 @@ public class Intent implements Parcelable, Cloneable {
      * places where the framework may automatically set the exclude flag).
      */
     public static final int FLAG_INCLUDE_STOPPED_PACKAGES = 0x00000020;
-
     /**
      * If set, the new activity is not kept in the history stack.  As soon as
      * the user navigates away from it, the activity is finished.  This may also
@@ -3343,6 +3342,11 @@ public class Intent implements Parcelable, Cloneable {
      */
     public static final int FLAG_ACTIVITY_TASK_ON_HOME = 0X00004000;
     /**
+     * If set, this intent will always match start up as a floating window
+     * in mutil window scenarios.
+     */
+    public static final int FLAG_FLOATING_WINDOW = 0x00002000;
+    /**
      * If set, when sending a broadcast only registered receivers will be
      * called -- no BroadcastReceiver components will be launched.
      */
diff --git a/core/java/android/hardware/Camera.java b/core/java/android/hardware/Camera.java
index 50aa0b8..a9e342f 100644
--- a/core/java/android/hardware/Camera.java
+++ b/core/java/android/hardware/Camera.java
@@ -42,6 +42,26 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.concurrent.locks.ReentrantLock;
 
+///////////////////////////////////////////////////////
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+
+import android.content.Context;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageManager;
+
+import android.os.Process;
+import android.os.ServiceManager;
+import java.util.Random;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+///////////////////////////////////////////////////////
+
 /**
  * The Camera class is used to set image capture settings, start/stop preview,
  * snap pictures, and retrieve frames for encoding for video.  This class is a
@@ -162,6 +182,157 @@ public class Camera {
     private boolean mFaceDetectionRunning = false;
     private Object mAutoFocusCallbackLock = new Object();
 
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY 
+
+    private static final int IS_ALLOWED = -1;
+    private static final int IS_NOT_ALLOWED = -2;
+    private static final int GOT_ERROR = -3;
+    
+    private static final String PRIVACY_TAG = "PM,Camera";
+
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+    
+    private boolean privacyMode = false;
+    
+    private IPackageManager mPm;
+    
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY
+    /**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private String[] getPackageName(){
+    	try{
+    		if(mPm != null){
+        		int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+        	}
+    		else{
+    			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+    			int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+    		}
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG,"something went wrong with getting package name");
+    		return null;
+    	}
+    }
+    /**
+     * This method returns the fake image which should be in system folder! 
+     * @return byte array of jpeg fake image or null if something went wrong
+     * {@hide}
+     */
+    private byte[] getFakeImage(){
+	try{
+		String filepath = "/system/media/PDroid.jpeg";
+        	File imagefile = new File(filepath);
+        	FileInputStream fis = null;
+        	
+          	fis = new FileInputStream(imagefile);
+        	
+       	 	Bitmap bm = BitmapFactory.decodeStream(fis);
+        	ByteArrayOutputStream helper = new ByteArrayOutputStream();  
+        	bm.compress(Bitmap.CompressFormat.JPEG, 100 , helper);    
+		return helper.toByteArray();
+	}
+	catch (Exception e){
+		Log.e(PRIVACY_TAG,"something went wrong with getting the picture!");
+		e.printStackTrace();
+		return null;
+	}
+    }
+    /**
+     * {@hide}
+     * This method sets up all variables which are needed for privacy mode! It also writes to privacyMode, if everything was successfull or not! 
+     * -> privacyMode = true ok! otherwise false!
+     * CALL THIS METHOD IN CONSTRUCTOR!
+     */
+    private void initiate(){
+    	try{
+    		context = null;
+    		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    		mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+       	 	privacyMode = true;
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG, "Something went wrong with initalize variables");
+    		privacyMode = false;
+    	}
+    }
+
+    /**
+     * {@hide}
+     * This method should be used, because in some devices the uid has more than one package within!
+     * @return IS_ALLOWED (-1) if all packages allowed, IS_NOT_ALLOWED(-2) if one of these packages not allowed, GOT_ERROR (-3) if something went wrong
+     */
+    private int checkIfPackagesAllowed(){
+    	try{
+    		//boolean isAllowed = false;
+    		if(pSetMan != null){
+    			PrivacySettings pSet = null;
+	    		String[] package_names = getPackageName();
+	    		int uid = Process.myUid();
+	    		if(package_names != null){
+	    		
+		        	for(int i=0;i < package_names.length; i++){
+		        		pSet = pSetMan.getSettings(package_names[i], uid);
+		        		if(pSet != null && (pSet.getCameraSetting() != PrivacySettings.REAL)){ //if pSet is null, we allow application to access to mic
+		        			return IS_NOT_ALLOWED;
+		        		}
+		        		pSet = null;
+		        	}
+			    	return IS_ALLOWED;
+	    		}
+	    		else{
+	    			Log.e(PRIVACY_TAG,"return GOT_ERROR, because package_names are NULL");
+	    			return GOT_ERROR;
+	    		}
+    		}
+    		else{
+    			Log.e(PRIVACY_TAG,"return GOT_ERROR, because pSetMan is NULL");
+    			return GOT_ERROR;
+    		}
+    	}
+    	catch (Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG,"Got exception in checkIfPackagesAllowed");
+    		return GOT_ERROR;
+    	}
+    }
+    
+    /**
+     * Loghelper method, true = access successful, false = blocked access
+     * {@hide}
+     */
+    private void dataAccess(boolean success){
+	String package_names[] = getPackageName();
+	if(success && package_names != null){
+		for(int i=0;i<package_names.length;i++)
+			Log.i(PRIVACY_TAG,"Allowed Package: -" + package_names[i] + "- accessing camera.");
+	}
+	else if(package_names != null){
+		for(int i=0;i<package_names.length;i++)
+			Log.i(PRIVACY_TAG,"Blocked Package: -" + package_names[i] + "- accessing camera.");
+	}
+    }
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
     /**
      * Broadcast Action:  A new picture is taken by the camera, and the entry of
      * the picture has been added to the media store.
@@ -328,6 +499,14 @@ public class Camera {
         mPostviewCallback = null;
         mZoomListener = null;
 
+	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+        //BEGIN PRIVACY
+        
+        initiate();
+        
+        //END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
         Looper looper;
         if ((looper = Looper.myLooper()) != null) {
             mEventHandler = new EventHandler(this, looper);
@@ -750,6 +929,27 @@ public class Camera {
 
         @Override
         public void handleMessage(Message msg) {
+	    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+            //BEGIN PRIVACY
+
+	    boolean access = true;
+	    if(!privacyMode){
+		initiate();
+	    }
+	    String packageName[] = getPackageName();
+	    if(checkIfPackagesAllowed() == IS_NOT_ALLOWED){
+		access = false;
+		dataAccess(false);
+		if(packageName != null)
+			pSetMan.notification(packageName[0], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_CAMERA, null, pSetMan.getSettings(packageName[0], Process.myUid()));
+	    }
+	    else{
+		dataAccess(true);
+		if(packageName != null)
+			pSetMan.notification(packageName[0], 0, PrivacySettings.REAL, PrivacySettings.DATA_CAMERA, null, pSetMan.getSettings(packageName[0], Process.myUid()));
+	    }
+
+
             switch(msg.what) {
             case CAMERA_MSG_SHUTTER:
                 if (mShutterCallback != null) {
@@ -759,13 +959,19 @@ public class Camera {
 
             case CAMERA_MSG_RAW_IMAGE:
                 if (mRawImageCallback != null) {
-                    mRawImageCallback.onPictureTaken((byte[])msg.obj, mCamera);
+		    if(access)
+                    	mRawImageCallback.onPictureTaken((byte[])msg.obj, mCamera);
+		    else
+			mRawImageCallback.onPictureTaken(null, mCamera);//this normally doesn't get a call, because we disabled this receiver in takepicture method!
                 }
                 return;
 
             case CAMERA_MSG_COMPRESSED_IMAGE:
                 if (mJpegCallback != null) {
-                    mJpegCallback.onPictureTaken((byte[])msg.obj, mCamera);
+		    if(access)
+                    	mJpegCallback.onPictureTaken((byte[])msg.obj, mCamera);
+		    else
+			mJpegCallback.onPictureTaken(getFakeImage(), mCamera);
                 }
                 return;
 
@@ -783,13 +989,21 @@ public class Camera {
                         // Set to oneshot mode again.
                         setHasPreviewCallback(true, false);
                     }
-                    pCb.onPreviewFrame((byte[])msg.obj, mCamera);
+                    //pCb.onPreviewFrame((byte[])msg.obj, mCamera);
+                    if(access)
+                        pCb.onPreviewFrame((byte[])msg.obj, mCamera);//leave the camera the preview frame!
+                    else
+                        pCb.onPreviewFrame(getFakeImage(), mCamera);//here we go testing if it is able to give preview of fake image, if it doesn't work -> pass null
                 }
                 return;
 
             case CAMERA_MSG_POSTVIEW_FRAME:
                 if (mPostviewCallback != null) {
-                    mPostviewCallback.onPictureTaken((byte[])msg.obj, mCamera);
+                    //mPostviewCallback.onPictureTaken((byte[])msg.obj, mCamera);
+                    if(access)
+                        mPostviewCallback.onPictureTaken((byte[])msg.obj, mCamera);
+                    else
+                        mPostviewCallback.onPictureTaken(getFakeImage(), mCamera);//same as in onpreviewframe -> give test fake image
                 }
                 return;
 
@@ -834,6 +1048,8 @@ public class Camera {
                 return;
             }
         }
+        //END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
     }
 
     private static void postEventFromNative(Object camera_ref,
@@ -1083,6 +1299,28 @@ public class Camera {
         mPostviewCallback = postview;
         mJpegCallback = jpeg;
 
+
+	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+        //BEGIN PRIVACY
+	//check if we are in privacy mode!, this is a to hard method to prevent from making pictures, because camera will freeze!	
+	if(!privacyMode){
+		initiate();
+	}
+	if(checkIfPackagesAllowed() == IS_NOT_ALLOWED){
+//		mShutterCallback = null;
+        	mRawImageCallback = null;
+		Log.i(PRIVACY_TAG,"blocked rawImageCallback -> it will never be called!");
+//        	mPostviewCallback = null;
+//        	mJpegCallback = null;
+//		dataAccess(false);
+	}
+//	else{
+//		dataAccess(true);
+//	}
+	//END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
         // If callback is not set, do not send me callbacks.
         int msgType = 0;
         if (mShutterCallback != null) {
diff --git a/core/java/android/net/NetworkInfo.java b/core/java/android/net/NetworkInfo.java
index 0b23cb7..2616e6b 100644
--- a/core/java/android/net/NetworkInfo.java
+++ b/core/java/android/net/NetworkInfo.java
@@ -165,6 +165,14 @@ public class NetworkInfo implements Parcelable {
         }
     }
 
+    // BEGIN privacy-added
+    // SM: I've no idea where this is used
+    /**{@hide}* Used for set state to get better working Privacy*/
+    public void setState(State state){
+	   this.mState = state;
+    }
+    // END privacy-added
+
     /**
      * Reports the type of network to which the
      * info in this {@code NetworkInfo} pertains.
diff --git a/core/java/android/os/SystemProperties.java b/core/java/android/os/SystemProperties.java
index a9584d0..60e3757 100644
--- a/core/java/android/os/SystemProperties.java
+++ b/core/java/android/os/SystemProperties.java
@@ -21,6 +21,22 @@ import java.util.ArrayList;
 
 import android.util.Log;
 
+//-----------------------------------------------------------
+import com.android.internal.telephony.TelephonyProperties;
+
+import android.os.Process;
+import android.os.ServiceManager;
+
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+
+import android.content.Context;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageManager;
+import android.os.Binder;
+//----------------------------------------------------------
+
 
 /**
  * Gives access to the system properties store.  The system properties
@@ -45,6 +61,128 @@ public class SystemProperties
     private static native void native_set(String key, String def);
     private static native void native_add_change_callback();
 
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY 
+
+    private static final int IS_ALLOWED = -1;
+    private static final int IS_NOT_ALLOWED = -2;
+    private static final int GOT_ERROR = -3;
+    
+    private static final String PRIVACY_TAG = "SystemProperties";
+    private static Context context;
+    
+    private static PrivacySettingsManager pSetMan;
+    
+    private static boolean privacyMode = false;
+    
+    private static IPackageManager mPm;
+    
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY
+    /**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private static String[] getPackageName(){
+    	try{
+    		if(mPm != null){
+        		int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+        	}
+    		else{
+    			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+    			int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+    		}
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG,"something went wrong with getting package name");
+    		return null;
+    	}
+    }
+    /**
+     * {@hide}
+     * This method sets up all variables which are needed for privacy mode! It also writes to privacyMode, if everything was successfull or not! 
+     * -> privacyMode = true ok! otherwise false!
+     * CALL THIS METHOD IN CONSTRUCTOR!
+     */
+    private static void initiate(){
+    	try{
+    		context = null;
+    		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    		mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+       	 	privacyMode = true;
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG, "Something went wrong with initalize variables");
+    		privacyMode = false;
+    	}
+    }
+    /**
+     * {@hide}
+     * This method should be used, because in some devices the uid has more than one package within!
+     * @return IS_ALLOWED (-1) if all packages allowed, IS_NOT_ALLOWED(-2) if one of these packages not allowed, GOT_ERROR (-3) if something went wrong
+     */
+    private static int checkIfPackagesAllowed(){
+    	try{
+    		//boolean isAllowed = false;
+    		if(pSetMan != null){
+    			PrivacySettings pSet = null;
+	    		String[] package_names = getPackageName();
+	    		int uid = Process.myUid();
+	    		if(package_names != null){
+	    		
+		        	for(int i=0;i < package_names.length; i++){
+		        		pSet = pSetMan.getSettings(package_names[i], uid);
+		        		if(pSet != null && (pSet.getNetworkInfoSetting() != PrivacySettings.REAL)){ //if pSet is null, we allow application to access to mic
+		        			return IS_NOT_ALLOWED;
+		        		}
+		        		pSet = null;
+		        	}
+			    	return IS_ALLOWED;
+	    		}
+	    		else{
+	    			Log.e(PRIVACY_TAG,"return GOT_ERROR, because package_names are NULL");
+	    			return GOT_ERROR;
+	    		}
+    		}
+    		else{
+    			Log.e(PRIVACY_TAG,"return GOT_ERROR, because pSetMan is NULL");
+    			return GOT_ERROR;
+    		}
+    	}
+    	catch (Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG,"Got exception in checkIfPackagesAllowed");
+    		return GOT_ERROR;
+    	}
+    }
+    /**
+     * Loghelper method, true = access successful, false = blocked access
+     * {@hide}
+     */
+    private static void dataAccess(boolean success){
+	String package_names[] = getPackageName();
+	if(success && package_names != null){
+		for(int i=0;i<package_names.length;i++)
+			Log.i(PRIVACY_TAG,"Allowed Package: -" + package_names[i] + "- accessing networkinfo.");
+	}
+	else if(package_names != null){
+		for(int i=0;i<package_names.length;i++)
+			Log.i(PRIVACY_TAG,"Blocked Package: -" + package_names[i] + "- accessing networkinfo.");
+	}
+    }
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    
+
+
     /**
      * Get the value for the given key.
      * @return an empty string if the key isn't found
@@ -54,6 +192,15 @@ public class SystemProperties
         if (key.length() > PROP_NAME_MAX) {
             throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
         }
+        if (key.equals(TelephonyProperties.PROPERTY_OPERATOR_ALPHA)   || 
+            key.equals(TelephonyProperties.PROPERTY_OPERATOR_NUMERIC)     ){
+		initiate();
+		if (checkIfPackagesAllowed() == IS_NOT_ALLOWED) {
+			dataAccess(false);
+			return "";
+		}
+		dataAccess(true);
+	}
         return native_get(key);
     }
 
@@ -66,6 +213,15 @@ public class SystemProperties
         if (key.length() > PROP_NAME_MAX) {
             throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
         }
+	if (key.equals(TelephonyProperties.PROPERTY_OPERATOR_ALPHA)   || 
+            key.equals(TelephonyProperties.PROPERTY_OPERATOR_NUMERIC)     ){
+		initiate();
+		if (checkIfPackagesAllowed() == IS_NOT_ALLOWED) {
+			dataAccess(false);
+			return "";
+		}
+		dataAccess(true);
+	}
         return native_get(key, def);
     }
 
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 90b9b32..7007c70 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -58,6 +58,17 @@ import java.net.URISyntaxException;
 import java.util.HashMap;
 import java.util.HashSet;
 
+//////////////////////////////////////////////////
+import android.content.pm.IPackageManager;
+import android.os.ServiceManager;
+import android.os.Process;
+import java.util.Random;
+
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+//////////////////////////////////////////////////
+
 /**
  * The Settings provider contains global system-level device preferences.
  */
@@ -2706,6 +2717,32 @@ public final class Settings {
         public static final String COMBINED_BAR_AUTO_HIDE = "combined_bar_auto_hide";
 
         /**
+         * Pie menu, should default to 1 (yes, show)
+         * HALO, should default to 0 (no, do not show)
+         * @hide
+         */
+        public static final String HALO_ACTIVE = "halo_active";
+
+        /**
+         * HALO reversed?, should default to 1 (yes, reverse)
+         * @hide
+         */
+        public static final String HALO_REVERSED = "halo_reversed";
+
+        /**
+         * HALO hide?, should default to 0 (no, do not hide)
+         * @hide
+         */
+        public static final String HALO_HIDE = "halo_hide";
+
+        /**
+         * HALO pause activities?, defaults to 0 (no, do not pause) on devices which isLargeRAM() == true
+         * otherwise it defaults to 1 (yes, do pause)
+         * @hide
+         */
+        public static final String HALO_PAUSE = "halo_pause";
+
+        /**
          * Display style of AM/PM next to clock in status bar
          * 0: Normal display (Eclair stock)
          * 1: Small display (Froyo stock)
@@ -2819,6 +2856,12 @@ public final class Settings {
         public static final String HOME_WAKE_SCREEN = "home_wake_screen";
 
         /**
+         * Preference for the button backlight. The value is enum (0 for on touch, 1 for
+         * off, 2 for on, 3 for force off, 4 for force on).
+         */
+        public static final String BUTTON_BACKLIGHT_MODE = "button_backlight_mode";
+
+        /**
          * Whether to wake the screen with the volume keys, the value is boolean.
          * @hide
          */
@@ -3669,6 +3712,46 @@ public final class Settings {
                 }
             }
 
+            
+         //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+         //BEGIN PRIVACY
+         if(name.equals(ANDROID_ID)){ //normally it should work with sNameValueCache.getString instead of sLockSettings
+  	       initiate();
+  	       try{
+  		       if(pSetMan == null) pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+  		       if(mPm == null) mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+  		       PrivacySettings settings = null;
+  		       final String[] packages = getPackageName();
+  		       if(packages != null && packages.length > 0){
+  			       for(int i = 0; i < packages.length; i++){
+  				       settings = pSetMan.getSettings(packages[i]);
+  				       if(settings != null && settings.getAndroidIdSetting() != PrivacySettings.REAL){
+  					       String output = settings.getAndroidID();
+  					       if(output != null){
+  						       pSetMan.notification(packages[i], 0, settings.getAndroidIdSetting(), PrivacySettings.DATA_ANDROID_ID, output, null);
+  						       return output;
+  					       } else{
+  						       pSetMan.notification(packages[i], 0, settings.getAndroidIdSetting(), PrivacySettings.DATA_ANDROID_ID, "q4a5w896ay21dr46", null);
+  						       return "q4a5w896ay21dr46"; //we can not pull out empty android id, because we get bootlops then
+  					       }
+  				       }
+  				       if(i == packages.length - 1) //package is allowed to get android id
+  					       pSetMan.notification(packages[packages.length - 1], 0, PrivacySettings.REAL, PrivacySettings.DATA_ANDROID_ID, null, null);
+  				       settings = null;
+  			       }
+  		       } else{
+  			       pSetMan.notification(packages[packages.length - 1], 0, PrivacySettings.REAL, PrivacySettings.DATA_ANDROID_ID, null, null);
+  		       }
+  	       }
+  	       catch (Exception e){
+  		       e.printStackTrace();
+  		       Log.e(PRIVACY_TAG,"Got exception in  getString()");
+               }
+         }
+         //END PRIVACY
+         //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
             return sNameValueCache.getStringForUser(resolver, name, userHandle);
         }
 
@@ -3969,7 +4052,71 @@ public final class Settings {
                 int userHandle) {
             return putStringForUser(cr, name, Float.toString(value), userHandle);
         }
-
+        
+		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+		//BEGIN PRIVACY 
+		
+		private static final String PRIVACY_TAG = "PM,SecureSettings";
+		private static Context context;
+		
+		private static PrivacySettingsManager pSetMan;
+		
+		private static boolean privacyMode = false;
+		
+		private static IPackageManager mPm;
+		
+		//END PRIVACY 		
+		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+		
+		
+		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+		//BEGIN PRIVACY
+		
+		/**
+		* {@hide}
+		* @return package names of current process which is using this object or null if something went wrong
+		*/
+		private static String[] getPackageName(){
+			try{
+				if(mPm != null){
+					int uid = Process.myUid();
+					final String[] package_names = mPm.getPackagesForUid(uid);
+					return package_names;
+				}
+				else{
+					mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+					int uid = Process.myUid();
+					final String[] package_names = mPm.getPackagesForUid(uid);
+					return package_names;
+				}
+			}
+			catch(Exception e){
+				e.printStackTrace();
+				Log.e(PRIVACY_TAG,"something went wrong with getting package name");
+				return null;
+			}
+		}
+		/**
+		* {@hide}
+		* This method sets up all variables which are needed for privacy mode! It also writes to privacyMode, if everything was successfull or not! 
+		* -> privacyMode = true ok! otherwise false!
+		*/
+		private static void initiate(){
+			try{
+				context = null;
+				pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+				mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+				privacyMode = true;
+			}
+			catch(Exception e){
+				e.printStackTrace();
+				Log.e(PRIVACY_TAG, "Something went wrong with initalize variables");
+				privacyMode = false;
+			}
+		}
+		//END PRIVACY
+		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+        
         /**
          * @deprecated Use {@link android.provider.Settings.Global#DEVELOPMENT_SETTINGS_ENABLED}
          * instead
diff --git a/core/java/android/speech/srec/MicrophoneInputStream.java b/core/java/android/speech/srec/MicrophoneInputStream.java
index fab77a9..b0f5f9c 100644
--- a/core/java/android/speech/srec/MicrophoneInputStream.java
+++ b/core/java/android/speech/srec/MicrophoneInputStream.java
@@ -24,6 +24,20 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.lang.IllegalStateException;
 
+//BEGIN PRIVACY
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+
+import android.content.Context;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageManager;
+
+import android.os.Process;
+import android.os.ServiceManager;
+import android.util.Log;
+//END PRIVACY
+
 
 /**
  * PCM input stream from the microphone, 16 bits per sample.
@@ -32,11 +46,137 @@ public final class MicrophoneInputStream extends InputStream {
     static {
         System.loadLibrary("srec_jni");
     }
+
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY 
+
+    private static final int IS_ALLOWED = -1;
+    private static final int IS_NOT_ALLOWED = -2;
+    private static final int GOT_ERROR = -3;
     
+    private static final String PRIVACY_TAG = "PM,MicrophoneInputStream";
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+    
+    private boolean privacyMode = false;
+    
+    private IPackageManager mPm;
+    
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    
+
     private final static String TAG = "MicrophoneInputStream";
     private int mAudioRecord = 0;
     private byte[] mOneByte = new byte[1];
     
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY
+    /**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private String[] getPackageName(){
+    	try{
+    		if(mPm != null){
+        		int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+        	}
+    		else{
+    			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+    			int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+    		}
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG,"something went wrong with getting package name");
+    		return null;
+    	}
+    }
+    /**
+     * {@hide}
+     * This method sets up all variables which are needed for privacy mode! It also writes to privacyMode, if everything was successfull or not! 
+     * -> privacyMode = true ok! otherwise false!
+     * CALL THIS METHOD IN CONSTRUCTOR!
+     */
+    private void initiate(){
+    	try{
+    		context = null;
+    		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    		mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+       	 	privacyMode = true;
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG, "Something went wrong with initalize variables");
+    		privacyMode = false;
+    	}
+    }
+    /**
+     * {@hide}
+     * This method should be used, because in some devices the uid has more than one package within!
+     * @return IS_ALLOWED (-1) if all packages allowed, IS_NOT_ALLOWED(-2) if one of these packages not allowed, GOT_ERROR (-3) if something went wrong
+     */
+    private int checkIfPackagesAllowed(){
+    	try{
+    		//boolean isAllowed = false;
+    		if(pSetMan != null){
+    			PrivacySettings pSet = null;
+	    		String[] package_names = getPackageName();
+	    		int uid = Process.myUid();
+	    		if(package_names != null){
+	    		
+		        	for(int i=0;i < package_names.length; i++){
+		        		pSet = pSetMan.getSettings(package_names[i], uid);
+		        		if(pSet != null && (pSet.getRecordAudioSetting() != PrivacySettings.REAL)){ //if pSet is null, we allow application to access to mic
+		        			return IS_NOT_ALLOWED;
+		        		}
+		        		pSet = null;
+		        	}
+			    	return IS_ALLOWED;
+	    		}
+	    		else{
+	    			Log.e(PRIVACY_TAG,"return GOT_ERROR, because package_names are NULL");
+	    			return GOT_ERROR;
+	    		}
+    		}
+    		else{
+    			Log.e(PRIVACY_TAG,"return GOT_ERROR, because pSetMan is NULL");
+    			return GOT_ERROR;
+    		}
+    	}
+    	catch (Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG,"Got exception in checkIfPackagesAllowed");
+    		return GOT_ERROR;
+    	}
+    }
+    /**
+     * Loghelper method, true = access successful, false = blocked access
+     * {@hide}
+     */
+    private void dataAccess(boolean success){
+	String package_names[] = getPackageName();
+	if(success && package_names != null){
+		for(int i=0;i<package_names.length;i++)
+			Log.i(PRIVACY_TAG,"Allowed Package: -" + package_names[i] + "- accessing microphone.");
+	}
+	else if(package_names != null){
+		for(int i=0;i<package_names.length;i++)
+			Log.i(PRIVACY_TAG,"Blocked Package: -" + package_names[i] + "- accessing microphone.");
+	}
+    }
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+
     /**
      * MicrophoneInputStream constructor.
      * @param sampleRate sample rate of the microphone, typically 11025 or 8000.
@@ -44,6 +184,28 @@ public final class MicrophoneInputStream extends InputStream {
      * This determines how long an application may delay before losing data.
      */
     public MicrophoneInputStream(int sampleRate, int fifoDepth) throws IOException {
+
+
+	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+  	//BEGIN PRIVACY
+	if(!privacyMode){
+    		initiate();
+    	}
+	if(checkIfPackagesAllowed() == IS_NOT_ALLOWED){
+		dataAccess(false);
+		String packageName[] = getPackageName();
+		if(packageName != null)
+			pSetMan.notification(packageName[0], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_RECORD_AUDIO, null, pSetMan.getSettings(packageName[0], Process.myUid()));
+		throw new IOException("AudioRecord constructor failed - busy?");
+	}
+	dataAccess(true);
+	String packageName[] = getPackageName();
+	if(packageName != null)
+		pSetMan.notification(packageName[0], 0, PrivacySettings.REAL, PrivacySettings.DATA_RECORD_AUDIO, null, pSetMan.getSettings(packageName[0], Process.myUid())); 
+ 	//END PRIVACY
+   	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
         mAudioRecord = AudioRecordNew(sampleRate, fifoDepth);
         if (mAudioRecord == 0) throw new IOException("AudioRecord constructor failed - busy?");
         int status = AudioRecordStart(mAudioRecord);
diff --git a/core/java/android/view/Window.java b/core/java/android/view/Window.java
index fcf0924..aa8aebf 100644
--- a/core/java/android/view/Window.java
+++ b/core/java/android/view/Window.java
@@ -152,6 +152,8 @@ public abstract class Window {
     
     private boolean mDestroyed;
 
+    public boolean mIsFloatingWindow = false;
+
     // The current window attributes.
     private final WindowManager.LayoutParams mWindowAttributes =
         new WindowManager.LayoutParams();
diff --git a/core/java/com/android/internal/widget/ActionBarView.java b/core/java/com/android/internal/widget/ActionBarView.java
index 0f964b9..856a8ee 100644
--- a/core/java/com/android/internal/widget/ActionBarView.java
+++ b/core/java/com/android/internal/widget/ActionBarView.java
@@ -903,19 +903,8 @@ public class ActionBarView extends AbsActionBarView {
         mIsCollapsed = false;
 
         int widthMode = MeasureSpec.getMode(widthMeasureSpec);
-        if (widthMode != MeasureSpec.EXACTLY) {
-            throw new IllegalStateException(getClass().getSimpleName() + " can only be used " +
-                    "with android:layout_width=\"match_parent\" (or fill_parent)");
-        }
-        
         int heightMode = MeasureSpec.getMode(heightMeasureSpec);
-        if (heightMode != MeasureSpec.AT_MOST) {
-            throw new IllegalStateException(getClass().getSimpleName() + " can only be used " +
-                    "with android:layout_height=\"wrap_content\"");
-        }
-
         int contentWidth = MeasureSpec.getSize(widthMeasureSpec);
-
         int maxHeight = mContentHeight >= 0 ?
                 mContentHeight : MeasureSpec.getSize(heightMeasureSpec);
         
diff --git a/core/res/res/values/symbols.xml b/core/res/res/values/symbols.xml
index 0ff9036..c2369bf 100644
--- a/core/res/res/values/symbols.xml
+++ b/core/res/res/values/symbols.xml
@@ -1162,6 +1162,8 @@
   <java-symbol type="style" name="Theme.DeviceDefault.Dialog.NoFrame" />
   <java-symbol type="style" name="Theme.IconMenu" />
   <java-symbol type="style" name="Theme.Panel.Volume" />
+  <java-symbol type="style" name="Theme.DeviceDefault.FloatingWindow" />
+  <java-symbol type="style" name="Theme.DeviceDefault.FloatingWindowLight" />
 
   <java-symbol type="attr" name="mediaRouteButtonStyle" />
   <java-symbol type="attr" name="externalRouteEnabledDrawable" />
diff --git a/core/res/res/values/themes_device_defaults.xml b/core/res/res/values/themes_device_defaults.xml
index 4178cc4..e0dfd1f 100644
--- a/core/res/res/values/themes_device_defaults.xml
+++ b/core/res/res/values/themes_device_defaults.xml
@@ -485,8 +485,32 @@ easier.
     decorations, so you basically have an empty rectangle in which to place your content. It makes
     the window floating, with a transparent background, and turns off dimming behind the window. -->
     <style name="Theme.DeviceDefault.Panel" parent="Theme.Holo.Panel" >
+    </style>
+
+    <style name="Theme.DeviceDefault.FloatingWindow">
+        <item name="android:windowIsFloating">false</item>
+        <item name="android:windowIsTranslucent">true</item>
+        <item name="android:windowFrame">@null</item>
+        <item name="android:windowContentOverlay">@null</item>
+        <item name="android:windowAnimationStyle">@android:style/Animation.Dialog</item>
+        <item name="android:windowActionModeOverlay">true</item>
+        <item name="android:windowCloseOnTouchOutside">true</item>
+        <item name="android:windowFullscreen">false</item>
+        <item name="android:windowSoftInputMode">stateAlwaysHidden|adjustPan</item>
+    </style>
 
+    <style name="Theme.DeviceDefault.FloatingWindowLight" parent="Theme.Holo.Light.Dialog">
+        <item name="android:windowIsFloating">false</item>
+        <item name="android:windowIsTranslucent">true</item>
+        <item name="android:windowFrame">@null</item>
+        <item name="android:windowContentOverlay">@null</item>
+        <item name="android:windowAnimationStyle">@android:style/Animation.Dialog</item>
+        <item name="android:windowActionModeOverlay">true</item>
+        <item name="android:windowCloseOnTouchOutside">true</item>
+        <item name="android:windowFullscreen">false</item>
+        <item name="android:windowSoftInputMode">stateAlwaysHidden|adjustPan</item>
     </style>
+
     <!-- DeviceDefault light theme for panel windows. This removes all extraneous window
     decorations, so you basically have an empty rectangle in which to place your content. It makes
     the window floating, with a transparent background, and turns off dimming behind the window. -->
diff --git a/media/java/android/media/AudioRecord.java b/media/java/android/media/AudioRecord.java
index 59177a7..fcccccc 100644
--- a/media/java/android/media/AudioRecord.java
+++ b/media/java/android/media/AudioRecord.java
@@ -29,6 +29,22 @@ import android.os.Looper;
 import android.os.Message;
 import android.util.Log;
 
+////////////////////////////////////////////
+import android.app.ActivityThread;
+import android.app.Application;
+import android.content.Context;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageManager;
+import android.os.Binder;
+
+import android.os.Process;
+import android.os.ServiceManager;
+
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+///////////////////////////////////////////
+
 /**
  * The AudioRecord class manages the audio resources for Java applications
  * to record audio from the audio input hardware of the platform. This is
@@ -190,6 +206,28 @@ public class AudioRecord
      */
     private int mSessionId = 0;
 
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY 
+
+    private static final int IS_ALLOWED = -1;
+    private static final int IS_NOT_ALLOWED = -2;
+    private static final int GOT_ERROR = -3;
+    
+    private static final String PRIVACY_TAG = "PM,AudioRecord";
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+    
+    private boolean privacyMode = false;
+    
+    private IPackageManager mPm;
+    
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+
     //---------------------------------------------------------
     // Constructor, Finalize
     //--------------------
@@ -242,12 +280,125 @@ public class AudioRecord
             return; // with mState == STATE_UNINITIALIZED
         }
 
+	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+        //BEGIN PRIVACY
+        
+        initiate();
+       
+        //END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
         mSessionId = session[0];
 
         mState = STATE_INITIALIZED;
     }
 
 
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY
+    /**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private String[] getPackageName(){
+    	try{
+    		if(mPm != null){
+        		int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+        	}
+    		else{
+    			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+    			int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+    		}
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG,"something went wrong with getting package name");
+    		return null;
+    	}
+    }
+    /**
+     * {@hide}
+     * This method sets up all variables which are needed for privacy mode! It also writes to privacyMode, if everything was successfull or not! 
+     * -> privacyMode = true ok! otherwise false!
+     * CALL THIS METHOD IN CONSTRUCTOR!
+     */
+    private void initiate(){
+    	try{
+    		context = null;
+    		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    		mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+       	 	privacyMode = true;
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG, "Something went wrong with initalize variables");
+    		privacyMode = false;
+    	}
+    }
+    /**
+     * {@hide}
+     * This method should be used, because in some devices the uid has more than one package within!
+     * @return IS_ALLOWED (-1) if all packages allowed, IS_NOT_ALLOWED(-2) if one of these packages not allowed, GOT_ERROR (-3) if something went wrong
+     */
+    private int checkIfPackagesAllowed(){
+    	try{
+    		//boolean isAllowed = false;
+    		if(pSetMan != null){
+    			PrivacySettings pSet = null;
+	    		String[] package_names = getPackageName();
+	    		int uid = Process.myUid();
+	    		if(package_names != null){
+	    		
+		        	for(int i=0;i < package_names.length; i++){
+		        		pSet = pSetMan.getSettings(package_names[i], uid);
+		        		if(pSet != null && (pSet.getRecordAudioSetting() != PrivacySettings.REAL)){ //if pSet is null, we allow application to access to mic
+		        			return IS_NOT_ALLOWED;
+		        		}
+		        		pSet = null;
+		        	}
+			    	return IS_ALLOWED;
+	    		}
+	    		else{
+	    			Log.e(PRIVACY_TAG,"return GOT_ERROR, because package_names are NULL");
+	    			return GOT_ERROR;
+	    		}
+    		}
+    		else{
+    			Log.e(PRIVACY_TAG,"return GOT_ERROR, because pSetMan is NULL");
+    			return GOT_ERROR;
+    		}
+    	}
+    	catch (Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG,"Got exception in checkIfPackagesAllowed");
+    		return GOT_ERROR;
+    	}
+    }
+    /**
+     * Loghelper method, true = access successful, false = blocked access
+     * {@hide}
+     */
+    private void dataAccess(boolean success){
+	String package_names[] = getPackageName();
+	if(success && package_names != null){
+		for(int i=0;i<package_names.length;i++)
+			Log.i(PRIVACY_TAG,"Allowed Package: -" + package_names[i] + "- accessing microphone.");
+	}
+	else if(package_names != null){
+		for(int i=0;i<package_names.length;i++)
+			Log.i(PRIVACY_TAG,"Blocked Package: -" + package_names[i] + "- accessing microphone.");
+	}
+    }
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    
+
+
+
+
     // Convenience method for the constructor's parameter checks.
     // This is where constructor IllegalArgumentException-s are thrown
     // postconditions:
@@ -528,10 +679,27 @@ public class AudioRecord
      */
     public void startRecording()
     throws IllegalStateException {
-        if (mState != STATE_INITIALIZED) {
-            throw(new IllegalStateException("startRecording() called on an "
-                    +"uninitialized AudioRecord."));
+
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    	//BEGIN PRIVACY
+    	//now check if everything was ok in constructor!
+    	if(!privacyMode){
+    		initiate();
+    	}
+        if ((mState != STATE_INITIALIZED) || (checkIfPackagesAllowed() == IS_NOT_ALLOWED)) { //If applicaton is not allowed -> throw exception!
+            dataAccess(false);
+	    String packageName[] = getPackageName();
+	    if(packageName != null)
+	    	pSetMan.notification(packageName[0], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_RECORD_AUDIO, null, pSetMan.getSettings(packageName[0], Process.myUid()));  
+            throw(new IllegalStateException("startRecording() called on an "+"uninitialized AudioRecord."));
         }
+        dataAccess(true);
+	String packageName[] = getPackageName();
+	if(packageName != null)
+		pSetMan.notification(packageName[0], 0, PrivacySettings.REAL, PrivacySettings.DATA_RECORD_AUDIO, null, pSetMan.getSettings(packageName[0], Process.myUid())); 
+        //END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
 
         // start recording
         synchronized(mRecordingStateLock) {
diff --git a/media/java/android/media/MediaRecorder.java b/media/java/android/media/MediaRecorder.java
index 544410f..e1a20c1 100644
--- a/media/java/android/media/MediaRecorder.java
+++ b/media/java/android/media/MediaRecorder.java
@@ -22,12 +22,27 @@ import android.os.Looper;
 import android.os.Message;
 import android.util.Log;
 import android.view.Surface;
-
 import java.io.FileDescriptor;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.lang.ref.WeakReference;
 
+///////////////////////////////////////////
+import android.os.Environment;
+import java.io.FileWriter;
+import java.io.File;
+import android.os.Binder;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.content.pm.IPackageManager;
+import android.content.Context;
+import java.util.Random;
+
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+///////////////////////////////////////////
+
 /**
  * Used to record audio and video. The recording control is based on a
  * simple state machine (see below).
@@ -91,6 +106,68 @@ public class MediaRecorder
     private OnErrorListener mOnErrorListener;
     private OnInfoListener mOnInfoListener;
 
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY 
+    
+    /** default value of privacy path. You have to add the package name at the end to write file in directory of the app itself*/
+    private static final String PRIVACY_PATH_DEF = "/data/data/";
+    
+    /**
+     * This variable will be set if user use path to save file. Only if user is not allowed!
+     */
+    private String pPath = null;
+    
+    /**
+     * Path where Filedescriptor linked to.
+     */
+    private String pFileDescriptorPath = null;
+    
+    /**
+     * This variable will be set if user use FileDescriptor so save file. Only if user is not allowed!
+     */
+    private FileDescriptor pFileDescriptor = null;
+    
+    
+    private PrivacyRunner pRunner = null;
+    
+    
+    private boolean deletedFile = false;
+    
+    
+    private static final int STATE_RECORD_AUDIO = 0;
+    private static final int STATE_RECORD_BOTH = 1;
+    private static final int MODE_RECORD_AUDIO = 2;
+    private static final int MODE_RECORD_BOTH = 3;
+    private static final int IS_ALLOWED = -1;
+    private static final int IS_NOT_ALLOWED = -2;
+    private static final int GOT_ERROR = -3;
+
+    private static final int MIC_DATA_ACCESS = 10;
+    private static final int BOTH_DATA_ACCESS = 11;
+
+    private static final String PRIVACY_TAG = "PM,MediaRecorder";
+
+    /**
+     * {@hide} This context will ever be null, because we dont need it but pass it to the pSetMan!
+     */
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+    
+    private IPackageManager mPm;
+    
+    private boolean privacyMode = false;
+    
+    private boolean stoppedStream = false;
+    
+    private int ACTUAL_STATE = STATE_RECORD_AUDIO;
+    
+
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
     /**
      * Default constructor.
      */
@@ -105,6 +182,16 @@ public class MediaRecorder
             mEventHandler = null;
         }
 
+
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+        //BEGIN PRIVACY
+        
+        initiate();
+        
+        //END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
         /* Native setup requires a weak reference to our object.
          * It's easier to create it here than in C++.
          */
@@ -135,9 +222,300 @@ public class MediaRecorder
      * @see android.hardware.Camera#setPreviewDisplay(android.view.SurfaceHolder)
      */
     public void setPreviewDisplay(Surface sv) {
+
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    	//BEGIN PRIVACY 
+    	ACTUAL_STATE = STATE_RECORD_BOTH;
+    	//END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
         mSurface = sv;
     }
 
+
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY 
+    
+    /**
+     * PrivacyStop. Should be called within privacyRunner
+     */
+    private void privacyStop(){
+    	try{
+    		stop();
+    	} catch(Exception e){
+    		Log.e(PRIVACY_TAG,"Got exception while trying to call privacyStop()");
+    	}
+    }
+    
+    /**
+     * This method search automatically the current package path and return it. If we haven't found any path, we return the path to SDcard if we are able to write to it.
+     * If we're not able to write to sdCard -> return null
+     * @return internal path to package directory or path to SDCard if package not found and we have rights to save files on SDCard. If something went wrong or we couldn't find
+     * anything of it -> return null
+     */
+    private String getPrivacyPath(){
+    	final String[] packages = getPackageName();
+    	Random value = new Random();
+		String current_package = null, data_name = value.nextLong() + ".tmp";
+		FileWriter fWriter = null;
+		File deleteMe = null;
+		
+		for(int i=0;i<packages.length;i++){
+			try{
+				//first check if cache folder exist
+				File folder = new File(PRIVACY_PATH_DEF + packages[i] + "/cache/");
+				folder.mkdirs();
+				fWriter = new FileWriter(PRIVACY_PATH_DEF + packages[i] + "/cache/" + data_name);
+	            fWriter.write("test");
+	            fWriter.flush();
+	            fWriter.close();
+	            deleteMe = new File(PRIVACY_PATH_DEF + packages[i] + "/cache/" + data_name);
+	            deleteMe.delete();
+	            Log.i(PRIVACY_TAG,"found our package: " + packages[i] + " with internal path. File: " + data_name);
+	            //all is fine, break now and save our current package name!
+	            current_package = packages[i];
+	            break;
+	    	} catch(Exception e){
+	    		//we're not allowed to write in this directory -> this is not our package!
+	    	} finally{
+	    		fWriter = null;
+	            deleteMe = null;
+	            System.gc();
+	    	}
+		}
+    	if(current_package != null){
+    		Log.i(PRIVACY_TAG,"returned file: " + data_name + " for package: " + current_package + " with internal path. Path: " + PRIVACY_PATH_DEF + current_package + "/cache/" + data_name);
+    		return PRIVACY_PATH_DEF + current_package + "/cache/" + data_name;
+    	}
+    	else{ //last chance, try to write to SD-Card
+    		try{
+    			String sdPath = Environment.getExternalStorageDirectory().getAbsolutePath();
+        		fWriter = new FileWriter(sdPath + "/" + data_name);
+                fWriter.write("test");
+                fWriter.flush();
+                fWriter.close();
+                deleteMe = new File(sdPath + "/" + data_name);
+                deleteMe.delete();
+                Log.i(PRIVACY_TAG,"Return filePath:  " + sdPath + "/" + data_name + " . It is on SDCard!");
+                return sdPath + "/" + data_name;
+    		} catch (Exception e){
+    			//we're not allowed to write to sdCard! 
+    			//return null
+    			return null;
+    		}
+    	}
+    }
+    
+    
+    /**
+     * This method does exactly what the method getPrivacyPath() does, but it returns an FileDescriptor to path
+     * @return FileDescriptor to privacyFile or null if something went wrong
+     */
+    private FileDescriptor getPrivacyFileDescriptor(){
+    	final String[] packages = getPackageName();
+    	Random value = new Random();
+		String current_package = null, data_name = value.nextLong() + ".tmp";
+		FileWriter fWriter = null;
+		File deleteMe = null;
+		
+		for(int i=0;i<packages.length;i++){
+			try{
+				//first check if cache folder exist
+				File folder = new File(PRIVACY_PATH_DEF + packages[i] + "/cache/");
+				folder.mkdirs();
+				fWriter = new FileWriter(PRIVACY_PATH_DEF + packages[i] + "/cache/" + data_name);
+	            fWriter.write("test");
+	            fWriter.flush();
+	            fWriter.close();
+	            deleteMe = new File(PRIVACY_PATH_DEF + packages[i] + "/cache/" + data_name);
+	            deleteMe.delete();
+	            Log.i(PRIVACY_TAG,"found our package: " + packages[i] + " with internal path. File: " + data_name);
+	            //all is fine, break now and save our current package name!
+	            current_package = packages[i];
+	            break;
+	    	} catch(Exception e){
+	    		//we're not allowed to write in this directory -> this is not our package!
+	    	} finally{
+	    		fWriter = null;
+	            deleteMe = null;
+	            System.gc();
+	    	}
+		}
+    	if(current_package != null){
+    		try{
+    			FileOutputStream fos = new  FileOutputStream(PRIVACY_PATH_DEF + current_package + "/cache/" + data_name);
+    			FileDescriptor fD = fos.getFD();
+    			pFileDescriptorPath = PRIVACY_PATH_DEF + current_package + "/cache/" + data_name;
+    			Log.i(PRIVACY_TAG,"returned fileDescriptor for package: " + current_package + " with internal path. Path: " + PRIVACY_PATH_DEF + current_package + "/cache/" + data_name);
+    			return fD;
+    		} catch(Exception e){
+    			Log.e(PRIVACY_TAG,"Got exception while creating fileDescriptor -> return null");
+    			return null;
+    		}
+    	}
+    	else{ //last chance, try to write to SD-Card
+    		try{
+    			String sdPath = Environment.getExternalStorageDirectory().getAbsolutePath();
+        		fWriter = new FileWriter(sdPath + "/" + data_name);
+                fWriter.write("test");
+                fWriter.flush();
+                fWriter.close();
+                deleteMe = new File(sdPath + "/" + data_name);
+                deleteMe.delete();
+                FileOutputStream fos = new  FileOutputStream(sdPath + "/" + data_name);
+                FileDescriptor fD = fos.getFD();
+                pFileDescriptorPath = sdPath + "/" + data_name;
+                Log.i(PRIVACY_TAG,"Returned FileDescriptor. Path:  " + sdPath + "/" + data_name + " . It is on SDCard!");
+                return fD;
+    		} catch (Exception e){
+    			//we're not allowed to write to sdCard! 
+    			//return null
+    			return null;
+    		}
+    	}
+    }
+    
+    
+    
+    /**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private String[] getPackageName(){
+    	try{
+    		if(mPm != null){
+        		int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+        	}
+    		else{
+    			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+    			int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+    		}
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG,"something went wrong with getting package name");
+    		return null;
+    	}
+    }
+    /**
+     * {@hide}
+     * This method should be used, because in some devices the uid has more than one package within!
+     * @param privacySetting the Mode which has to be tested -> MODE_RECORD_AUDIO, MODE_RECORD_BOTH
+     * @return IS_ALLOWED (-1) if all packages allowed, IS_NOT_ALLOWED(-2) if one of these packages not allowed, GOT_ERROR (-3) if something went wrong
+     */
+    private int checkIfPackagesAllowed(int privacySetting){
+    	try{
+    		//boolean isAllowed = false;
+    		if(pSetMan != null){
+    			PrivacySettings pSet = null;
+	    		String[] package_names = getPackageName();
+	    		int uid = Process.myUid();
+	    		if(package_names != null){
+	    			switch(privacySetting){
+	    				case MODE_RECORD_AUDIO:
+	    					
+				        	for(int i=0;i < package_names.length; i++){
+				        		pSet = pSetMan.getSettings(package_names[i], uid);
+				        		if(pSet != null && (pSet.getRecordAudioSetting() != PrivacySettings.REAL)){ //if pSet is null, we allow application to access to mic
+				        			return IS_NOT_ALLOWED;
+				        		}
+				        		pSet = null;
+				        	}
+	    			    	return IS_ALLOWED;
+	    					
+	    				case MODE_RECORD_BOTH:
+	    					
+				        	for(int i=0;i < package_names.length; i++){
+				        		pSet = pSetMan.getSettings(package_names[i], uid);
+				        		if(pSet != null && ((pSet.getRecordAudioSetting() != PrivacySettings.REAL) || (pSet.getCameraSetting() != PrivacySettings.REAL))){ //if pSet is null, we allow application to access to mic
+				        			return IS_NOT_ALLOWED;
+				        		}
+				        		pSet = null;
+				        	}
+	    			    	return IS_ALLOWED;
+					default: return GOT_ERROR;
+	    					
+	    			}
+	    		}
+	    		else{
+	    			Log.e(PRIVACY_TAG,"return GOT_ERROR, because package_names are NULL");
+	    			return GOT_ERROR;
+	    		}
+    		}
+    		else{
+    			Log.e(PRIVACY_TAG,"return GOT_ERROR, because pSetMan is NULL");
+    			return GOT_ERROR;
+    		}
+    	}
+    	catch (Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG,"Got exception in checkIfPackagesAllowed");
+    		return GOT_ERROR;
+    	}
+    }
+    /**
+     * {@hide}
+     * This method sets up all variables which are needed for privacy mode! It also writes to privacyMode, if everything was successfull or not! 
+     * -> privacyMode = true ok! otherwise false!
+     * CALL THIS METHOD IN CONSTRUCTOR!
+     */
+    private void initiate(){
+    	try{
+    		context = null;
+    		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    		mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+       	 	//runner = new PrivacyRunner();
+       	 	privacyMode = true;
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG, "Something went wrong with initalize variables");
+    		privacyMode = false;
+    	}
+    }
+ 
+     /**
+     * Loghelper method, true = access successful, false = blocked access. 
+     * {@hide}
+     */
+    private void dataAccess(boolean success, int micOrBoth){
+	String package_names[] = getPackageName();
+	if(success && package_names != null){
+		switch(micOrBoth){
+			case MIC_DATA_ACCESS:
+				for(int i=0;i<package_names.length;i++)
+					Log.i(PRIVACY_TAG,"Allowed Package: -" + package_names[i] + "- accessing microphone.");
+				break;
+			case BOTH_DATA_ACCESS:
+				for(int i=0;i<package_names.length;i++)
+					Log.i(PRIVACY_TAG,"Allowed Package: -" + package_names[i] + "- accessing microphone and camera.");
+				break;
+		}
+		
+	}
+	else if(package_names != null){
+		switch(micOrBoth){
+		case MIC_DATA_ACCESS:
+				for(int i=0;i<package_names.length;i++)
+					Log.i(PRIVACY_TAG,"Blocked Package: -" + package_names[i] + "- accessing microphone.");
+				break;
+			case BOTH_DATA_ACCESS:
+				for(int i=0;i<package_names.length;i++)
+					Log.i(PRIVACY_TAG,"Blocked Package: -" + package_names[i] + "- accessing microphone and camera.");
+				break;
+		}
+	}
+    }
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+
     /**
      * Defines the audio source. These constants are used with
      * {@link MediaRecorder#setAudioSource(int)}.
@@ -340,6 +718,13 @@ public class MediaRecorder
      * @see android.media.CamcorderProfile
      */
     public void setProfile(CamcorderProfile profile) {
+
+    	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    	//BEGIN PRIVACY 
+    	ACTUAL_STATE = STATE_RECORD_BOTH;
+    	//END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
         setOutputFormat(profile.fileFormat);
         setVideoFrameRate(profile.videoFrameRate);
         setVideoSize(profile.videoFrameWidth, profile.videoFrameHeight);
@@ -374,6 +759,13 @@ public class MediaRecorder
      * possible.
      */
     public void setCaptureRate(double fps) {
+
+    	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    	//BEGIN PRIVACY 
+    	ACTUAL_STATE = STATE_RECORD_BOTH;
+    	//END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
         // Make sure that time lapse is enabled when this method is called.
         setParameter("time-lapse-enable=1");
 
@@ -601,6 +993,13 @@ public class MediaRecorder
      * @param bitRate the video encoding bit rate in bits per second.
      */
     public void setVideoEncodingBitRate(int bitRate) {
+
+	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    	//BEGIN PRIVACY 
+    	ACTUAL_STATE = STATE_RECORD_BOTH;
+    	//END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
         if (bitRate <= 0) {
             throw new IllegalArgumentException("Video encoding bit rate is not positive");
         }
@@ -641,6 +1040,7 @@ public class MediaRecorder
     {
         mPath = null;
         mFd = fd;
+        deletedFile = false;
     }
 
     /**
@@ -655,6 +1055,7 @@ public class MediaRecorder
     {
         mFd = null;
         mPath = path;
+        deletedFile = false;
     }
 
     // native implementation
@@ -673,6 +1074,78 @@ public class MediaRecorder
      */
     public void prepare() throws IllegalStateException, IOException
     {
+
+    	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    	//BEGIN PRIVACY
+    	if(!privacyMode){
+    		initiate();
+    	}
+    	deletedFile = false;
+		boolean skip = false;
+		switch(ACTUAL_STATE){
+    		case STATE_RECORD_AUDIO:
+				if(checkIfPackagesAllowed(MODE_RECORD_AUDIO) == IS_NOT_ALLOWED /* || checkIfPackagesAllowed(MODE_RECORD_BOTH) == IS_NOT_ALLOWED*/){
+					String x[] = getPackageName();
+					if(x != null && x.length > 0)
+						pSetMan.notification(x[0], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_RECORD_AUDIO, null, null);
+					pRunner = new PrivacyRunner();
+					//here wo do not need to exchange the path or filedescriptor, because we can interrupt very quick!
+					pRunner.setDelay(50); // try very low value
+					pRunner.start();
+					skip = true;
+	//				if(x != null) Log.i(PRIVACY_TAG,"now throw exception in prepare method for package: " + x[0]);
+	//				else Log.i(PRIVACY_TAG,"now throw exception in prepare method");
+	//				if(ACTUAL_STATE == STATE_RECORD_BOTH){
+	//					dataAccess(false, BOTH_DATA_ACCESS);
+	//					if(x != null)
+	//						pSetMan.notification(x[0], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_CAMERA, null, pSetMan.getSettings(x[0], Process.myUid()));
+	//				}
+	//				else{
+	//					dataAccess(false, MIC_DATA_ACCESS);
+	//					if(x != null)
+	//						pSetMan.notification(x[0], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_RECORD_AUDIO, null, pSetMan.getSettings(x[0], Process.myUid()));
+	//					//now test something, because a lot of applications crashes if we throw illegalstateException. We intercept now when applications wants to record audio!
+	//					//skip = true;
+	//					//break;
+	//				}
+	//				throw new IllegalStateException(); //now throw exception to prevent recording 
+				}
+				break;
+    		case STATE_RECORD_BOTH:
+				if(checkIfPackagesAllowed(MODE_RECORD_BOTH) == IS_NOT_ALLOWED){
+					String x[] = getPackageName();
+					if(x != null && x.length > 0)
+						pSetMan.notification(x[0], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_CAMERA, null, null);
+					if(mPath != null){
+						//now overwrite path
+						mPath = getPrivacyPath();
+					} else if(mFd != null){
+						//now overwrite fileDescriptor
+						mFd = getPrivacyFileDescriptor();
+					} else{
+						//no chance to get it, throw exception
+						throw new IOException("No valid output file");
+					}
+					pRunner = new PrivacyRunner();
+					//we use default time for video record
+					pRunner.start();
+					skip = true;
+					
+				}
+				break;
+		}
+		//END PRIVACY
+	    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+		String packageName[] = getPackageName();
+		if(!skip){
+			if (ACTUAL_STATE == STATE_RECORD_BOTH && packageName != null && packageName.length > 0) {
+				pSetMan.notification(packageName[0], 0, PrivacySettings.REAL, PrivacySettings.DATA_CAMERA, null, null);
+			} else if (packageName != null && packageName.length > 0) {
+				pSetMan.notification(packageName[0], 0, PrivacySettings.REAL, PrivacySettings.DATA_RECORD_AUDIO, null, null);
+			}
+			deletedFile = true;
+		}
+
         if (mPath != null) {
             FileOutputStream fos = new FileOutputStream(mPath);
             try {
@@ -725,7 +1198,24 @@ public class MediaRecorder
      */
     public void reset() {
         native_reset();
-
+        if(!deletedFile){
+        	if(mPath != null){
+				File tmp = new File(mPath);
+				if(tmp.delete())
+					deletedFile = true;
+			} else if(mFd != null && pFileDescriptorPath != null){
+				File tmp = new File(pFileDescriptorPath);
+				if(tmp.delete())
+					deletedFile = true;
+			} else{
+				Log.e(PRIVACY_TAG,"Can't delete temporary File, because all is null?! It could be that we only want to record audio?!");
+				deletedFile = false;
+			}
+        }
+        //
+        pRunner = null;
+        System.gc();
+        //
         // make sure none of the listeners get called anymore
         mEventHandler.removeCallbacksAndMessages(null);
     }
@@ -1006,5 +1496,81 @@ public class MediaRecorder
     private native void setParameter(String nameValuePair);
 
     @Override
-    protected void finalize() { native_finalize(); }
+    protected void finalize() { 
+    	
+    	if(!deletedFile){
+        	if(mPath != null){
+				File tmp = new File(mPath);
+				if(tmp.delete())
+					deletedFile = true;
+			} else if(mFd != null && pFileDescriptorPath != null){
+				File tmp = new File(pFileDescriptorPath);
+				if(tmp.delete())
+					deletedFile = true;
+			} else{
+				Log.e(PRIVACY_TAG,"Can't delete temporary File, because all is null?! It could be that we only want to record audio?!");
+				deletedFile = false;
+			}
+        }
+    	native_finalize(); }
+    
+    
+//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+//BEGIN PRIVACY
+	/**
+	* Helper class to interrupt stream.
+	* @author CollegeDev
+	* {@hide}
+	*/
+	private class PrivacyRunner extends Thread{
+	
+		private static final long OFFSET_DELAY = 2500;	
+		
+		private long delay = OFFSET_DELAY;
+		
+		public PrivacyRunner(){
+		
+		}
+		
+		public void setDelay(long delay){
+			this.delay = delay;
+		}
+		
+		public long getDelay(){
+			return delay;
+		}
+		
+		@Override
+		public void run() {
+			try{
+				Thread.sleep(delay);
+				//now we're going to stop stream
+				privacyStop();
+				if(mPath != null){
+					File tmp = new File(mPath);
+					if(tmp.delete())
+						deletedFile = true;
+				} else if(mFd != null && pFileDescriptorPath != null){
+					File tmp = new File(pFileDescriptorPath);
+					if(tmp.delete())
+						deletedFile = true;
+				} else{
+					Log.e(PRIVACY_TAG,"Can't delete temporary File, because all is null?! It could be that we only want to record audio?!");
+					deletedFile = false;
+				}
+			}
+			catch(Exception e){
+				Log.e(PRIVACY_TAG,"Something went wrong while waiting for cancel the stream!");
+				e.printStackTrace();
+			}
+			finally{
+				privacyStop();
+			}
+		}
+	
+	}
+	//END PRIVACY
+	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    
+    
 }
diff --git a/packages/SystemUI/AndroidManifest.xml b/packages/SystemUI/AndroidManifest.xml
index 80bb24d..bbed46a 100644
--- a/packages/SystemUI/AndroidManifest.xml
+++ b/packages/SystemUI/AndroidManifest.xml
@@ -74,6 +74,9 @@
     <uses-permission android:name="android.permission.READ_SYNC_SETTINGS" />
     <uses-permission android:name="android.permission.WRITE_SYNC_SETTINGS" />
 
+    <!--Halo-->
+    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/>
+
     <application
         android:persistent="true"
         android:allowClearUserData="false"
@@ -255,5 +258,8 @@
                 <category android:name="android.intent.category.DESK_DOCK" />
             </intent-filter>
         </activity>
+
+        <activity android:name="com.android.systemui.Transparent"
+            android:theme="@android:style/Theme.Translucent.NoTitleBar" />
     </application>
 </manifest>
diff --git a/packages/SystemUI/proguard.flags b/packages/SystemUI/proguard.flags
index c886eea..f32be13 100644
--- a/packages/SystemUI/proguard.flags
+++ b/packages/SystemUI/proguard.flags
@@ -14,4 +14,13 @@
   public void setGlowScale(float);
 }
 
+-keep class com.android.systemui.statusbar.halo.HaloProperties {
+  public int getHaloX();
+  public int getHaloY();
+  public float getHaloContentAlpha();
+  public void setHaloX(int);
+  public void setHaloY(int);
+  public void setHaloContentAlpha(float);
+}
+
 -keep class com.android.systemui.statusbar.tv.TvStatusBar
diff --git a/packages/SystemUI/res/layout/status_bar_expanded_header.xml b/packages/SystemUI/res/layout/status_bar_expanded_header.xml
index e8ceeed..64f8d47 100644
--- a/packages/SystemUI/res/layout/status_bar_expanded_header.xml
+++ b/packages/SystemUI/res/layout/status_bar_expanded_header.xml
@@ -74,9 +74,19 @@
         android:padding="2dp"
         />
 
+    <ImageView android:id="@+id/halo_button"
+        android:layout_width="50dp"
+        android:layout_height="50dp"
+        android:scaleType="center"
+        android:src="@drawable/ic_notify_halo_normal"
+        android:background="@drawable/ic_notify_button_bg"
+        android:contentDescription="@string/accessibility_halo"
+        />     
+
     <ImageView android:id="@+id/clear_all_button"
         android:layout_width="50dp"
         android:layout_height="50dp"
+        android:layout_marginLeft="5dp"
         android:scaleType="center"
         android:src="@drawable/ic_notify_clear"
         android:contentDescription="@string/accessibility_clear_all"
@@ -85,7 +95,7 @@
     <FrameLayout android:id="@+id/settings_button_holder"
         android:layout_width="50dp"
         android:layout_height="50dp"
-        android:layout_marginLeft="12dp"
+        android:layout_marginLeft="5dp"
         >
         <ImageView android:id="@+id/settings_button"
             android:layout_width="50dp"
diff --git a/packages/SystemUI/res/values-land/dimens.xml b/packages/SystemUI/res/values-land/dimens.xml
index ab71371..3d42a3a 100644
--- a/packages/SystemUI/res/values-land/dimens.xml
+++ b/packages/SystemUI/res/values-land/dimens.xml
@@ -40,4 +40,8 @@
 
     <!-- The fixed height of each tile -->
     <dimen name="quick_settings_cell_height">100dp</dimen>
+
+    <dimen name="pie_panel_padding">100dp</dimen>
+
+    <dimen name="halo_content_max_width">350dp</dimen>
 </resources>
diff --git a/packages/SystemUI/res/values/dimens.xml b/packages/SystemUI/res/values/dimens.xml
index 158c355..114827f 100644
--- a/packages/SystemUI/res/values/dimens.xml
+++ b/packages/SystemUI/res/values/dimens.xml
@@ -237,4 +237,7 @@
 
     <dimen name="pie_sysinfo_radius">165dp</dimen>
     <dimen name="pie_sysinfo_height">85sp</dimen>
+
+    <dimen name="halo_content_max_width">250dp</dimen>
+
 </resources>
diff --git a/packages/SystemUI/res/values/strings.xml b/packages/SystemUI/res/values/strings.xml
index f3db062..0c3568e 100644
--- a/packages/SystemUI/res/values/strings.xml
+++ b/packages/SystemUI/res/values/strings.xml
@@ -426,6 +426,9 @@
     <!-- Notification text: when GPS has found a fix [CHAR LIMIT=50] -->
     <string name="gps_notification_found_text">Location set by GPS</string>
 
+    <!-- Content description of the halo button in the notification panel for accessibility (not shown on the screen). [CHAR LIMIT=NONE] -->
+    <string name="accessibility_halo">Create notification halo.</string>
+
     <!-- Content description of the clear button in the notification panel for accessibility (not shown on the screen). [CHAR LIMIT=NONE] -->
     <string name="accessibility_clear_all">Clear all notifications.</string>
 
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/BaseStatusBar.java b/packages/SystemUI/src/com/android/systemui/statusbar/BaseStatusBar.java
index 46cbf29..53573ab 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/BaseStatusBar.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/BaseStatusBar.java
@@ -50,7 +50,12 @@ import android.content.res.Configuration;
 import android.content.res.Resources;
 import android.database.ContentObserver;
 import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
 import android.graphics.Paint;
+import android.graphics.PorterDuff.Mode;
+import android.graphics.PorterDuffXfermode;
 import android.graphics.Rect;
 import android.net.Uri;
 import android.os.Build;
@@ -61,7 +66,6 @@ import android.os.RemoteException;
 import android.os.ServiceManager;
 import android.os.UserHandle;
 import android.provider.Settings;
-import android.service.pie.PieManager;
 import android.text.TextUtils;
 import android.util.DisplayMetrics;
 import android.util.Log;
@@ -83,6 +87,13 @@ import android.widget.PopupMenu;
 import android.widget.RemoteViews;
 import android.widget.TextView;
 
+import com.android.systemui.statusbar.halo.Halo;
+import com.android.systemui.statusbar.phone.QuickSettingsContainerView;
+import com.android.systemui.statusbar.phone.Ticker;
+import com.android.systemui.statusbar.policy.BatteryController;
+import com.android.systemui.statusbar.policy.Clock;
+import com.android.systemui.statusbar.policy.NetworkController;
+
 import java.util.ArrayList;
 
 public abstract class BaseStatusBar extends SystemUI implements
@@ -156,6 +167,26 @@ public abstract class BaseStatusBar extends SystemUI implements
     private ArrayList<NavigationBarCallback> mNavigationCallbacks =
             new ArrayList<NavigationBarCallback>();
 
+    // Halo
+    protected Halo mHalo = null;
+    protected Ticker mTicker;
+    protected boolean mHaloActive;
+    protected boolean mHaloTaskerActive = false;
+    protected ImageView mHaloButton;
+    protected boolean mHaloButtonVisible = true;
+
+    // Policy
+    public NetworkController mNetworkController;
+    public BatteryController mBatteryController;
+    public SignalClusterView mSignalCluster;
+    public Clock mClock;
+
+    // left-hand icons 
+    public LinearLayout mStatusIcons;
+
+    // Statusbar view container
+    public ViewGroup mBarView;
+
     // Pie Control
     protected PieController mPieController;
 
@@ -175,6 +206,34 @@ public abstract class BaseStatusBar extends SystemUI implements
 
     private boolean mShowNotificationCounts;
 
+    public Ticker getTicker() {
+        return mTicker;
+    }
+
+    public void collapse() {
+    }
+
+    public QuickSettingsContainerView getQuickSettingsPanel() {
+        // This method should be overriden
+        return null;
+    }
+
+    public Handler getHandler() {
+        return mHandler;
+    }
+
+    public IStatusBarService getService() {
+        return mBarService;
+    }
+
+    public NotificationData getNotificationData() {
+        return mNotificationData;
+    }
+
+    public NotificationRowLayout getNotificationRowLayout() {
+        return mPile;
+    }
+
     public IStatusBarService getStatusBarService() {
         return mBarService;
     }
@@ -260,6 +319,9 @@ public abstract class BaseStatusBar extends SystemUI implements
             // If the system process isn't there we're doomed anyway.
         }
 
+        mHaloActive = Settings.System.getInt(mContext.getContentResolver(),
+                Settings.System.HALO_ACTIVE, 0) == 1;
+
         createAndAddWindows();
 
         disable(switches[0]);
@@ -315,13 +377,54 @@ public abstract class BaseStatusBar extends SystemUI implements
                     if (true) Slog.v(TAG, "userId " + mCurrentUserId + " is in the house");
                     userSwitched(mCurrentUserId);
                 }
-            }
-        }, filter);
+            }}, filter);
+
+        // Listen for HALO state
+        mContext.getContentResolver().registerContentObserver(
+                Settings.System.getUriFor(Settings.System.HALO_ACTIVE), false, new ContentObserver(new Handler()) {
+            @Override
+            public void onChange(boolean selfChange) {
+                updateHalo();
+            }});
+
+        updateHalo();
+    }
+
+    public void setHaloTaskerActive(boolean haloTaskerActive, boolean updateNotificationIcons) {
+        mHaloTaskerActive = haloTaskerActive;
+        if (updateNotificationIcons) {
+            updateNotificationIcons();
+        }
+    }
+
+    protected void updateHaloButton() {
+        if (mHaloButton != null) {
+            mHaloButton.setVisibility(mHaloButtonVisible && !mHaloActive ? View.VISIBLE : View.GONE);
+        }
+    }
 
-        if (PieManager.getInstance().isPresent()) {
-            mPieController = new PieController(mContext);
-            mPieController.attachStatusBar(this);
-            addNavigationBarCallback(mPieController);
+    protected void updateHalo() {
+        mHaloActive = Settings.System.getInt(mContext.getContentResolver(),
+                Settings.System.HALO_ACTIVE, 0) == 1;
+
+        updateHaloButton();
+
+        if (mHaloActive) {
+            if (mHalo == null) {
+                LayoutInflater inflater = (LayoutInflater) mContext
+                        .getSystemService(Context.LAYOUT_INFLATER_SERVICE); 
+                mHalo = (Halo)inflater.inflate(R.layout.halo_trigger, null);
+                mHalo.setLayerType (View.LAYER_TYPE_HARDWARE, null);
+                WindowManager.LayoutParams params = mHalo.getWMParams();
+                mWindowManager.addView(mHalo,params);
+                mHalo.setStatusBar(this);
+            }
+        } else {
+            if (mHalo != null) {
+                mHalo.cleanUp();
+                mWindowManager.removeView(mHalo);
+                mHalo = null;
+            }
         }
     }
 
@@ -843,11 +946,12 @@ public abstract class BaseStatusBar extends SystemUI implements
         return new NotificationClicker(intent, pkg, tag, id);
     }
 
-    private class NotificationClicker implements View.OnClickListener {
-        private PendingIntent mIntent;
-        private String mPkg;
-        private String mTag;
-        private int mId;
+    public class NotificationClicker implements View.OnClickListener {
+        public PendingIntent mIntent;
+        public String mPkg;
+        public String mTag;
+        public int mId;
+        public boolean mFloat;
 
         NotificationClicker(PendingIntent intent, String pkg, String tag, int id) {
             mIntent = intent;
@@ -856,6 +960,10 @@ public abstract class BaseStatusBar extends SystemUI implements
             mId = id;
         }
 
+        public void makeFloating(boolean floating) {
+            mFloat = floating;
+        }
+
         public void onClick(View v) {
             try {
                 // The intent we are sending is for the application, which
@@ -870,9 +978,17 @@ public abstract class BaseStatusBar extends SystemUI implements
             }
 
             if (mIntent != null) {
+
+                if (mFloat && !"android".equals(mPkg) && !"com.paranoid.halo".equals(mPkg)) {
+                    Intent transparent = new Intent(mContext, com.android.systemui.Transparent.class);
+                    transparent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_FLOATING_WINDOW);
+                    mContext.startActivity(transparent);
+                }
+
                 int[] pos = new int[2];
                 v.getLocationOnScreen(pos);
                 Intent overlay = new Intent();
+                if (mFloat) overlay.addFlags(Intent.FLAG_FLOATING_WINDOW | Intent.FLAG_ACTIVITY_CLEAR_TASK);
                 overlay.setSourceBounds(
                         new Rect(pos[0], pos[1], pos[0]+v.getWidth(), pos[1]+v.getHeight()));
                 try {
@@ -955,6 +1071,41 @@ public abstract class BaseStatusBar extends SystemUI implements
         return entry.notification;
     }
 
+    private Bitmap createRoundIcon(StatusBarNotification notification) {
+        // Construct the round icon
+        BitmapDrawable bd = (BitmapDrawable) mContext.getResources().getDrawable(R.drawable.halo_bg);
+        int iconSize = bd.getBitmap().getWidth();
+        int smallIconSize = mContext.getResources().getDimensionPixelSize(R.dimen.status_bar_icon_size);        
+        Bitmap roundIcon = Bitmap.createBitmap(iconSize, iconSize, Bitmap.Config.ARGB_8888);
+        Canvas canvas = new Canvas(roundIcon);
+        canvas.drawARGB(0, 0, 0, 0);
+
+        if (notification.notification.largeIcon != null) {           
+            Paint smoothingPaint = new Paint();
+            smoothingPaint.setAntiAlias(true);
+            smoothingPaint.setFilterBitmap(true);
+            smoothingPaint.setDither(true);
+            canvas.drawCircle(iconSize / 2, iconSize / 2, iconSize / 2.3f, smoothingPaint);
+            smoothingPaint.setXfermode(new PorterDuffXfermode(Mode.SRC_IN));
+            Bitmap scaledBitmap = Bitmap.createScaledBitmap(notification.notification.largeIcon, iconSize, iconSize, true);
+            canvas.drawBitmap(scaledBitmap, null, new Rect(0, 0,
+                    iconSize, iconSize), smoothingPaint);
+        } else {
+            try {
+                Drawable icon = StatusBarIconView.getIcon(mContext,
+                    new StatusBarIcon(notification.pkg, notification.user, notification.notification.icon,
+                    notification.notification.iconLevel, 0, notification.notification.tickerText)); 
+                if (icon == null) icon = mContext.getPackageManager().getApplicationIcon(notification.pkg);
+                int margin = (iconSize - smallIconSize) / 2;
+                icon.setBounds(margin, margin, iconSize - margin, iconSize - margin);
+                icon.draw(canvas);
+            } catch (Exception e) {
+                // NameNotFoundException
+            }
+        }
+        return roundIcon;
+    }
+
     protected StatusBarIconView addNotificationViews(IBinder key,
             StatusBarNotification notification) {
         if (DEBUG) {
@@ -976,8 +1127,19 @@ public abstract class BaseStatusBar extends SystemUI implements
             handleNotificationError(key, notification, "Couldn't create icon: " + ic);
             return null;
         }
+
+        NotificationData.Entry entry = new NotificationData.Entry(key, notification, iconView,
+                createRoundIcon(notification));
+        entry.hide = entry.notification.pkg.equals("com.paranoid.halo");
+
+        final PendingIntent contentIntent = notification.notification.contentIntent;
+        if (contentIntent != null) {
+            entry.floatingIntent = makeClicker(contentIntent,
+                    notification.pkg, notification.tag, notification.id);
+            entry.floatingIntent.makeFloating(true);
+        }
+
         // Construct the expanded view.
-        NotificationData.Entry entry = new NotificationData.Entry(key, notification, iconView);
         if (!inflateViews(entry, mPile)) {
             handleNotificationError(key, notification, "Couldn't expand RemoteViews for: "
                     + notification);
@@ -1007,6 +1169,7 @@ public abstract class BaseStatusBar extends SystemUI implements
             lp.height = rowHeight;
         }
         entry.row.setLayoutParams(lp);
+        if (entry.hide) entry.row.setVisibility(View.GONE);
         return expand;
     }
 
@@ -1095,10 +1258,10 @@ public abstract class BaseStatusBar extends SystemUI implements
         boolean orderUnchanged = notification.notification.when==oldNotification.notification.when
                 && notification.score == oldNotification.score;
                 // score now encompasses/supersedes isOngoing()
-
-        boolean updateTicker = notification.notification.tickerText != null
+        
+        boolean updateTicker = (notification.notification.tickerText != null
                 && !TextUtils.equals(notification.notification.tickerText,
-                        oldEntry.notification.notification.tickerText);
+                        oldEntry.notification.notification.tickerText)) || mHaloActive;
         boolean isTopAnyway = isTopNotification(rowParent, oldEntry);
         if (contentsUnchanged && bigContentsUnchanged && (orderUnchanged || isTopAnyway)) {
             if (DEBUG) Slog.d(TAG, "reusing notification for key: " + key);
@@ -1109,15 +1272,22 @@ public abstract class BaseStatusBar extends SystemUI implements
                 if (bigContentView != null && oldEntry.getLargeView() != null) {
                     bigContentView.reapply(mContext, oldEntry.getLargeView(), mOnClickHandler);
                 }
-                // update the contentIntent
+                // update contentIntent and floatingIntent
                 final PendingIntent contentIntent = notification.notification.contentIntent;
                 if (contentIntent != null) {
                     final View.OnClickListener listener = makeClicker(contentIntent,
                             notification.pkg, notification.tag, notification.id);
                     oldEntry.content.setOnClickListener(listener);
+                    oldEntry.floatingIntent = makeClicker(contentIntent,
+                            notification.pkg, notification.tag, notification.id);
+                    oldEntry.floatingIntent.makeFloating(true);
                 } else {
                     oldEntry.content.setOnClickListener(null);
+                    oldEntry.floatingIntent = null;
                 }
+                // Update the roundIcon
+                oldEntry.roundIcon = createRoundIcon(notification);
+
                 // Update the icon.
                 final StatusBarIcon ic = new StatusBarIcon(notification.pkg,
                         notification.user,
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/NotificationData.java b/packages/SystemUI/src/com/android/systemui/statusbar/NotificationData.java
index 7222c08..8de7b08 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/NotificationData.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/NotificationData.java
@@ -17,10 +17,12 @@
 package com.android.systemui.statusbar;
 
 import android.app.Notification;
+import android.graphics.Bitmap;
 import android.os.IBinder;
 import android.view.View;
 import android.widget.ImageView;
 
+import com.android.systemui.statusbar.BaseStatusBar.NotificationClicker;
 import com.android.internal.statusbar.StatusBarNotification;
 import com.android.systemui.R;
 
@@ -39,13 +41,22 @@ public class NotificationData {
         public View content; // takes the click events and sends the PendingIntent
         public View expanded; // the inflated RemoteViews
         public ImageView largeIcon;
+        protected boolean hide = false;
+        protected Bitmap roundIcon;
         protected View expandedLarge;
+        protected NotificationClicker floatingIntent;
         public Entry() {}
         public Entry(IBinder key, StatusBarNotification n, StatusBarIconView ic) {
             this.key = key;
             this.notification = n;
             this.icon = ic;
         }
+        public Entry(IBinder key, StatusBarNotification n, StatusBarIconView ic, Bitmap ri) {
+            this.key = key;
+            this.notification = n;
+            this.icon = ic;
+            this.roundIcon = ri;
+        }
         public void setLargeView(View expandedLarge) {
             this.expandedLarge = expandedLarge;
             writeBooleanTag(row, R.id.expandable_tag, expandedLarge != null);
@@ -53,6 +64,12 @@ public class NotificationData {
         public View getLargeView() {
             return expandedLarge;
         }
+        public NotificationClicker getFloatingIntent() {
+            return floatingIntent;
+        }
+        public Bitmap getRoundIcon() {
+            return roundIcon;
+        }
         /**
          * Return whether the entry can be expanded.
          */
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java
index 1c21f22..e729cf8 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java
@@ -261,7 +261,6 @@ public class PhoneStatusBar extends BaseStatusBar {
     PowerWidget mPowerWidget;
 
     // ticker
-    private Ticker mTicker;
     private View mTickerView;
     private boolean mTicking;
 
@@ -383,6 +382,10 @@ public class PhoneStatusBar extends BaseStatusBar {
             if (mSettingsButton != null && mHasFlipSettings) {
                 mSettingsButton.setVisibility(userSetup ? View.VISIBLE : View.INVISIBLE);
             }
+            if (mHaloButton != null && mHasFlipSettings) {
+                mHaloButtonVisible = userSetup;
+                updateHaloButton();
+            }
             if (mSettingsPanel != null) {
                 mSettingsPanel.setEnabled(userSetup);
             }
@@ -524,7 +527,7 @@ public class PhoneStatusBar extends BaseStatusBar {
         mClearButton = mStatusBarWindow.findViewById(R.id.clear_all_button);
         mClearButton.setOnClickListener(mClearButtonListener);
         mClearButton.setAlpha(0f);
-        mClearButton.setVisibility(View.INVISIBLE);
+        mClearButton.setVisibility(View.GONE);
         mClearButton.setEnabled(false);
         mDateView = (DateView)mStatusBarWindow.findViewById(R.id.date);
 
@@ -559,6 +562,14 @@ public class PhoneStatusBar extends BaseStatusBar {
                 mSettingsButton.setImageResource(R.drawable.ic_notify_settings);
             }
         }
+
+        mHaloButton = (ImageView) mStatusBarWindow.findViewById(R.id.halo_button);
+        if (mHaloButton != null) {
+            mHaloButton.setOnClickListener(mHaloButtonListener);
+            mHaloButtonVisible = true;
+            updateHaloButton();
+        }
+
         if (mHasFlipSettings) {
             mNotificationButton = (ImageView) mStatusBarWindow.findViewById(R.id.notification_button);
             if (mNotificationButton != null) {
@@ -597,6 +608,7 @@ public class PhoneStatusBar extends BaseStatusBar {
         mTicker = new MyTicker(context, mStatusBarView);
         TickerView tickerView = (TickerView)mStatusBarView.findViewById(R.id.tickerText);
         tickerView.mTicker = mTicker;
+        if (mHaloActive) mTickerView.setVisibility(View.GONE);
 
         mEdgeBorder = res.getDimensionPixelSize(R.dimen.status_bar_edge_ignore);
 
@@ -1162,6 +1174,9 @@ public class PhoneStatusBar extends BaseStatusBar {
         if (mSettingsButton != null) {
             mSettingsButton.setEnabled(isDeviceProvisioned());
         }
+        if (mHaloButton != null) {
+            mHaloButton.setEnabled(isDeviceProvisioned());
+        }
     }
 
     @Override
@@ -1186,7 +1201,7 @@ public class PhoneStatusBar extends BaseStatusBar {
         for (int i=0; i<N; i++) {
             Entry ent = mNotificationData.get(N-i-1);
             if (!((provisioned && ent.notification.score >= HIDE_ICONS_BELOW_SCORE)
-                    || showNotificationEvenIfUnprovisioned(ent.notification))) continue;
+                    || showNotificationEvenIfUnprovisioned(ent.notification) || mHaloTaskerActive)) continue;
             if (!notificationIsForCurrentUser(ent.notification)) continue;
             toShow.add(ent.icon);
         }
@@ -1269,7 +1284,7 @@ public class PhoneStatusBar extends BaseStatusBar {
                 && mFlipSettingsView.getVisibility() == View.VISIBLE
                 && mScrollView.getVisibility() != View.VISIBLE) {
             // the flip settings panel is unequivocally showing; we should not be shown
-            mClearButton.setVisibility(View.INVISIBLE);
+            mClearButton.setVisibility(View.GONE);
         } else if (mClearButton.isShown()) {
             if (clearable != (mClearButton.getAlpha() == 1.0f)) {
                 ObjectAnimator clearAnimation = ObjectAnimator.ofFloat(
@@ -1293,7 +1308,7 @@ public class PhoneStatusBar extends BaseStatusBar {
             }
         } else {
             mClearButton.setAlpha(clearable ? 1.0f : 0.0f);
-            mClearButton.setVisibility(clearable ? View.VISIBLE : View.INVISIBLE);
+            mClearButton.setVisibility(clearable ? View.VISIBLE : View.GONE);
         }
         mClearButton.setEnabled(clearable);
 
@@ -1600,7 +1615,7 @@ public class PhoneStatusBar extends BaseStatusBar {
     final int FLIP_DURATION = (FLIP_DURATION_IN + FLIP_DURATION_OUT);
 
     Animator mScrollViewAnim, mFlipSettingsViewAnim, mNotificationButtonAnim,
-        mSettingsButtonAnim, mClearButtonAnim;
+        mSettingsButtonAnim, mHaloButtonAnim, mClearButtonAnim;
 
     @Override
     public void animateExpandNotificationsPanel() {
@@ -1626,6 +1641,7 @@ public class PhoneStatusBar extends BaseStatusBar {
         if (mFlipSettingsViewAnim != null) mFlipSettingsViewAnim.cancel();
         if (mScrollViewAnim != null) mScrollViewAnim.cancel();
         if (mSettingsButtonAnim != null) mSettingsButtonAnim.cancel();
+        if (mHaloButtonAnim != null) mHaloButtonAnim.cancel();
         if (mNotificationButtonAnim != null) mNotificationButtonAnim.cancel();
         if (mClearButtonAnim != null) mClearButtonAnim.cancel();
 
@@ -1663,6 +1679,11 @@ public class PhoneStatusBar extends BaseStatusBar {
         mSettingsButtonAnim = start(
             ObjectAnimator.ofFloat(mSettingsButton, View.ALPHA, 1f)
                 .setDuration(FLIP_DURATION));
+        mHaloButtonVisible = true;
+        updateHaloButton();
+        mHaloButtonAnim = start(
+            ObjectAnimator.ofFloat(mHaloButton, View.ALPHA, 1f)
+                .setDuration(FLIP_DURATION));
         mClearButton.setVisibility(View.VISIBLE);
         mClearButton.setAlpha(0f);
         setAreThereNotifications(); // this will show/hide the button as necessary
@@ -1708,6 +1729,8 @@ public class PhoneStatusBar extends BaseStatusBar {
         mFlipSettingsView.setScaleX(1f);
         mFlipSettingsView.setVisibility(View.VISIBLE);
         mSettingsButton.setVisibility(View.GONE);
+        mHaloButtonVisible = false;
+        updateHaloButton();
         mScrollView.setVisibility(View.GONE);
         mScrollView.setScaleX(0f);
         mPowerWidget.setVisibility(View.GONE);
@@ -1767,6 +1790,7 @@ public class PhoneStatusBar extends BaseStatusBar {
         if (mFlipSettingsViewAnim != null) mFlipSettingsViewAnim.cancel();
         if (mScrollViewAnim != null) mScrollViewAnim.cancel();
         if (mSettingsButtonAnim != null) mSettingsButtonAnim.cancel();
+        if (mHaloButtonAnim != null) mHaloButtonAnim.cancel();
         if (mNotificationButtonAnim != null) mNotificationButtonAnim.cancel();
         if (mClearButtonAnim != null) mClearButtonAnim.cancel();
 
@@ -1798,6 +1822,11 @@ public class PhoneStatusBar extends BaseStatusBar {
                     .setDuration(FLIP_DURATION),
                     mScrollView, View.INVISIBLE));
         mPowerWidget.setVisibility(View.GONE);
+        mHaloButtonAnim = start(
+            setVisibilityWhenDone(
+                ObjectAnimator.ofFloat(mHaloButton, View.ALPHA, 0f)
+                    .setDuration(FLIP_DURATION),
+                    mScrollView, View.INVISIBLE));
         mNotificationButton.setVisibility(View.VISIBLE);
         mNotificationButtonAnim = start(
             ObjectAnimator.ofFloat(mNotificationButton, View.ALPHA, 1f)
@@ -1850,6 +1879,7 @@ public class PhoneStatusBar extends BaseStatusBar {
             if (mFlipSettingsViewAnim != null) mFlipSettingsViewAnim.cancel();
             if (mScrollViewAnim != null) mScrollViewAnim.cancel();
             if (mSettingsButtonAnim != null) mSettingsButtonAnim.cancel();
+            if (mHaloButtonAnim != null) mHaloButtonAnim.cancel();
             if (mNotificationButtonAnim != null) mNotificationButtonAnim.cancel();
             if (mClearButtonAnim != null) mClearButtonAnim.cancel();
 
@@ -1858,6 +1888,9 @@ public class PhoneStatusBar extends BaseStatusBar {
             mPowerWidget.updateVisibility();
             mSettingsButton.setAlpha(1f);
             mSettingsButton.setVisibility(View.VISIBLE);
+            mHaloButton.setAlpha(1f);
+            mHaloButtonVisible = true;
+            updateHaloButton();
             mNotificationPanel.setVisibility(View.GONE);
             mFlipSettingsView.setVisibility(View.GONE);
             mNotificationButton.setVisibility(View.GONE);
@@ -2282,8 +2315,8 @@ public class PhoneStatusBar extends BaseStatusBar {
 
     @Override
     protected void tick(IBinder key, StatusBarNotification n, boolean firstTime) {
-        // no ticking in lights-out mode
-        if (!areLightsOn()) return;
+        // no ticking in lights-out mode, except if halo is active
+        if (!areLightsOn() && !mHaloActive) return;
 
         // no ticking in Setup
         if (!isDeviceProvisioned()) return;
@@ -2295,7 +2328,8 @@ public class PhoneStatusBar extends BaseStatusBar {
         // until status bar window is attached to the window manager,
         // because...  well, what's the point otherwise?  And trying to
         // run a ticker without being attached will crash!
-        if (n.notification.tickerText != null && mStatusBarContainer.getWindowToken() != null) {
+        if (n.notification.tickerText != null && mStatusBarContainer.getWindowToken() != null
+                && !mHaloActive) {
             if (0 == (mDisabled & (StatusBarManager.DISABLE_NOTIFICATION_ICONS
                             | StatusBarManager.DISABLE_NOTIFICATION_TICKER))) {
                 mTicker.addEntry(n);
@@ -2311,27 +2345,33 @@ public class PhoneStatusBar extends BaseStatusBar {
         @Override
         public void tickerStarting() {
             mTicking = true;
-            mStatusBarContents.setVisibility(View.GONE);
-            mTickerView.setVisibility(View.VISIBLE);
-            mTickerView.startAnimation(loadAnim(com.android.internal.R.anim.push_up_in, null));
-            mStatusBarContents.startAnimation(loadAnim(com.android.internal.R.anim.push_up_out, null));
+            if (!mHaloActive) {
+                mStatusBarContents.setVisibility(View.GONE);
+                mTickerView.setVisibility(View.VISIBLE);
+                mTickerView.startAnimation(loadAnim(com.android.internal.R.anim.push_up_in, null));
+                mStatusBarContents.startAnimation(loadAnim(com.android.internal.R.anim.push_up_out, null));
+            }
         }
 
         @Override
         public void tickerDone() {
-            mStatusBarContents.setVisibility(View.VISIBLE);
-            mTickerView.setVisibility(View.GONE);
-            mStatusBarContents.startAnimation(loadAnim(com.android.internal.R.anim.push_down_in, null));
-            mTickerView.startAnimation(loadAnim(com.android.internal.R.anim.push_down_out,
-                        mTickingDoneListener));
+            if (!mHaloActive) {
+                mStatusBarContents.setVisibility(View.VISIBLE);
+                mTickerView.setVisibility(View.GONE);
+                mStatusBarContents.startAnimation(loadAnim(com.android.internal.R.anim.push_down_in, null));
+                mTickerView.startAnimation(loadAnim(com.android.internal.R.anim.push_down_out,
+                            mTickingDoneListener));
+            }
         }
 
         @Override
         public void tickerHalting() {
-            mStatusBarContents.setVisibility(View.VISIBLE);
-            mTickerView.setVisibility(View.GONE);
-            mStatusBarContents.startAnimation(loadAnim(com.android.internal.R.anim.fade_in, null));
-            // we do not animate the ticker away at this point, just get rid of it (b/6992707)
+            if (!mHaloActive) {
+                mStatusBarContents.setVisibility(View.VISIBLE);
+                mTickerView.setVisibility(View.GONE);
+                mStatusBarContents.startAnimation(loadAnim(com.android.internal.R.anim.fade_in, null));
+                // we do not animate the ticker away at this point, just get rid of it (b/6992707)
+            }
         }
     }
 
@@ -2625,6 +2665,18 @@ public class PhoneStatusBar extends BaseStatusBar {
         }
     };
 
+    private View.OnClickListener mHaloButtonListener = new View.OnClickListener() {
+        public void onClick(View v) {
+            // Activate HALO
+            Settings.System.putInt(mContext.getContentResolver(),
+                    Settings.System.HALO_ACTIVE, 1);
+            // Switch off regular ticker
+            mTickerView.setVisibility(View.GONE);
+            // Collapse
+            animateCollapsePanels();
+        }
+    };
+
     private final View.OnClickListener mClockClickListener = new View.OnClickListener() {
         @Override
         public void onClick(View v) {
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/Ticker.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/Ticker.java
index ecc70d6..1e1b014 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/Ticker.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/Ticker.java
@@ -52,6 +52,16 @@ public abstract class Ticker {
     private ImageSwitcher mIconSwitcher;
     private TextSwitcher mTextSwitcher;
     private float mIconScale;
+    private TickerCallback mEvent;
+
+    public interface TickerCallback  
+    {  
+        public void updateTicker(StatusBarNotification notification, String text);
+    }  
+
+    public void setUpdateEvent(TickerCallback event) {
+        mEvent = event;
+    }
 
     public static boolean isGraphicOrEmoji(char c) {
         int gc = Character.getType(c);
@@ -63,21 +73,21 @@ public abstract class Ticker {
                 && gc != Character.SPACE_SEPARATOR;
     }
 
-    private final class Segment {
-        StatusBarNotification notification;
-        Drawable icon;
-        CharSequence text;
-        int current;
-        int next;
-        boolean first;
+    public final class Segment {
+        public StatusBarNotification notification;
+        public Drawable icon;
+        public CharSequence text;
+        public int current;
+        public int next;
+        public boolean first;
 
-        StaticLayout getLayout(CharSequence substr) {
+        public StaticLayout getLayout(CharSequence substr) {
             int w = mTextSwitcher.getWidth() - mTextSwitcher.getPaddingLeft()
                     - mTextSwitcher.getPaddingRight();
             return new StaticLayout(substr, mPaint, w, Alignment.ALIGN_NORMAL, 1, 0, true);
         }
 
-        CharSequence rtrim(CharSequence substr, int start, int end) {
+        public CharSequence rtrim(CharSequence substr, int start, int end) {
             while (end > start && !isGraphicOrEmoji(substr.charAt(end-1))) {
                 end--;
             }
@@ -88,7 +98,7 @@ public abstract class Ticker {
         }
 
         /** returns null if there is no more text */
-        CharSequence getText() {
+        public CharSequence getText() {
             if (this.current > this.text.length()) {
                 return null;
             }
@@ -107,7 +117,7 @@ public abstract class Ticker {
         }
 
         /** returns null if there is no more text */
-        CharSequence advance() {
+        public CharSequence advance() {
             this.first = false;
             int index = this.next;
             final int len = this.text.length();
@@ -140,7 +150,7 @@ public abstract class Ticker {
             return null;
         }
 
-        Segment(StatusBarNotification n, Drawable icon, CharSequence text) {
+        public Segment(StatusBarNotification n, Drawable icon, CharSequence text) {
             this.notification = n;
             this.icon = icon;
             this.text = text;
@@ -217,19 +227,24 @@ public abstract class Ticker {
         }
 
         mSegments.add(newSegment);
-
+        if (mEvent != null) {
+            if (newSegment != null) {
+                mEvent.updateTicker(newSegment.notification, text.toString());
+            }
+        }
+        
         if (initialCount == 0 && mSegments.size() > 0) {
             Segment seg = mSegments.get(0);
             seg.first = false;
-            
+
             mIconSwitcher.setAnimateFirstView(false);
             mIconSwitcher.reset();
             mIconSwitcher.setImageDrawable(seg.icon);
-            
+
             mTextSwitcher.setAnimateFirstView(false);
             mTextSwitcher.reset();
             mTextSwitcher.setText(seg.getText());
-            
+
             tickerStarting();
             scheduleAdvance();
         }
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/policy/DateView.java b/packages/SystemUI/src/com/android/systemui/statusbar/policy/DateView.java
index 26b1eb2..faf9fb2 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/policy/DateView.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/policy/DateView.java
@@ -54,7 +54,8 @@ public class DateView extends TextView implements OnClickListener, OnLongClickLi
             final String action = intent.getAction();
             if (Intent.ACTION_TIME_TICK.equals(action)
                     || Intent.ACTION_TIME_CHANGED.equals(action)
-                    || Intent.ACTION_TIMEZONE_CHANGED.equals(action)) {
+                    || Intent.ACTION_TIMEZONE_CHANGED.equals(action)
+                    || Intent.ACTION_LOCALE_CHANGED.equals(action)) {
                 updateClock();
             }
         }
@@ -145,6 +146,7 @@ public class DateView extends TextView implements OnClickListener, OnLongClickLi
                 filter.addAction(Intent.ACTION_TIME_TICK);
                 filter.addAction(Intent.ACTION_TIME_CHANGED);
                 filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
+                filter.addAction(Intent.ACTION_LOCALE_CHANGED);
                 mContext.registerReceiver(mIntentReceiver, filter, null, null);
                 updateClock();
             } else {
diff --git a/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java b/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
index f620c6d..eb670fc 100644
--- a/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
+++ b/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
@@ -914,21 +914,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
     private final Runnable mRingerChordLongPress = new Runnable() {
         public void run() {
-            // Do the switch
-            final AudioManager am = (AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE);
-            final int ringerMode = am.getRingerMode();
-            final VolumePanel volumePanel = new VolumePanel(ThemeUtils.createUiContext(mContext),
-                                                              (AudioService) getAudioService());
-            if (ringerMode == AudioManager.RINGER_MODE_NORMAL) {
-                boolean vibrateSetting = Settings.System.getIntForUser(mContext.getContentResolver(),
-                        Settings.System.VIBRATE_WHEN_RINGING, 0, UserHandle.USER_CURRENT) != 0;
-                am.setRingerMode(vibrateSetting ? AudioManager.RINGER_MODE_VIBRATE :
-                                   AudioManager.RINGER_MODE_SILENT);
-            } else {
-                am.setRingerMode(AudioManager.RINGER_MODE_NORMAL);
-            }
-            volumePanel.postVolumeChanged(AudioManager.STREAM_RING,AudioManager.FLAG_SHOW_UI
-                                          | AudioManager.FLAG_VIBRATE);
+            mContext.sendBroadcast(new Intent("com.lge.QuickClip.action.START_QUICKCLIP"));
         }
     };
 
@@ -2185,8 +2171,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
         if (DEBUG_INPUT) {
             Log.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount="
-                    + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed
-                    + " canceled=" + canceled);
+                    + repeatCount + " keyguardOn=" + keyguardOn + " canceled=" + canceled);
         }
 
         // If we think we might have a volume down & power/volume-up key chord on the way
@@ -5402,7 +5387,6 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 pw.println(mForceStatusBarFromKeyguard);
         pw.print(prefix); pw.print("mDismissKeyguard="); pw.print(mDismissKeyguard);
                 pw.print(" mWinDismissingKeyguard="); pw.print(mWinDismissingKeyguard);
-                pw.print(" mHomePressed="); pw.println(mHomePressed);
         pw.print(prefix); pw.print("mAllowLockscreenWhenOn="); pw.print(mAllowLockscreenWhenOn);
                 pw.print(" mLockScreenTimeout="); pw.print(mLockScreenTimeout);
                 pw.print(" mLockScreenTimerActive="); pw.println(mLockScreenTimerActive);
diff --git a/policy/src/com/android/internal/policy/impl/keyguard/KeyguardAbsKeyInputView.java b/policy/src/com/android/internal/policy/impl/keyguard/KeyguardAbsKeyInputView.java
index 46dfc34..ee8f851 100644
--- a/policy/src/com/android/internal/policy/impl/keyguard/KeyguardAbsKeyInputView.java
+++ b/policy/src/com/android/internal/policy/impl/keyguard/KeyguardAbsKeyInputView.java
@@ -94,6 +94,7 @@ public abstract class KeyguardAbsKeyInputView extends LinearLayout
 
     protected abstract int getPasswordTextViewId();
     protected abstract void resetState();
+    protected abstract boolean getQuickUnlockAllowed();
 
     @Override
     protected void onFinishInflate() {
diff --git a/policy/src/com/android/internal/policy/impl/keyguard/KeyguardPINView.java b/policy/src/com/android/internal/policy/impl/keyguard/KeyguardPINView.java
index fa80352..82cb9b5 100644
--- a/policy/src/com/android/internal/policy/impl/keyguard/KeyguardPINView.java
+++ b/policy/src/com/android/internal/policy/impl/keyguard/KeyguardPINView.java
@@ -56,6 +56,11 @@ public class KeyguardPINView extends KeyguardAbsKeyInputView
     }
 
     @Override
+    protected boolean getQuickUnlockAllowed() {
+        return true;
+    }
+
+    @Override
     protected void onFinishInflate() {
         super.onFinishInflate();
 
diff --git a/policy/src/com/android/internal/policy/impl/keyguard/KeyguardPasswordView.java b/policy/src/com/android/internal/policy/impl/keyguard/KeyguardPasswordView.java
index d52c993..1dd129a 100644
--- a/policy/src/com/android/internal/policy/impl/keyguard/KeyguardPasswordView.java
+++ b/policy/src/com/android/internal/policy/impl/keyguard/KeyguardPasswordView.java
@@ -69,6 +69,11 @@ public class KeyguardPasswordView extends KeyguardAbsKeyInputView
     }
 
     @Override
+    protected boolean getQuickUnlockAllowed() {
+        return true;
+    }
+
+    @Override
     public boolean needsInput() {
         return true;
     }
diff --git a/policy/src/com/android/internal/policy/impl/keyguard/KeyguardSimPinView.java b/policy/src/com/android/internal/policy/impl/keyguard/KeyguardSimPinView.java
index ab364ee..fe10516 100644
--- a/policy/src/com/android/internal/policy/impl/keyguard/KeyguardSimPinView.java
+++ b/policy/src/com/android/internal/policy/impl/keyguard/KeyguardSimPinView.java
@@ -63,6 +63,11 @@ public class KeyguardSimPinView extends KeyguardAbsKeyInputView
     }
 
     @Override
+    protected boolean getQuickUnlockAllowed() {
+        return false;
+    }
+
+    @Override
     protected void onFinishInflate() {
         super.onFinishInflate();
 
diff --git a/policy/src/com/android/internal/policy/impl/keyguard/KeyguardSimPukView.java b/policy/src/com/android/internal/policy/impl/keyguard/KeyguardSimPukView.java
index e5b4b73..8ef6451 100644
--- a/policy/src/com/android/internal/policy/impl/keyguard/KeyguardSimPukView.java
+++ b/policy/src/com/android/internal/policy/impl/keyguard/KeyguardSimPukView.java
@@ -114,6 +114,11 @@ public class KeyguardSimPukView extends KeyguardAbsKeyInputView
     }
 
     @Override
+    protected boolean getQuickUnlockAllowed() {
+        return false;
+    }
+
+    @Override
     protected void onFinishInflate() {
         super.onFinishInflate();
 
diff --git a/preloaded-classes b/preloaded-classes
index 10c5c9e..90a767d 100644
--- a/preloaded-classes
+++ b/preloaded-classes
@@ -2,6 +2,19 @@
 # Automatically generated by frameworks/base/tools/preload/WritePreloadedClassFile.java.
 # MIN_LOAD_TIME_MICROS=1250
 # MIN_PROCESSES=10
+# BEGIN PRIVACY
+android.privacy.PrivacySettingsManagerService
+android.privacy.PrivacySettingsManager
+android.privacy.PrivacySettings
+android.privacy.PrivacyPersistenceAdapter
+android.privacy.IPrivacySettingsManager
+android.privacy.surrogate.PrivacyActivityManagerService
+android.privacy.surrogate.PrivacyCDMALTEPhone
+android.privacy.surrogate.PrivacyCDMAPhone
+android.privacy.surrogate.PrivacyGSMPhone
+android.privacy.surrogate.PrivacyPhoneProxy
+android.privacy.surrogate.PrivacySipPhone
+# END PRIVACY
 android.R$styleable
 android.accounts.Account
 android.accounts.Account$1
diff --git a/services/java/com/android/server/NotificationManagerService.java b/services/java/com/android/server/NotificationManagerService.java
index 06a8615..f82d955 100644
--- a/services/java/com/android/server/NotificationManagerService.java
+++ b/services/java/com/android/server/NotificationManagerService.java
@@ -175,67 +175,87 @@ public class NotificationManagerService extends INotificationManager.Stub
     private boolean mQuietHoursDim = true;
 
     // Notification control database. For now just contains disabled packages.
-    private AtomicFile mPolicyFile;
+    private AtomicFile mPolicyFile, mHaloPolicyFile;
     private HashSet<String> mBlockedPackages = new HashSet<String>();
+    private HashSet<String> mHaloBlacklist = new HashSet<String>();
+    private HashSet<String> mHaloWhitelist = new HashSet<String>();
+    private boolean mHaloPolicyisBlack = true;
 
     private static final int DB_VERSION = 1;
 
     private static final String TAG_BODY = "notification-policy";
     private static final String ATTR_VERSION = "version";
+    private static final String ATTR_HALO_POLICY_IS_BLACK = "policy_is_black";
 
+    private static final String TAG_ALLOWED_PKGS = "allowed-packages";
     private static final String TAG_BLOCKED_PKGS = "blocked-packages";
     private static final String TAG_PACKAGE = "package";
     private static final String ATTR_NAME = "name";
 
+    private int readPolicy(AtomicFile file, String lookUpTag, HashSet<String> db) {
+        return readPolicy(file, lookUpTag, db, null, 0);
+    }
+
+    private int readPolicy(AtomicFile file, String lookUpTag, HashSet<String> db, String resultTag, int defaultResult) {
+        int result = defaultResult;
+        FileInputStream infile = null;
+        try {
+            infile = file.openRead();
+            final XmlPullParser parser = Xml.newPullParser();
+            parser.setInput(infile, null);
+
+            int type;
+            String tag;
+            int version = DB_VERSION;
+            while ((type = parser.next()) != END_DOCUMENT) {
+                tag = parser.getName();
+                if (type == START_TAG) {
+                    if (TAG_BODY.equals(tag)) {
+                        version = Integer.parseInt(parser.getAttributeValue(null, ATTR_VERSION));
+                        if (resultTag != null) {
+                            String attribValue = parser.getAttributeValue(null, resultTag);
+                            result = Integer.parseInt((attribValue != null ? attribValue : "0"));
+                        }
+                    } else if (lookUpTag.equals(tag)) {
+                        while ((type = parser.next()) != END_DOCUMENT) {
+                            tag = parser.getName();
+                            if (TAG_PACKAGE.equals(tag)) {
+                                db.add(parser.getAttributeValue(null, ATTR_NAME));
+                            } else if (lookUpTag.equals(tag) && type == END_TAG) {
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+        } catch (Exception e) {
+            // Unable to read
+        } finally {
+            IoUtils.closeQuietly(infile);
+        }
+        return result;
+    }
+
     private void loadBlockDb() {
         synchronized(mBlockedPackages) {
             if (mPolicyFile == null) {
-                File dir = new File("/data/system");
-                mPolicyFile = new AtomicFile(new File(dir, "notification_policy.xml"));
-
+                mPolicyFile = new AtomicFile(new File("/data/system", "notification_policy.xml"));
                 mBlockedPackages.clear();
-
-                FileInputStream infile = null;
-                try {
-                    infile = mPolicyFile.openRead();
-                    final XmlPullParser parser = Xml.newPullParser();
-                    parser.setInput(infile, null);
-
-                    int type;
-                    String tag;
-                    int version = DB_VERSION;
-                    while ((type = parser.next()) != END_DOCUMENT) {
-                        tag = parser.getName();
-                        if (type == START_TAG) {
-                            if (TAG_BODY.equals(tag)) {
-                                version = Integer.parseInt(parser.getAttributeValue(null, ATTR_VERSION));
-                            } else if (TAG_BLOCKED_PKGS.equals(tag)) {
-                                while ((type = parser.next()) != END_DOCUMENT) {
-                                    tag = parser.getName();
-                                    if (TAG_PACKAGE.equals(tag)) {
-                                        mBlockedPackages.add(parser.getAttributeValue(null, ATTR_NAME));
-                                    } else if (TAG_BLOCKED_PKGS.equals(tag) && type == END_TAG) {
-                                        break;
-                                    }
-                                }
-                            }
-                        }
-                    }
-                } catch (FileNotFoundException e) {
-                    // No data yet
-                } catch (IOException e) {
-                    Log.wtf(TAG, "Unable to read blocked notifications database", e);
-                } catch (NumberFormatException e) {
-                    Log.wtf(TAG, "Unable to parse blocked notifications database", e);
-                } catch (XmlPullParserException e) {
-                    Log.wtf(TAG, "Unable to parse blocked notifications database", e);
-                } finally {
-                    IoUtils.closeQuietly(infile);
-                }
+                readPolicy(mPolicyFile, TAG_BLOCKED_PKGS, mBlockedPackages);
             }
         }
     }
 
+    private synchronized void loadHaloBlockDb() {
+        if (mHaloPolicyFile == null) {
+            mHaloPolicyFile = new AtomicFile(new File("/data/system", "halo_policy.xml"));
+            mHaloBlacklist.clear();
+            mHaloPolicyisBlack = readPolicy(mHaloPolicyFile, TAG_BLOCKED_PKGS, mHaloBlacklist, ATTR_HALO_POLICY_IS_BLACK, 1) == 1;
+            mHaloWhitelist.clear();
+            readPolicy(mHaloPolicyFile, TAG_ALLOWED_PKGS, mHaloWhitelist);
+        }
+    }
+
     private void writeBlockDb() {
         synchronized(mBlockedPackages) {
             FileOutputStream outfile = null;
@@ -270,6 +290,91 @@ public class NotificationManagerService extends INotificationManager.Stub
         }
     }
 
+    private synchronized void writeHaloBlockDb() {
+        FileOutputStream outfile = null;
+        try {
+            outfile = mHaloPolicyFile.startWrite();
+
+            XmlSerializer out = new FastXmlSerializer();
+            out.setOutput(outfile, "utf-8");
+
+            out.startDocument(null, true);
+
+            out.startTag(null, TAG_BODY); {
+                out.attribute(null, ATTR_VERSION, String.valueOf(DB_VERSION));
+                out.attribute(null, ATTR_HALO_POLICY_IS_BLACK, (mHaloPolicyisBlack ? "1" : "0"));
+
+                    out.startTag(null, TAG_BLOCKED_PKGS); {
+                        for (String blockedPkg : mHaloBlacklist) {
+                            out.startTag(null, TAG_PACKAGE); {
+                                out.attribute(null, ATTR_NAME, blockedPkg);
+                            } out.endTag(null, TAG_PACKAGE);
+                        }
+                    } out.endTag(null, TAG_BLOCKED_PKGS);
+                    
+                    out.startTag(null, TAG_ALLOWED_PKGS); {
+                        for (String allowedPkg : mHaloWhitelist) {
+                            out.startTag(null, TAG_PACKAGE); {
+                                out.attribute(null, ATTR_NAME, allowedPkg);
+                            } out.endTag(null, TAG_PACKAGE);
+                        }
+                    } out.endTag(null, TAG_ALLOWED_PKGS);
+
+            } out.endTag(null, TAG_BODY);
+
+            out.endDocument();
+
+            mHaloPolicyFile.finishWrite(outfile);
+        } catch (IOException e) {
+            if (outfile != null) {
+                mHaloPolicyFile.failWrite(outfile);
+            }
+        }
+    }
+
+    public void setHaloPolicyBlack(boolean state) {
+        mHaloPolicyisBlack = state;
+        writeHaloBlockDb();
+    }
+
+    public void setHaloStatus(String pkg, boolean status) {
+        if (mHaloPolicyisBlack) {
+            setHaloBlacklistStatus(pkg, status);
+        } else {
+            setHaloWhitelistStatus(pkg, status);
+        }
+    }
+
+    public void setHaloBlacklistStatus(String pkg, boolean status) {
+        if (status) {
+            mHaloBlacklist.add(pkg);            
+        } else {
+            mHaloBlacklist.remove(pkg);
+        }
+        writeHaloBlockDb();
+    }
+
+    public void setHaloWhitelistStatus(String pkg, boolean status) {
+        if (status) {
+            mHaloWhitelist.add(pkg);            
+        } else {
+            mHaloWhitelist.remove(pkg);
+        }
+        writeHaloBlockDb();
+    }
+
+    public boolean isHaloPolicyBlack() {
+        return mHaloPolicyisBlack;
+    }
+
+    public boolean isPackageAllowedForHalo(String pkg) {
+        if (mHaloPolicyisBlack) {
+            return !mHaloBlacklist.contains(pkg);
+        } else {
+            return mHaloWhitelist.contains(pkg);
+        }
+    }
+
     public boolean areNotificationsEnabledForPackage(String pkg) {
         checkCallerIsSystem();
         return areNotificationsEnabledForPackageInt(pkg);
@@ -730,6 +835,7 @@ public class NotificationManagerService extends INotificationManager.Stub
         mHandler = new WorkerHandler();
 
         loadBlockDb();
+        loadHaloBlockDb();
 
         mStatusBar = statusBar;
         statusBar.setNotificationCallbacks(mNotificationCallbacks);
diff --git a/services/java/com/android/server/SystemServer.java b/services/java/com/android/server/SystemServer.java
index 1b2b65d..629c8e9 100644
--- a/services/java/com/android/server/SystemServer.java
+++ b/services/java/com/android/server/SystemServer.java
@@ -77,6 +77,12 @@ import dalvik.system.Zygote;
 import java.io.File;
 import java.util.Timer;
 import java.util.TimerTask;
+
+// BEGIN privacy-added
+import android.privacy.PrivacySettingsManagerService;
+//import android.privacy.surrogate.PrivacyTelephonyRegistry;
+// END privacy-added
+
 import com.stericsson.hardware.fm.FmReceiverService;
 import com.stericsson.hardware.fm.FmTransmitterService;
 
@@ -245,7 +251,10 @@ class ServerThread extends Thread {
             ServiceManager.addService(Context.DISPLAY_SERVICE, display, true);
 
             Slog.i(TAG, "Telephony Registry");
-            telephonyRegistry = new TelephonyRegistry(context);
+            // BEGIN privacy-modified
+            // telephonyRegistry = new TelephonyRegistry(context);
+            telephonyRegistry = new PrivacyTelephonyRegistry(context);
+            // END privacy-modified
             ServiceManager.addService("telephony.registry", telephonyRegistry);
 
             Slog.i(TAG, "Scheduling Policy");
@@ -301,6 +310,10 @@ class ServerThread extends Thread {
             contentService = ContentService.main(context,
                     factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL);
 
+            // BEGIN privacy-added
+            addPrivacyService(context);
+            // END privacy-added
+
             Slog.i(TAG, "System Content Providers");
             ActivityManagerService.installSystemProviders();
 
@@ -1123,6 +1136,19 @@ class ServerThread extends Thread {
         //Slog.d(TAG, "Starting service: " + intent);
         context.startServiceAsUser(intent, UserHandle.OWNER);
     }
+
+    // BEGIN privacy-added
+    private void addPrivacyService(Context context) {
+        try {
+            Slog.i(TAG, "Privacy Service");
+            ServiceManager.addService("privacy", new PrivacySettingsManagerService(context));
+        } catch (Throwable e) {
+            Log.e(TAG, "Failure starting Privacy Service", e);
+        }
+    }
+    // END privacy-added
+
+
 }
 
 public class SystemServer {
diff --git a/services/java/com/android/server/TelephonyRegistry.java b/services/java/com/android/server/TelephonyRegistry.java
index 17260d5..2b2177d 100644
--- a/services/java/com/android/server/TelephonyRegistry.java
+++ b/services/java/com/android/server/TelephonyRegistry.java
@@ -63,7 +63,10 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
     private static final boolean DBG = false;
     private static final boolean DBG_LOC = false;
 
-    private static class Record {
+    // BEGIN privacy-modified
+    // private static class Record {
+    public static class Record {
+    // END privacy-modified
         String pkgForDebug;
 
         IBinder binder;
@@ -81,29 +84,32 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
         }
     }
 
-    private final Context mContext;
+    // BEGIN privacy-modified
+    // these were all private, now protected
+
+    protected final Context mContext;
 
     // access should be inside synchronized (mRecords) for these two fields
-    private final ArrayList<IBinder> mRemoveList = new ArrayList<IBinder>();
-    private final ArrayList<Record> mRecords = new ArrayList<Record>();
+    protected final ArrayList<IBinder> mRemoveList = new ArrayList<IBinder>();
+    protected final ArrayList<Record> mRecords = new ArrayList<Record>();
 
     private final IBatteryStats mBatteryStats;
 
-    private int mCallState = TelephonyManager.CALL_STATE_IDLE;
+    protected int mCallState = TelephonyManager.CALL_STATE_IDLE;
 
-    private String mCallIncomingNumber = "";
+    protected String mCallIncomingNumber = "";
 
-    private ServiceState mServiceState = new ServiceState();
+    protected ServiceState mServiceState = new ServiceState();
 
-    private SignalStrength mSignalStrength = new SignalStrength();
+    protected SignalStrength mSignalStrength = new SignalStrength();
 
-    private boolean mMessageWaiting = false;
+    protected boolean mMessageWaiting = false;
 
-    private boolean mCallForwarding = false;
+    protected boolean mCallForwarding = false;
 
-    private int mDataActivity = TelephonyManager.DATA_ACTIVITY_NONE;
+    protected int mDataActivity = TelephonyManager.DATA_ACTIVITY_NONE;
 
-    private int mDataConnectionState = TelephonyManager.DATA_UNKNOWN;
+    protected int mDataConnectionState = TelephonyManager.DATA_UNKNOWN;
 
     private boolean mDataConnectionPossible = false;
 
@@ -117,14 +123,14 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
 
     private LinkCapabilities mDataConnectionLinkCapabilities;
 
-    private Bundle mCellLocation = new Bundle();
+    protected Bundle mCellLocation = new Bundle();
 
-    private int mDataConnectionNetworkType;
+    protected int mDataConnectionNetworkType;
 
-    private int mOtaspMode = ServiceStateTracker.OTASP_UNKNOWN;
-
-    private List<CellInfo> mCellInfo = null;
+    protected int mOtaspMode = ServiceStateTracker.OTASP_UNKNOWN;
 
+    protected List<CellInfo> mCellInfo = null;
+    // END privacy-modified
     static final int PHONE_STATE_PERMISSION_MASK =
                 PhoneStateListener.LISTEN_CALL_FORWARDING_INDICATOR |
                 PhoneStateListener.LISTEN_CALL_STATE |
@@ -165,7 +171,11 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
     // calls go through a oneway interface and local calls going through a
     // handler before they get to app code.
 
-    TelephonyRegistry(Context context) {
+    // BEGIN privacy-modified
+    // made protected to allow subclassing
+    // TelephonyRegistry(Context context) {
+    protected TelephonyRegistry(Context context) {
+    // END privacy-modified
         CellLocation  location = CellLocation.getEmpty();
 
         // Note that location can be null for non-phone builds like
@@ -312,7 +322,11 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
         }
     }
 
-    private void remove(IBinder binder) {
+    // BEGIN privacy-modified
+    // made protected to allow subclassing
+    // private void remove(IBinder binder) {
+    protected void remove(IBinder binder) {
+    // END privacy-modified
         synchronized (mRecords) {
             final int recordCount = mRecords.size();
             for (int i = 0; i < recordCount; i++) {
@@ -351,9 +365,15 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
         }
         synchronized (mRecords) {
             mServiceState = state;
+            // BEGIN privacy-added
+	        mServiceState.setOperatorName("", "", "");
+	        // END privacy-added
             for (Record r : mRecords) {
                 if ((r.events & PhoneStateListener.LISTEN_SERVICE_STATE) != 0) {
                     try {
+                        // BEGIN privacy-added
+			            state.setOperatorName("", "", "");
+			            // END privacy-added
                         r.callback.onServiceStateChanged(new ServiceState(state));
                     } catch (RemoteException ex) {
                         mRemoveList.add(r.binder);
@@ -639,7 +659,11 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
     // the legacy intent broadcasting
     //
 
-    private void broadcastServiceStateChanged(ServiceState state) {
+    // BEGIN privacy-modified
+    // made protected to allow subclassing
+    // private void broadcastServiceStateChanged(ServiceState state) {
+    protected void broadcastServiceStateChanged(ServiceState state) {
+    // END privacy-modified
         long ident = Binder.clearCallingIdentity();
         try {
             mBatteryStats.notePhoneState(state.getState());
@@ -738,7 +762,10 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
         mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
     }
 
-    private boolean checkNotifyPermission(String method) {
+    // BEGIN privacy-modified
+    // made protected to allow subclassing
+    protected boolean checkNotifyPermission(String method) {
+    // END privacy-modified
         if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
                 == PackageManager.PERMISSION_GRANTED) {
             return true;
@@ -749,7 +776,10 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
         return false;
     }
 
-    private void checkListenerPermission(int events) {
+    // BEGIN privacy-modified
+    // made protected to allow subclassing
+    protected void checkListenerPermission(int events) {
+    // END privacy-modified
         if ((events & PhoneStateListener.LISTEN_CELL_LOCATION) != 0) {
             mContext.enforceCallingOrSelfPermission(
                     android.Manifest.permission.ACCESS_COARSE_LOCATION, null);
@@ -768,7 +798,10 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
         }
     }
 
-    private void handleRemoveListLocked() {
+    // BEGIN privacy-modified
+    // made protected to allow subclassing
+    protected void handleRemoveListLocked() {
+    // END privacy-modified
         if (mRemoveList.size() > 0) {
             for (IBinder b: mRemoveList) {
                 remove(b);
diff --git a/services/java/com/android/server/am/ActivityRecord.java b/services/java/com/android/server/am/ActivityRecord.java
index de0f9ca..32aa93f 100644
--- a/services/java/com/android/server/am/ActivityRecord.java
+++ b/services/java/com/android/server/am/ActivityRecord.java
@@ -23,6 +23,7 @@ import com.android.server.am.ActivityStack.ActivityState;
 import android.app.Activity;
 import android.app.ActivityOptions;
 import android.content.ComponentName;
+import android.content.Context;
 import android.content.Intent;
 import android.content.pm.ActivityInfo;
 import android.content.pm.ApplicationInfo;
@@ -42,6 +43,7 @@ import android.util.EventLog;
 import android.util.Log;
 import android.util.Slog;
 import android.util.TimeUtils;
+import android.view.ContextThemeWrapper;
 import android.view.IApplicationToken;
 import android.view.WindowManager;
 
@@ -124,6 +126,10 @@ final class ActivityRecord {
     boolean immersive;      // immersive mode (don't interrupt if possible)
     boolean forceNewConfig; // force re-create with new config next time
 
+    boolean topIntent;
+    boolean newTask;
+    boolean floatingWindow;
+
     String stringName;      // for caching of toString().
     
     private boolean inHistory;  // are we in the history stack?
@@ -380,6 +386,7 @@ final class ActivityRecord {
                 labelRes = app.labelRes;
             }
             icon = aInfo.getIconResource();
+
             theme = aInfo.getThemeResource();
             realTheme = theme;
             if (realTheme == 0) {
@@ -388,6 +395,51 @@ final class ActivityRecord {
                         ? android.R.style.Theme
                         : android.R.style.Theme_Holo;
             }
+
+            // This is where the package gets its first context from the attribute-cache
+            // In order to hook its attributes we set up our check for floating mutil windows here.
+            topIntent = true;
+
+            floatingWindow = (intent.getFlags() & Intent.FLAG_FLOATING_WINDOW) == Intent.FLAG_FLOATING_WINDOW;
+
+            ActivityRecord baseRecord = stack.mHistory.size() > 0 ? stack.mHistory.get(stack.mHistory.size() -1) : null;
+
+            if (baseRecord != null) {
+
+                final boolean floats = (baseRecord.intent.getFlags() & Intent.FLAG_FLOATING_WINDOW) == Intent.FLAG_FLOATING_WINDOW;
+                final boolean taskAffinity = aInfo.applicationInfo.packageName.equals(baseRecord.packageName);
+                newTask = (intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) == Intent.FLAG_ACTIVITY_NEW_TASK;
+
+                // If the current intent is not a new task we will check its top parent.
+                // Perhaps it started out as a multiwindow in which case we pass the flag on
+                if (floats && (!newTask || taskAffinity)) {
+                    intent.addFlags(Intent.FLAG_FLOATING_WINDOW);
+                    // Flag the activity as sub-task
+                    topIntent = false;
+                    floatingWindow = true;
+                }
+            }
+
+            // If this is a multiwindow activity we prevent it from messing up the history stack,
+            // like jumping back home, killing the current activity or polluting recents
+            if (floatingWindow) {
+                intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_TASK_ON_HOME);
+                intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_SINGLE_TOP);
+                intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_CLEAR_TOP);
+                intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
+                intent.addFlags(Intent.FLAG_ACTIVITY_NO_USER_ACTION);
+                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                
+                // If this is the mother-intent we make it volatile
+                if (topIntent) {
+                    intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
+                    intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
+                }
+
+                // Change theme
+                realTheme = com.android.internal.R.style.Theme_DeviceDefault_FloatingWindow;
+            }
+
             if ((aInfo.flags&ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0) {
                 windowFlags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
             }
@@ -406,7 +458,7 @@ final class ActivityRecord {
             
             packageName = aInfo.applicationInfo.packageName;
             launchMode = aInfo.launchMode;
-            
+
             AttributeCache.Entry ent = AttributeCache.instance().get(userId, packageName,
                     realTheme, com.android.internal.R.styleable.Window);
             fullscreen = ent != null && !ent.array.getBoolean(
diff --git a/services/java/com/android/server/am/ActivityStack.java b/services/java/com/android/server/am/ActivityStack.java
index 885ec89..98db9e0 100644
--- a/services/java/com/android/server/am/ActivityStack.java
+++ b/services/java/com/android/server/am/ActivityStack.java
@@ -58,6 +58,7 @@ import android.os.ServiceManager;
 import android.os.SystemClock;
 import android.os.SystemProperties;
 import android.os.UserHandle;
+import android.provider.Settings;
 import android.util.EventLog;
 import android.util.Log;
 import android.util.Slog;
@@ -1531,7 +1532,7 @@ final class ActivityStack {
         
         // We need to start pausing the current activity so the top one
         // can be resumed...
-        if (mResumedActivity != null) {
+        if (mResumedActivity != null && (pauseActiveAppWhenUsingHalo() || !next.floatingWindow)) {
             if (DEBUG_SWITCH) Slog.v(TAG, "Skip resume: need to start pausing");
             // At this point we want to put the upcoming activity's process
             // at the top of the LRU list, since we know we will be needing it
@@ -1610,7 +1611,7 @@ final class ActivityStack {
             if (prev.finishing) {
                 if (DEBUG_TRANSITION) Slog.v(TAG,
                         "Prepare close transition: prev=" + prev);
-                if (mNoAnimActivities.contains(prev)) {
+                if (mNoAnimActivities.contains(prev) || next.floatingWindow) {
                     mService.mWindowManager.prepareAppTransition(
                             WindowManagerPolicy.TRANSIT_NONE, false);
                 } else {
@@ -1623,7 +1624,7 @@ final class ActivityStack {
             } else {
                 if (DEBUG_TRANSITION) Slog.v(TAG,
                         "Prepare open transition: prev=" + prev);
-                if (mNoAnimActivities.contains(next)) {
+                if (mNoAnimActivities.contains(next) || next.floatingWindow) {
                     noAnim = true;
                     mService.mWindowManager.prepareAppTransition(
                             WindowManagerPolicy.TRANSIT_NONE, false);
@@ -1755,7 +1756,7 @@ final class ActivityStack {
                 if (!next.hasBeenLaunched) {
                     next.hasBeenLaunched = true;
                 } else {
-                    if (SHOW_APP_STARTING_PREVIEW && mMainStack) {
+                    if (SHOW_APP_STARTING_PREVIEW && mMainStack && !next.floatingWindow) {
                         mService.mWindowManager.setAppStartingWindow(
                                 next.appToken, next.packageName, next.theme,
                                 mService.compatibilityInfoForPackageLocked(
@@ -1789,7 +1790,7 @@ final class ActivityStack {
             if (!next.hasBeenLaunched) {
                 next.hasBeenLaunched = true;
             } else {
-                if (SHOW_APP_STARTING_PREVIEW) {
+                if (SHOW_APP_STARTING_PREVIEW && !next.floatingWindow) {
                     mService.mWindowManager.setAppStartingWindow(
                             next.appToken, next.packageName, next.theme,
                             mService.compatibilityInfoForPackageLocked(
@@ -1888,12 +1889,13 @@ final class ActivityStack {
             }
             if (DEBUG_TRANSITION) Slog.v(TAG,
                     "Prepare open transition: starting " + r);
-            if ((r.intent.getFlags()&Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
+
+            if (((r.intent.getFlags()&Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) || (r.floatingWindow && !r.topIntent)) {
                 mService.mWindowManager.prepareAppTransition(
                         WindowManagerPolicy.TRANSIT_NONE, keepCurTransition);
                 mNoAnimActivities.add(r);
             } else {
-                mService.mWindowManager.prepareAppTransition(newTask
+                mService.mWindowManager.prepareAppTransition(newTask && !r.floatingWindow
                         ? WindowManagerPolicy.TRANSIT_TASK_OPEN
                         : WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN, keepCurTransition);
                 mNoAnimActivities.remove(r);
@@ -1915,7 +1917,7 @@ final class ActivityStack {
                     doShow = topRunningNonDelayedActivityLocked(null) == r;
                 }
             }
-            if (SHOW_APP_STARTING_PREVIEW && doShow) {
+            if (SHOW_APP_STARTING_PREVIEW && doShow && !r.floatingWindow) {
                 // Figure out if we are transitioning from another activity that is
                 // "has the same starting icon" as the next one.  This allows the
                 // window manager to keep the previous window it had previously
@@ -3816,7 +3818,7 @@ final class ActivityStack {
                     || (mHistory.get(index-1)).task != r.task;
             if (DEBUG_TRANSITION) Slog.v(TAG,
                     "Prepare close transition: finishing " + r);
-            mService.mWindowManager.prepareAppTransition(endTask
+            mService.mWindowManager.prepareAppTransition(endTask && !r.floatingWindow
                     ? WindowManagerPolicy.TRANSIT_TASK_CLOSE
                     : WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE, false);
     
@@ -4302,7 +4304,7 @@ final class ActivityStack {
         if (top < 0 || (mHistory.get(top)).task.taskId == task) {
             // nothing to do!
             if (reason != null &&
-                    (reason.intent.getFlags()&Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
+                    ((reason.intent.getFlags()&Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0 || reason.floatingWindow)) {
                 ActivityOptions.abort(options);
             } else {
                 updateTransitLocked(WindowManagerPolicy.TRANSIT_TASK_TO_FRONT, options);
@@ -4341,7 +4343,7 @@ final class ActivityStack {
         if (DEBUG_TRANSITION) Slog.v(TAG,
                 "Prepare to front transition: task=" + tr);
         if (reason != null &&
-                (reason.intent.getFlags()&Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
+                ((reason.intent.getFlags()&Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0 || reason.floatingWindow)) {
             mService.mWindowManager.prepareAppTransition(
                     WindowManagerPolicy.TRANSIT_NONE, false);
             ActivityRecord r = topRunningActivityLocked(null);
@@ -4434,7 +4436,7 @@ final class ActivityStack {
         }
 
         if (reason != null &&
-                (reason.intent.getFlags()&Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
+                ((reason.intent.getFlags()&Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0 || reason.floatingWindow)) {
             mService.mWindowManager.prepareAppTransition(
                     WindowManagerPolicy.TRANSIT_NONE, false);
             ActivityRecord r = topRunningActivityLocked(null);
@@ -4754,7 +4756,13 @@ final class ActivityStack {
 
         return true;
     }
-    
+
+    private boolean pauseActiveAppWhenUsingHalo() {
+        int isLowRAM = (ActivityManager.isLargeRAM()) ? 0 : 1;
+        return Settings.System.getInt(mContext.getContentResolver(),
+                Settings.System.HALO_PAUSE, isLowRAM) == 1;
+    }
+
     public void dismissKeyguardOnNextActivityLocked() {
         mDismissKeyguardOnNextActivity = true;
     }
diff --git a/services/java/com/android/server/am/BroadcastQueue.java b/services/java/com/android/server/am/BroadcastQueue.java
index bada7f0..a26394e 100644
--- a/services/java/com/android/server/am/BroadcastQueue.java
+++ b/services/java/com/android/server/am/BroadcastQueue.java
@@ -41,6 +41,8 @@ import android.util.EventLog;
 import android.util.Log;
 import android.util.Slog;
 
+import android.privacy.surrogate.PrivacyActivityManagerService;
+
 /**
  * BROADCASTS
  *
@@ -635,6 +637,29 @@ public class BroadcastQueue {
             }
 
             Object nextReceiver = r.receivers.get(recIdx);
+            // BEGIN privacy-added
+            enforcePrivacyPermission(nextReceiver, r);
+            boolean empty = false;
+            if(r != null && r.intent != null && r.intent.getAction() != null && r.intent.getAction().equals("catchBootComplete")){
+               empty = true;
+//             String packageName = null;
+//             try { // try to get intent receiver information
+//                    if (nextReceiver instanceof BroadcastFilter) {
+//                        packageName = ((BroadcastFilter) nextReceiver).receiverList.app.info.packageName;
+//                    } else if (nextReceiver instanceof ResolveInfo) {
+//                        packageName = ((ResolveInfo) nextReceiver).activityInfo.applicationInfo.packageName;
+//                    }
+//                } catch (Exception e) {
+//                    // if above information is not available, exception will be thrown
+//                    // do nothing, this is not our intent
+//
+//                }
+//             if(packageName != null)
+//                     Log.i("PrivacyBroadcast", "empty=true -> INTENT_BOOT_COMPLETE should be skipped! package: " + packageName);
+//             else
+//                     Log.i("PrivacyBroadcast", "empty=true -> INTENT_BOOT_COMPLETE should be skipped! package: " + "UNKNOWN");
+            }
+            // END privacy-added
             if (nextReceiver instanceof BroadcastFilter) {
                 // Simple case: this is a registered receiver who gets
                 // a direct call.
@@ -643,7 +668,15 @@ public class BroadcastQueue {
                         "Delivering ordered ["
                         + mQueueName + "] to registered "
                         + filter + ": " + r);
-                deliverToRegisteredReceiverLocked(r, filter, r.ordered);
+                if(!empty){
+                       deliverToRegisteredReceiverLocked(r, filter, r.ordered);
+                } else{
+                       //Log.i("PrivacyBroadcast","set r.receiver to null");
+                       r.receiver = null;
+                    r.curFilter = null;
+                    //re-initalize
+                    r.intent.setAction(Intent.ACTION_BOOT_COMPLETED);
+                }
                 if (r.receiver == null || !r.ordered) {
                     // The receiver has already finished, so schedule to
                     // process the next one.
@@ -735,6 +768,12 @@ public class BroadcastQueue {
                 skip = true;
             }
 
+            //PRIVACY BEGIN
+            if(empty){
+               skip = true;
+               r.intent.setAction(Intent.ACTION_BOOT_COMPLETED);
+            }
+            //PRIVACY END
             if (skip) {
                 if (DEBUG_BROADCAST)  Slog.v(TAG,
                         "Skipping delivery of ordered ["
@@ -830,6 +869,33 @@ public class BroadcastQueue {
         }
     }
 
+    // BEGIN privacy-added
+    private void enforcePrivacyPermission(Object nextReceiver, BroadcastRecord r) {
+        if (r != null && r.intent != null && r.intent.getAction() != null) {
+
+            String packageName = null;
+            int uid = -1;
+            try { // try to get intent receiver information
+                if (nextReceiver instanceof BroadcastFilter) {
+                    packageName = ((BroadcastFilter) nextReceiver).receiverList.app.info.packageName;
+                    uid = ((BroadcastFilter) nextReceiver).receiverList.app.info.uid;
+                } else if (nextReceiver instanceof ResolveInfo) {
+                    packageName = ((ResolveInfo) nextReceiver).activityInfo.applicationInfo.packageName;
+                    uid = ((ResolveInfo) nextReceiver).activityInfo.applicationInfo.uid;
+                }
+            } catch (Exception e) {
+                // if above information is not available, exception will be thrown
+                // do nothing, this is not our intent
+                return;
+            }
+
+            if (packageName != null && uid != -1) {
+                PrivacyActivityManagerService.enforcePrivacyPermission(packageName, uid, r.intent, null, r.receivers.size());
+            }
+        }
+    }
+    // END privacy-added
+
     final void setBroadcastTimeoutLocked(long timeoutTime) {
         if (! mPendingBroadcastTimeoutMessage) {
             Message msg = mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG, this);
diff --git a/services/java/com/android/server/power/PowerManagerService.java b/services/java/com/android/server/power/PowerManagerService.java
index 0d2ba34..2ed8fa0 100644
--- a/services/java/com/android/server/power/PowerManagerService.java
+++ b/services/java/com/android/server/power/PowerManagerService.java
@@ -352,6 +352,14 @@ public final class PowerManagerService extends IPowerManager.Stub
     // Use -1 to disable.
     private int mButtonBrightnessOverrideFromWindowManager = -1;
 
+    // The button backlight preference from settings
+    // 0 = turn on when screen touched
+    // 1 = off
+    // 2 = on
+    // 3 = force off
+    // 4 = force on
+    private int mButtonModeSetting = 0;
+
     // The user activity timeout override from the window manager
     // to allow the current foreground activity to override the user activity timeout.
     // Use -1 to disable.
@@ -515,6 +523,9 @@ public final class PowerManagerService extends IPowerManager.Stub
             resolver.registerContentObserver(Settings.System.getUriFor(
                     Settings.System.AUTO_BRIGHTNESS_RESPONSIVENESS),
                     false, mSettingsObserver, UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.BUTTON_BACKLIGHT_MODE),
+                    false, mSettingsObserver, UserHandle.USER_ALL);
 
             // Go.
             readConfigurationLocked();
@@ -592,6 +603,10 @@ public final class PowerManagerService extends IPowerManager.Stub
         mAutoBrightnessResponsitivityFactor =
                 Math.min(Math.max(newAutoBrightnessResponsitivityFactor, 0.2f), 3.0f);
 
+        mButtonModeSetting = Settings.System.getIntForUser(resolver,
+                Settings.System.BUTTON_BACKLIGHT_MODE,
+                0, UserHandle.USER_CURRENT);
+
         mDirty |= DIRTY_SETTINGS;
     }
 
@@ -1376,14 +1391,27 @@ public final class PowerManagerService extends IPowerManager.Stub
                     nextTimeout = mLastUserActivityTime
                             + screenOffTimeout - screenDimDuration;
                     if (now < nextTimeout) {
-                        int brightness = mButtonBrightnessOverrideFromWindowManager >= 0
-                                ? mButtonBrightnessOverrideFromWindowManager
-                                : mDisplayPowerRequest.screenBrightness;
-                        mKeyboardLight.setBrightness(mKeyboardVisible ? brightness : 0);
                         if (now > mLastUserActivityTime + BUTTON_ON_DURATION) {
-                            mButtonsLight.setBrightness(0);
+                            // Default or force on
+                            int brightness = mButtonModeSetting == 2
+                                    || mButtonModeSetting == 4
+                                    ? mDisplayPowerRequest.screenBrightness : 0;
+                            mButtonsLight.setBrightness(brightness);
+                            mKeyboardLight.setBrightness(brightness);
                         } else {
+                            int brightness = mDisplayPowerRequest.screenBrightness;
+                            if (mButtonModeSetting == 1
+                                    || mButtonModeSetting == 3) {
+                                // Default or force off
+                                brightness = 0;
+                            }
+                            if (mButtonModeSetting < 3) { // Not forcing
+                                brightness = mButtonBrightnessOverrideFromWindowManager >= 0
+                                        ? mButtonBrightnessOverrideFromWindowManager
+                                        : brightness;
+                            }
                             mButtonsLight.setBrightness(brightness);
+                            mKeyboardLight.setBrightness(brightness);
                             if (brightness != 0) {
                                 nextTimeout = now + BUTTON_ON_DURATION;
                             }
diff --git a/telephony/java/android/telephony/CellInfoGsm.java b/telephony/java/android/telephony/CellInfoGsm.java
index bd14d45..dd4145d 100644
--- a/telephony/java/android/telephony/CellInfoGsm.java
+++ b/telephony/java/android/telephony/CellInfoGsm.java
@@ -48,7 +48,7 @@ public final class CellInfoGsm extends CellInfo implements Parcelable {
     public CellIdentityGsm getCellIdentity() {
         return mCellIdentityGsm;
     }
-    /** @hide */
+
     public void setCellIdentity(CellIdentityGsm cid) {
         mCellIdentityGsm = cid;
     }
diff --git a/telephony/java/android/telephony/PhoneStateListener.java b/telephony/java/android/telephony/PhoneStateListener.java
index f3ccae6..9d77147 100644
--- a/telephony/java/android/telephony/PhoneStateListener.java
+++ b/telephony/java/android/telephony/PhoneStateListener.java
@@ -16,16 +16,23 @@
 
 package android.telephony;
 
+// BEGIN privacy-added
+import com.android.internal.telephony.IPhoneStateListener;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.content.Context;
+// END privacy-added
+
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.Message;
-import android.telephony.ServiceState;
-import android.telephony.SignalStrength;
-import android.telephony.CellLocation;
+//import android.telephony.ServiceState;
+//import android.telephony.SignalStrength;
+//import android.telephony.CellLocation;
 import android.telephony.CellInfo;
-import android.util.Log;
+//import android.util.Log;
 
-import com.android.internal.telephony.IPhoneStateListener;
+//import com.android.internal.telephony.IPhoneStateListener;
 
 import java.util.List;
 
@@ -158,6 +165,29 @@ public class PhoneStateListener {
      */
     public static final int LISTEN_OTASP_CHANGED                            = 0x00000200;
 
+    // BEGIN privacy-added
+    private Context context;
+    private String packageName;
+    private int uid;
+    private final static String TAG = "PhoneStateListener"; 
+    
+    /** {@hide} */
+    public void setContext(Context context) {
+        this.context = context;
+    }
+    
+    /** {@hide} */
+    public void setPackageName(String packageName) {
+        this.packageName = packageName;
+    }
+    
+    /** {@hide} */
+    public void setUid(int uid) {
+        this.uid = uid;
+    }    
+    // END privacy-added
+ 
+
     /**
      * Listen for changes to observed cell info.
      *
@@ -317,11 +347,51 @@ public class PhoneStateListener {
 
         public void onCellLocationChanged(Bundle bundle) {
             CellLocation location = CellLocation.newFromBundle(bundle);
-            Message.obtain(mHandler, LISTEN_CELL_LOCATION, 0, 0, location).sendToTarget();
+            //Message.obtain(mHandler, LISTEN_CELL_LOCATION, 0, 0, location).sendToTarget();
+            // BEGIN privacy-modified
+            if (context != null) {
+                PrivacySettingsManager pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+                PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+//                String output;
+                if (pSet != null && pSet.getLocationNetworkSetting() != PrivacySettings.REAL) {
+                    // simply block the method call, since simulating cell location is not feasible
+//                    output = "[no output]";
+                    pSetMan.notification(packageName, uid, pSet.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);            
+                } else {
+//                    output = location.toString();
+                    Message.obtain(mHandler, LISTEN_CELL_LOCATION, 0, 0, location).sendToTarget();
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);            
+                }
+//                Log.d(TAG, "onCellLocationChanged - " + context.getPackageName() + " (" + 
+//                        Binder.getCallingUid() + ") output: " + output);
+            }
+            // END privacy-modified
         }
 
         public void onCallStateChanged(int state, String incomingNumber) {
-            Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, incomingNumber).sendToTarget();
+            //Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, incomingNumber).sendToTarget();
+            // BEGIN privacy-modified
+//            Log.d(TAG, "onCallStateChanged - state:" + state + " incoming number:" + incomingNumber);
+            // only take action if an incoming phone number is actually transmitted
+            if (context != null && incomingNumber != null && !incomingNumber.isEmpty()) {
+                PrivacySettingsManager pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+                PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+                String output;
+                if (pSet != null && pSet.getIncomingCallsSetting() != PrivacySettings.REAL) {
+                    output = "";
+                    Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, output).sendToTarget();
+//                    Log.d(TAG, "onCallStateChanged BLOCK - package:" + packageName + " uid:" + uid + " state:" + state + " output: " + output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_INCOMING_CALL, output, pSet);
+                } else {
+                    Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, incomingNumber).sendToTarget();
+//                    Log.d(TAG, "onCallStateChanged REAL 1 - package:" + packageName + " uid:" + uid + " state:" + state + " output: " + incomingNumber);
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_INCOMING_CALL, incomingNumber, pSet);
+                }
+            } else {
+//                Log.d(TAG, "onCallStateChanged REAL 2 - package:" + packageName + " uid:" + uid + " state:" + state + " output: " + incomingNumber);
+                Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, incomingNumber).sendToTarget();
+            }
+            // END privacy-modified
         }
 
         public void onDataConnectionStateChanged(int state, int networkType) {
diff --git a/telephony/java/android/telephony/ServiceState.java b/telephony/java/android/telephony/ServiceState.java
index 6e834db..9a671a7 100644
--- a/telephony/java/android/telephony/ServiceState.java
+++ b/telephony/java/android/telephony/ServiceState.java
@@ -489,7 +489,10 @@ public class ServiceState implements Parcelable {
                 + " EmergOnly=" + mIsEmergencyOnly);
     }
 
-    private void setNullState(int state) {
+   // BEGIN privacy-modified
+   // Was originally private
+   void setNullState(int state) {
+   // END privacy-modified
         mState = state;
         mRoaming = false;
         mOperatorAlphaLong = null;
diff --git a/wifi/java/android/net/wifi/WifiInfo.java b/wifi/java/android/net/wifi/WifiInfo.java
index 05db571..2bdb2f5 100644
--- a/wifi/java/android/net/wifi/WifiInfo.java
+++ b/wifi/java/android/net/wifi/WifiInfo.java
@@ -78,6 +78,24 @@ public class WifiInfo implements Parcelable {
      */
     private boolean mMeteredHint;
 
+
+    // BEGIN privacy-added
+    /**
+     * Constructor for faking WifiInfo
+     * @hide
+     */
+    public WifiInfo(boolean fake){
+    	mWifiSsid = WifiSsid.createFromAsciiEncoded("");
+        mBSSID = "";
+        mNetworkId = -1;
+        mSupplicantState = SupplicantState.UNINITIALIZED;
+        mRssi = -9999;
+        mLinkSpeed = -1;
+        mHiddenSSID = false;
+    }
+    // END privacy-added
+
+
     WifiInfo() {
         mWifiSsid = null;
         mBSSID = null;
